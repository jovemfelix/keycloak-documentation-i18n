msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n\n"
"POT-Creation-Date: 2017-09-21 04:04+0000\n"
"PO-Revision-Date: 2017-10-06 03:50-0400\n"
"Last-Translator: wadahiro <wadahiro@gmail.com>\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: crowdin.com\n"
"X-Crowdin-Project: keycloak-documentation-i18n\n"
"X-Crowdin-Language: ja\n"
"X-Crowdin-File: /develop/i18n/po/ja_JP/securing_apps__topics__overview__supported-protocols.ja_JP.po\n"

#. type: Title ==
#: source/securing_apps/topics/overview/supported-platforms.adoc:3
#: source/securing_apps/topics/overview/supported-protocols.adoc:5
#: source/securing_apps/topics/oidc/oidc-overview.adoc:1
#, no-wrap
msgid "OpenID Connect"
msgstr "OpenID Connect"

#. type: Title ===
#: source/securing_apps/topics/overview/supported-protocols.adoc:3
#, no-wrap
msgid "Supported Protocols"
msgstr "サポートされているプロトコル"

#. type: Plain text
#: source/securing_apps/topics/overview/supported-protocols.adoc:11
#: source/server_admin/topics/sso-protocols/oidc.adoc:9
msgid "link:http://openid.net/connect/[Open ID Connect] (OIDC) is an authentication protocol that is an extension of link:https://tools.ietf.org/html/rfc6749[OAuth 2.0].  While OAuth 2.0 is only a framework for building authorization protocols and is mainly incomplete, OIDC is a full-fledged authentication and authorization protocol.  OIDC also makes heavy use of the link:https://jwt.io[Json Web Token] (JWT) set of standards.  These standards define an identity token JSON format and ways to digitally sign and encrypt that data in a compact and web-friendly way."
msgstr "link:http://openid.net/connect/[Open ID Connect] (OIDC)は link:https://tools.ietf.org/html/rfc6749[OAuth 2.0] を拡張した認証プロトコルです。OAuth 2.0が認可プロトコルのみを構築するためのフレームワークで、不完全であるのに対し、OIDCは完成された認証および認可のプロトコルです。OIDCはまた、 link:https://jwt.io[Json Web Token] (JWT)の標準セットを多用します。これらの標準は、コンパクトでwebフレンドリーな方法で、アイデンティティー・トークンのJSON形式とデジタル署名、データ暗号化の方法を定義します。"

#. type: Plain text
#: source/securing_apps/topics/overview/supported-protocols.adoc:17
msgid "There is really two types of use cases when using OIDC.  The first is an application that asks the {project_name} server to authenticate a user for them.  After a successful login, the application will receive an _identity token_ and an _access token_.  The _identity token_ contains information about the user such as username, email, and other profile information.  The _access token_ is digitally signed by the realm and contains access information (like user role mappings) that the application can use to determine what resources the user is allowed to access on the application."
msgstr "OIDCを使用するユース・ケースは、実際には2つの種類があります。1つ目は、{project_name}サーバーにユーザーの認証を要求するアプリケーションのユース・ケースです。ログインが成功すると、アプリケーションは _identity token_ と _access token_ を受け取ります。 _Identity token_ には、ユーザー名、電子メール、その他のプロファイル情報など、ユーザーに関する情報が含まれています。 _Access token_ はレルムによってデジタル署名されており、アプリケーションがユーザーのアクセス可能なリソースを決定するために使用できるアクセス情報(ユーザー・ロール・マッピングのような)が含まれています。"

#. type: Plain text
#: source/securing_apps/topics/overview/supported-protocols.adoc:24
#: source/server_admin/topics/sso-protocols/oidc.adoc:22
msgid "The second type of use cases is that of a client that wants to gain access to remote services.  In this case, the client asks {project_name} to obtain an _access token_ it can use to invoke on other remote services on behalf of the user.  {project_name} authenticates the user then asks the user for consent to grant access to the client requesting it.  The client then receives the _access token_.  This _access token_ is digitally signed by the realm.  The client can make REST invocations on remote services using this _access token_.  The REST service extracts the _access token_, verifies the signature of the token, then decides based on access information within the token whether or not to process the request."
msgstr "2つ目のタイプは、リモート・サービスへのアクセス権を取得したいクライアントのユース・ケースです。この場合、クライアントは、ユーザーの代理として他のリモート・サービスの呼び出しに使用できる _access token_ の取得を{project_name}に要求します。{project_name}は、ユーザーを認証し、クライアントのアクセスを許可する同意を要求します。そして、クライアントは _access token_ を受け取ります。この _access token_ はレルムによってデジタル署名されます。クライアントはこの _access token_ を使用して、リモート・サービスのREST呼び出しを行うことができます。REST サービスは _access token_ を抽出し、トークンの署名を検証し、トークン内のアクセス情報に基づいて、要求を処理するかどうかを決定します。"

#. type: Title ====
#: source/securing_apps/topics/overview/supported-protocols.adoc:25
#, no-wrap
msgid "SAML 2.0"
msgstr "SAML 2.0"

#. type: Plain text
#: source/securing_apps/topics/overview/supported-protocols.adoc:30
msgid "link:http://saml.xml.org/saml-specifications[SAML 2.0] is a similar specification to OIDC but a lot older and more mature.  It has its roots in SOAP and the plethora of WS-* specifications so it tends to be a bit more verbose than OIDC.  SAML 2.0 is primarily an authentication protocol that works by exchanging XML documents between the authentication server and the application.  XML signatures and encryption are used to verify requests and responses."
msgstr "link:http://saml.xml.org/saml-specifications[SAML 2.0] は、OIDCに似ていますが、それよりも古く成熟した仕様です。SOAPと過度なWS-*の仕様をそのルーツを持っているため、OIDCよりも少し冗長になる傾向があります。SAML 2.0は、主に認証サーバーとアプリケーション間のXMLドキュメントの交換によって動作する認証プロトコルです。XML署名と暗号化を使用して、要求と応答を検証します。"

#. type: Plain text
#: source/securing_apps/topics/overview/supported-protocols.adoc:32
msgid "In {project_name} SAML serves two types of use cases: browser applications and REST invocations."
msgstr "{project_name}において、SAMLはブラウザー・アプリケーションとREST呼び出しの2種類のユース・ケースを提供しています 。"

#. type: Plain text
#: source/securing_apps/topics/overview/supported-protocols.adoc:38
msgid "There is really two types of use cases when using SAML.  The first is an application that asks the {project_name} server to authenticate a user for them.  After a successful login, the application will receive an XML document that contains something called a SAML assertion that specifies various attributes about the user.  This XML document is digitally signed by the realm and contains access information (like user role mappings) that the application can use to determine what resources the user is allowed to access on the application."
msgstr "OIDCを使用するユース・ケースは、実際には2つの種類があります。1つ目は、{project_name}サーバーにユーザーの認証を要求するアプリケーションのユース・ケースです。ログインが成功すると、アプリケーションは ユーザーに関する様々な属性を指定するSAMLアサーションと呼ばれるものが含まれるXMLドキュメントを受け取ります。このXMLドキュメントはレルムによってデジタル署名されており、アプリケーションがユーザーのアクセス可能なリソースを決定するために使用できるアクセス情報(ユーザー・ロール・マッピングのような)が含まれています。"

#. type: Plain text
#: source/securing_apps/topics/overview/supported-protocols.adoc:41
msgid "The second type of use cases is that of a client that wants to gain access to remote services.  In this case, the client asks {project_name} to obtain a SAML assertion it can use to invoke on other remote services on behalf of the user."
msgstr "2つ目のタイプは、リモート・サービスへのアクセス権を取得したいクライアントのユース・ケースです。この場合、クライアントは、ユーザーの代理として他のリモート・サービスの呼び出しに使用できるSAMLアサーションの取得を{project_name}に要求します。"

#. type: Title ===
#: source/securing_apps/topics/overview/supported-protocols.adoc:42
#: source/server_admin/topics/sso-protocols/saml-vs-oidc.adoc:2
#, no-wrap
msgid "OpenID Connect vs. SAML"
msgstr "OpenID Connect vs. SAML"

#. type: Plain text
#: source/securing_apps/topics/overview/supported-protocols.adoc:45
#: source/server_admin/topics/sso-protocols/saml-vs-oidc.adoc:5
msgid "Choosing between OpenID Connect and SAML is not just a matter of using a newer protocol (OIDC) instead of the older more mature protocol (SAML)."
msgstr "OpenID ConnectとSAMLの選択は、古いより成熟したプロトコル(SAML)の代わりに新しいプロトコル(OIDC)を使用するだけの問題ではありません。"

#. type: Plain text
#: source/securing_apps/topics/overview/supported-protocols.adoc:47
#: source/server_admin/topics/sso-protocols/saml-vs-oidc.adoc:7
msgid "In most cases {project_name} recommends using OIDC."
msgstr "ほとんどの場合において、{project_name}ではOIDCを使用することをお勧めします。"

#. type: Plain text
#: source/securing_apps/topics/overview/supported-protocols.adoc:49
#: source/server_admin/topics/sso-protocols/saml-vs-oidc.adoc:9
msgid "SAML tends to be a bit more verbose than OIDC."
msgstr "SAMLは、OIDCよりも少し冗長になる傾向があります。"

#. type: Plain text
#: source/securing_apps/topics/overview/supported-protocols.adoc:54
#: source/server_admin/topics/sso-protocols/saml-vs-oidc.adoc:14
msgid "Beyond verbosity of exchanged data, if you compare the specifications you'll find that OIDC was designed to work with the web while SAML was retrofitted to work on top of the web.  For example, OIDC is also more suited for HTML5/JavaScript applications because it is easier to implement on the client side than SAML. As tokens are in the JSON format, they are easier to consume by JavaScript. You will also find several nice features that make implementing security in your web applications easier. For example, check out the link:http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification[iframe trick] that the specification uses to easily determine if a user is still logged in or not."
msgstr ""

#. type: Plain text
#: source/securing_apps/topics/overview/supported-protocols.adoc:56
#: source/server_admin/topics/sso-protocols/saml-vs-oidc.adoc:15
msgid "SAML has its uses though. As you see the OIDC specifications evolve you see they implement more and more features that SAML has had for years. What we often see is that people pick SAML over OIDC because of the perception that it is more mature and also because they already have existing applications that are secured with it."
msgstr ""

