# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Nomura Research Institute, Ltd.
# This file is distributed under the same license as the keycloak-documentation-i18n package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Hiroyuki Wada <wadahiro@gmail.com>, 2020
# Kohei Tamura <ktamura.biz.80@gmail.com>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n\n"
"Last-Translator: Kohei Tamura <ktamura.biz.80@gmail.com>, 2020\n"
"Language-Team: Japanese (Japan) (https://www.transifex.com/openstandia/teams/79437/ja_JP/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja_JP\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Plain text
#, no-wrap
msgid "Client Authentication"
msgstr "クライアント認証"

#. type: Plain text
msgid ""
"When a confidential OIDC client needs to send a backchannel request (for "
"example, to exchange code for the token, or to refresh the token) it needs "
"to authenticate against the {project_name} server. By default, there are "
"three ways to authenticate the client: client ID and client secret, client "
"authentication with signed JWT, or client authentication with signed JWT "
"using client secret."
msgstr ""
"コンフィデンシャルOIDCクライアントがバックチャネル・リクエストを送信する必要がある場合（たとえば、トークンのコードを交換したり、トークンをリフレッシュするような場合）、{project_name}サーバーに対して認証する必要があります。デフォルトでは、クライアントIDとクライアント・シークレット、署名付きJWTによるクライアント認証、またはクライアント・シークレットを使用した署名付きJWTによるクライアント認証の3つの方法でクライアントを認証します。"

#. type: Title =====
#, no-wrap
msgid "Client ID and Client Secret"
msgstr "クライアントIDとクライアント・シークレット"

#. type: Plain text
msgid ""
"This is the traditional method described in the OAuth2 specification. The "
"client has a secret, which needs to be known to both the adapter "
"(application) and the {project_name} server.  You can generate the secret "
"for a particular client in the {project_name} administration console, and "
"then paste this secret into the `keycloak.json` file on the application "
"side:"
msgstr ""
"これは、OAuth2の仕様で説明されている伝統的な方法です。クライアントにはシークレットがあり、アダプター（アプリケーション）と{project_name}サーバーの両方に知られている必要があります。{project_name}管理コンソールで特定のクライアントのシークレットを生成し、このシークレットをアプリケーション側の"
" `keycloak.json` ファイルに以下のように貼り付けます。"

#. type: delimited block -
#, no-wrap
msgid ""
"\"credentials\": {\n"
"    \"secret\": \"19666a4f-32dd-4049-b082-684c74115f28\"\n"
"}\n"
msgstr ""
"\"credentials\": {\n"
"    \"secret\": \"19666a4f-32dd-4049-b082-684c74115f28\"\n"
"}\n"

#. type: Title =====
#, no-wrap
msgid "Client Authentication with Signed JWT"
msgstr "署名付きJWTによるクライアント認証"

#. type: Plain text
msgid ""
"This is based on the https://tools.ietf.org/html/rfc7523[RFC7523] "
"specification. It works this way:"
msgstr ""
"これは https://tools.ietf.org/html/rfc7523[RFC7523] の仕様に基づいています。以下の方法で動作します。"

#. type: Plain text
msgid ""
"The client must have the private key and certificate. For {project_name} "
"this is available through the traditional `keystore` file, which is either "
"available on the client application's classpath or somewhere on the file "
"system."
msgstr ""
"クライアントには秘密鍵と証明書が必要です。{project_name}の場合、これは伝統的な  `keystore` "
"ファイルから利用できます。これはクライアント・アプリケーションのクラスパスかファイルシステムのどこかで利用できます。"

#. type: Plain text
msgid ""
"Once the client application is started, it allows to download its public key"
" in https://self-issued.info/docs/draft-ietf-jose-json-web-key.html[JWKS] "
"format using a URL such as \\http://myhost.com/myapp/k_jwks, assuming that "
"\\http://myhost.com/myapp is the base URL of your client application. This "
"URL can be used by {project_name} (see below)."
msgstr ""
"クライアント・アプリケーションが開始されると、 \\http://myhost.com/myapp/k_jwks のようなURLを使った https"
"://self-issued.info/docs/draft-ietf-jose-json-web-key.html[JWKS] "
"形式の公開鍵のダウンロードが許可されます。 \\http://myhost.com/myapp "
"はクライアント・アプリケーションのベースURLであることを前提としています。このURLは{project_name}により使用されます（下記参照）。"

#. type: Plain text
msgid ""
"During authentication, the client generates a JWT token and signs it with "
"its private key and sends it to {project_name} in the particular backchannel"
" request (for example, code-to-token request) in the `client_assertion` "
"parameter."
msgstr ""
"認証中に、クライアントはJWTトークンを生成し、その秘密鍵で署名し、 `client_assertion` "
"パラメーターとともに特定のバックチャネル・リクエスト（たとえば、コードからトークンへの交換リクエスト）を{project_name}に送信します。"

#. type: Plain text
msgid ""
"{project_name} must have the public key or certificate of the client so that"
" it can verify the signature on JWT. In {project_name} you need to configure"
" client credentials for your client. First you need to choose `Signed JWT` "
"as the method of authenticating your client in the tab `Credentials` in "
"administration console.  Then you can choose to either: ** Configure the "
"JWKS URL where {project_name} can download the client's public keys. This "
"can be a URL such as \\http://myhost.com/myapp/k_jwks (see details above). "
"This option is the most flexible, since the client can rotate its keys "
"anytime and {project_name} then always downloads new keys when needed "
"without needing to change the configuration. More accurately, {project_name}"
" downloads new keys when it sees the token signed by an unknown `kid` (Key "
"ID).  ** Upload the client's public key or certificate, either in PEM "
"format, in JWK format, or from the keystore. With this option, the public "
"key is hardcoded and must be changed when the client generates a new key "
"pair.  You can even generate your own keystore from the {project_name} "
"admininstration console if you don't have your own available.  For more "
"details on how to set up the {project_name} administration console see "
"{adminguide_link}[{adminguide_name}]."
msgstr ""
"{project_name}は、JWTの署名を検証できるように、クライアントの公開鍵または証明書を持っていなければなりません。{project_name}では、クライアントのクライアント・クレデンシャルを設定する必要があります。まず、管理コンソールの"
" `Credentials` タブでクライアントを認証する方法として、 `Signed JWT` "
"を選択する必要があります。そして、次のどちらかを選択することができます。 ** "
"{project_name}がクライアントの公開鍵をダウンロードできるJWKS URLを設定します。これは "
"\\http://myhost.com/myapp/k_jwks "
"のようなURLです（詳細は上記を参照）。クライアントはいつでもキーをローテーションさせることができるので、このオプションは最も柔軟です。{project_name}は、設定を変更することなく、必要なときに常に新しいキーをダウンロードします。より正確には、{project_name}は、未知の"
" `kid`  （Key ID）で署名されたトークンを見ると、新しい鍵をダウンロードします。  ** "
"クライアントの公開鍵または証明書を、PEM形式、JWK形式、またはキーストアからアップロードします。このオプションを使用すると、公開鍵はハードコードされるので、クライアントが新しい鍵ペアを生成するときに変更する必要があります。独自のキーストアがない場合は、{project_name}管理コンソールから独自のキーストアを生成することもできます。{project_name}管理コンソールの設定方法の詳細については、"
" {adminguide_link}[{adminguide_name}] を参照してください。"

#. type: Plain text
msgid ""
"For set up on the adapter side you need to have something like this in your "
"`keycloak.json` file:"
msgstr "アダプター側でセットアップするには、 `keycloak.json` ファイルに次のようなものが必要です。"

#. type: delimited block -
#, no-wrap
msgid ""
"\"credentials\": {\n"
"  \"jwt\": {\n"
"    \"client-keystore-file\": \"classpath:keystore-client.jks\",\n"
"    \"client-keystore-type\": \"JKS\",\n"
"    \"client-keystore-password\": \"storepass\",\n"
"    \"client-key-password\": \"keypass\",\n"
"    \"client-key-alias\": \"clientkey\",\n"
"    \"token-expiration\": 10\n"
"  }\n"
"}\n"
msgstr ""
"\"credentials\": {\n"
"  \"jwt\": {\n"
"    \"client-keystore-file\": \"classpath:keystore-client.jks\",\n"
"    \"client-keystore-type\": \"JKS\",\n"
"    \"client-keystore-password\": \"storepass\",\n"
"    \"client-key-password\": \"keypass\",\n"
"    \"client-key-alias\": \"clientkey\",\n"
"    \"token-expiration\": 10\n"
"  }\n"
"}\n"

#. type: Plain text
msgid ""
"With this configuration, the keystore file `keystore-client.jks` must be "
"available on classpath in your WAR. If you do not use the prefix "
"`classpath:` you can point to any file on the file system where the client "
"application is running."
msgstr ""
"この設定では、キーストア・ファイル `keystore-client.jks` がWARのクラスパス上で利用可能でなければなりません。 "
"`classpath:` "
"というプレフィックスを使用しない場合は、クライアント・アプリケーションが実行されているファイルシステム上のファイルを指すことができます。"

#. type: Plain text
msgid ""
"For inspiration, you can take a look at the examples distribution into the "
"main demo example into the `product-portal` application."
msgstr "インスピレーションのために、 `product-portal` アプリケーションのデモのサンプル配布物を見てみることができます。"

#. type: Title =====
#, no-wrap
msgid "Client Authentication with Signed JWT using Client Secret"
msgstr "クライアント・シークレットを使用した署名付きJWTによるクライアント認証"

#. type: Plain text
msgid ""
"This is the same as Client Authentication with Signed JWT except for using "
"the client secret instead of the private key and certificate."
msgstr "これは、署名付きJWTによるクライアント認証と同じですが、秘密鍵と証明書の代わりにクライアント・シークレットを使用する点が異なります。"

#. type: Plain text
msgid ""
"The client has a secret, which needs to be known to both the adapter "
"(application) and the {project_name} server. You need to choose `Signed JWT "
"with Client Secret` as the method of authenticating your client in the tab "
"`Credentials` in administration console, and then paste this secret into the"
" `keycloak.json` file on the application side:"
msgstr ""
"クライアントにはシークレットがあり、アダプター（アプリケーション）と{project_name}サーバーの両方に知られている必要があります。管理コンソールの"
" `Credentials` タブでクライアントを認証する方法として `Signed JWT with Client Secret` "
"を選択し、このシークレットをアプリケーション側の `keycloak.json` ファイルに以下のように貼り付けます。"

#. type: delimited block -
#, no-wrap
msgid ""
"\"credentials\": {\n"
"  \"secret-jwt\": {\n"
"    \"secret\": \"19666a4f-32dd-4049-b082-684c74115f28\",\n"
"    \"algorithm\": \"HS512\"\n"
"  }\n"
"}\n"
msgstr ""
"\"credentials\": {\n"
"  \"secret-jwt\": {\n"
"    \"secret\": \"19666a4f-32dd-4049-b082-684c74115f28\",\n"
"    \"algorithm\": \"HS512\"\n"
"  }\n"
"}\n"

#. type: Plain text
msgid ""
"The \"algorithm\" field specifies the algorithm for Signed JWT using Client "
"Secret. It needs to be one of the following values : HS256, HS384, and "
"HS512. For details, please refer to "
"https://tools.ietf.org/html/rfc7518#section-3.2[JSON Web Algorithms (JWA)]."
msgstr ""
"「algorithm」フィールドには、クライアント・シークレットを使用した署名付きJWTのアルゴリズムを指定します。HS256、HS384、HS512のいずれかの値である必要があります。詳細については、https://tools.ietf.org/html/rfc7518#section-3.2[JSON"
" Web Algorithms (JWA)]を参照してください。"

#. type: Plain text
msgid ""
"This \"algorithm\" field is optional so that HS256 is applied automatically "
"if the \"algorithm\" field does not exist on the `keycloak.json` file."
msgstr ""
"この「algorithm」フィールドはオプションであり、「algorithm」フィールドが `keycloak.json` "
"ファイルに存在しない場合はHS256が自動的に適用されます。"

#. type: Title =====
#, no-wrap
msgid "Add Your Own Client Authentication Method"
msgstr "独自のクライアント認証方式の追加"

#. type: Plain text
msgid ""
"You can add your own client authentication method as well. You will need to "
"implement both client-side and server-side providers. For more details see "
"the `Authentication SPI` section in "
"link:{developerguide_link}[{developerguide_name}]."
msgstr ""
"独自のクライアント認証方式を追加することもできます。クライアントサイドとサーバーサイドの両方のプロバイダーを実装する必要があります。詳細はlink:{developerguide_link}[{developerguide_name}]の"
" `Authentication SPI` のセクションを参照してください。"
