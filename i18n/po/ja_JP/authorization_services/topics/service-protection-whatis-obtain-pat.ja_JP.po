# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Nomura Research Institute, Ltd.
# This file is distributed under the same license as the keycloak-documentation-i18n package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n\n"
"Last-Translator: Kohei Tamura <ktamura.biz.80@gmail.com>, 2018\n"
"Language-Team: Japanese (Japan) (https://www.transifex.com/openstandia/teams/79437/ja_JP/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja_JP\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Title =
#, no-wrap
msgid "What is a PAT and How to Obtain It"
msgstr "PATとは何か、そしてそれをどのように取得するか"

#. type: Plain text
msgid ""
"A *protection API token* (PAT) is a special OAuth2 access token with a scope"
" defined as *uma_protection*. When you create a resource server, "
"{project_name} automatically creates a role, _uma_protection_, for the "
"corresponding client application and associates it with the client's service"
" account."
msgstr ""
"*保護APIトークン* （PAT）は、 *uma_protection* "
"として定義されたスコープを持つ特殊なOAuth2アクセストークンです。リソースサーバーを作成すると、{project_name}は対応するクライアント・アプリケーションのロール"
" _uma_protection_ を自動的に作成し、クライアントのサービス・アカウントに関連付けます。"

#. type: Block title
#, no-wrap
msgid "Service Account granted with *uma_protection* role"
msgstr "*uma_protection* ロールで付与されたサービス・アカウント"

#. type: Plain text
msgid ""
"image:{project_images}/service/rs-uma-protection-role.png[alt=\"Service "
"Account granted with uma_protection role\"]"
msgstr ""
"image:{project_images}/service/rs-uma-protection-"
"role.png[alt=\"uma_protectionロールで付与されたサービス・アカウント\"]"

#. type: Plain text
msgid ""
"Resource servers can obtain a PAT from {project_name} like any other OAuth2 "
"access token. For example, using curl:"
msgstr ""
"リソースサーバーは、{project_name}から他のOAuth2アクセストークンと同様にPATを取得できます。たとえば、次のようにcurlを使用します。"

#. type: Code block
#, no-wrap
msgid ""
"curl -X POST \\\n"
"    -H \"Content-Type: application/x-www-form-urlencoded\" \\\n"
"    -d 'grant_type=client_credentials&client_id=${client_id}&client_secret=${client_secret}' \\\n"
"    \"http://localhost:8080/auth/realms/${realm_name}/protocol/openid-connect/token\"\n"
msgstr ""
"curl -X POST \\\n"
" -H \"Content-Type: application/x-www-form-urlencoded\" \\\n"
" -d 'grant_type=client_credentials&client_id=${client_id}&client_secret=${client_secret}' \\\n"
" \"http://localhost:8080/auth/realms/${realm_name}/protocol/openid-connect/token\"\n"

#. type: Plain text
msgid ""
"The example above is using the *client_credentials* grant type to obtain a "
"PAT from the server. As a result, the server returns a response similar to "
"the following:"
msgstr ""
"上記の例では、 *client_credentials* "
"グラントタイプを使用してサーバーからPATを取得しています。その結果、サーバーは次のような応答を返します。"

#. type: Code block
#, no-wrap
msgid ""
"{\n"
"  \"access_token\": ${PAT},\n"
"  \"expires_in\": 300,\n"
"  \"refresh_expires_in\": 1800,\n"
"  \"refresh_token\": ${refresh_token},\n"
"  \"token_type\": \"bearer\",\n"
"  \"id_token\": ${id_token},\n"
"  \"not-before-policy\": 0,\n"
"  \"session_state\": \"ccea4a55-9aec-4024-b11c-44f6f168439e\"\n"
"}\n"
msgstr ""
"{\n"
" \"access_token\": ${PAT},\n"
" \"expires_in\": 300,\n"
" \"refresh_expires_in\": 1800,\n"
" \"refresh_token\": ${refresh_token},\n"
" \"token_type\": \"bearer\",\n"
" \"id_token\": ${id_token},\n"
" \"not-before-policy\": 0,\n"
" \"session_state\": \"ccea4a55-9aec-4024-b11c-44f6f168439e\"\n"
"}\n"

#. type: Plain text
msgid ""
"{project_name} can authenticate your client application in different ways. "
"For simplicity, the *client_credentials* grant type is used here, which "
"requires a _client_id_ and a _client_secret_. You can choose to use any "
"supported authentication method."
msgstr ""
"{project_name}は、さまざまな方法でクライアント・アプリケーションを認証できます。わかりやすくするため、ここでは "
"*client_credentials* グラント・タイプが使用されています。これには _client_id_ と _client_secret_ "
"が必要です。サポートされている認証方法の使用を選択することができます。"
