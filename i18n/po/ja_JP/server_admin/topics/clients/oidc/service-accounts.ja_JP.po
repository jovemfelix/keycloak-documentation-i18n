# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Nomura Research Institute, Ltd.
# This file is distributed under the same license as the keycloak-documentation-i18n package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Shinsuke UEDA, 2017
# Hiroyuki Wada <wadahiro@gmail.com>, 2021
# Kohei Tamura <ktamura.biz.80@gmail.com>, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n\n"
"Last-Translator: Kohei Tamura <ktamura.biz.80@gmail.com>, 2022\n"
"Language-Team: Japanese (Japan) (https://www.transifex.com/openstandia/teams/79437/ja_JP/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja_JP\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    POST /auth/realms/demo/protocol/openid-connect/token\n"
"    Authorization: Basic cHJvZHVjdC1zYS1jbGllbnQ6cGFzc3dvcmQ=\n"
"    Content-Type: application/x-www-form-urlencoded\n"
msgstr ""
"POST /auth/realms/demo/protocol/openid-connect/token\n"
" Authorization: Basic cHJvZHVjdC1zYS1jbGllbnQ6cGFzc3dvcmQ=\n"
" Content-Type: application/x-www-form-urlencoded\n"

#. type: delimited block -
#, no-wrap
msgid "    grant_type=client_credentials\n"
msgstr "grant_type=client_credentials\n"

#. type: delimited block -
#, no-wrap
msgid ""
"HTTP/1.1 200 OK\n"
"Content-Type: application/json;charset=UTF-8\n"
"Cache-Control: no-store\n"
"Pragma: no-cache\n"
msgstr ""
"HTTP/1.1 200 OK\n"
"Content-Type: application/json;charset=UTF-8\n"
"Cache-Control: no-store\n"
"Pragma: no-cache\n"

#. type: delimited block -
#, no-wrap
msgid ""
"{\n"
"    \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n"
"    \"token_type\":\"bearer\",\n"
"    \"expires_in\":60\n"
"}\n"
msgstr ""
"{\n"
"    \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n"
"    \"token_type\":\"bearer\",\n"
"    \"expires_in\":60\n"
"}\n"

#. type: Title ====
#, no-wrap
msgid "Service Accounts"
msgstr "サービス・アカウント"

#. type: Plain text
msgid ""
"Each OIDC client has a built-in _service account_ which allows it to obtain "
"an access token.  This is covered in the OAuth 2.0 specifiation under "
"<<_client_credentials_grant,Client Credentials Grant>>.  To use this feature"
" you must set the <<_access-type, Access Type>> of your client to "
"`confidential`.  When you do this, the `Service Accounts Enabled` switch is "
"displayed.  You need to toggle this switch to ON.  Also make sure that you "
"have configured your <<_client-credentials, client credentials>>."
msgstr ""
"各OIDCクライアントには、 _サービス・アカウント_ が組み込まれており、アクセストークンを取得できます。これは、OAuth "
"2.0仕様の<<_client_credentials_grant,クライアント・クレデンシャル・グラント>>で説明されています。この機能を使用するには、クライアントの<<_access-"
"type, アクセスタイプ>>を `confidential` に設定する必要があります。これを行うと、 `Service Accounts "
"Enabled` スイッチが表示されます。このスイッチをオンに切り替える必要があります。また、<<_client-credentials, "
"クライアント・クレデンシャル>>を設定していることを確認してください。"

#. type: Plain text
msgid ""
"To use it you must have registered a valid `confidential` Client and you "
"need to check the switch `Service Accounts Enabled` in {project_name} admin "
"console for this client.  In tab `Service Account Roles` you can configure "
"the roles available to the service account retrieved on behalf of this "
"client.  Remember that you must have the roles available in Role Scope "
"Mappings (tab `Scope`) of this client as well, unless you have `Full Scope "
"Allowed` on. As in a normal login, roles from access token are the "
"intersection of:"
msgstr ""
"サービス・アカウントを使用するには、有効な `confidential` "
"クライアントを登録していなければなりません。また、そのクライアントの{project_name}管理コンソールの `Service Accounts "
"Enabled` スイッチをオンにする必要があります。 `Service Account Roles` "
"タブでは、このクライアントに代わって取得されたサービス・アカウントで使用可能なロールを設定できます。 `Full Scope Allowed` "
"をオンにしない限り、このクライアントのロール・スコープ・マッピング（ `Scope` "
"タブ）でロールを利用可能にする必要があることに注意してください。通常のログインと同様に、アクセストークンのロールは以下の論理積となります。"

#. type: Plain text
msgid ""
"Role scope mappings of particular client combined with the role scope "
"mappings inherited from linked client scopes"
msgstr "リンクされたクライアント・スコープから継承されたロール・スコープ・マッピングと結合された特定のクライアントのロール・スコープ・マッピング"

#. type: Plain text
msgid "Service account roles"
msgstr "サービス・アカウント・ロール"

#. type: Plain text
msgid ""
"The REST URL to invoke on is `/auth/realms/{realm-name}/protocol/openid-"
"connect/token`.  Invoking on this URL is a POST request and requires you to "
"post the client credentials.  By default, client credentials are represented"
" by clientId and clientSecret of the client in `Authorization: Basic` "
"header, but you can also authenticate the client with a signed JWT assertion"
" or any other custom mechanism for client authentication.  You also need to "
"use the parameter `grant_type=client_credentials` as per the OAuth2 "
"specification."
msgstr ""
"呼び出すREST URLは `/auth/realms/{realm-name}/protocol/openid-connect/token` "
"です。このURLを呼び出すのはPOSTリクエストで、クライアントのクレデンシャルを送信する必要があります。デフォルトでは、クライアントのクレデンシャルはクライアントのclientIdとclientSecretによって"
" `Authorization: Basic` "
"ヘッダーで表されますが、署名されたJWTアサーションまたはクライアント認証のためのその他のカスタム・メカニズムでクライアントを認証することもできます。また、OAuth2仕様に従ってパラメーター"
" `grant_type=client_credentials` を使う必要があります。"

#. type: Plain text
msgid ""
"For example the POST invocation to retrieve a service account can look like "
"this:"
msgstr "たとえば、サービス・アカウントを取得するためのPOST呼び出しは次のようになります。"

#. type: Plain text
msgid ""
"The response would be this "
"https://datatracker.ietf.org/doc/html/rfc6749#section-4.4.3[standard JSON "
"document] from the OAuth 2.0 specification."
msgstr ""
"このレスポンスは、OAuth 2.0仕様の "
"https://datatracker.ietf.org/doc/html/rfc6749#section-4.4.3[standard JSON "
"document] になります。"

#. type: Plain text
msgid ""
"There is the only access token returned by default. There is no refresh "
"token returned and there is also no user session created on the "
"{project_name} side upon successful authentication by default. Due the lack "
"of refresh token, there is a need to re-authenticate when access token "
"expires, however this does not mean any additional overhead on "
"{project_name} server side due the fact that sessions are not created by "
"default."
msgstr ""
"デフォルトで返されるのはアクセストークンだけです。デフォルトではリフレッシュトークンは返されず、認証に成功した際に{project_name}側で作成されるユーザー・セッションもありません。リフレッシュトークンがないため、アクセストークンの有効期限が切れたときに再認証する必要がありますが、デフォルトではセッションが作成されないため、これは{project_name}サーバー側で追加のオーバーヘッドが発生することを意味しません。"

#. type: Plain text
msgid ""
"Due to this, there is no need for logout, however issued access tokens can "
"be revoked by sending request to the OAuth2 Revocation Endpoint described in"
" the <<_oidc-endpoints, OpenID Connect Endpoints>> section."
msgstr ""
"このため、ログアウトする必要はありませんが、発行されたアクセストークンは、<<_oidc-endpoints, OpenID Connect "
"Endpoints>>のセクションで説明されているOAuth2 Revocation "
"Endpointにリクエストを送信することで取り消すことができます。"
