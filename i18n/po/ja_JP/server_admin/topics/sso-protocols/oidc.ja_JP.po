# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Nomura Research Institute, Ltd.
# This file is distributed under the same license as the keycloak-documentation-i18n package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Shinsuke UEDA, 2021
# Tsukasa Amano <t.amano@pro-japan.co.jp>, 2021
# Hiroyuki Wada <wadahiro@gmail.com>, 2021
# Kohei Tamura <ktamura.biz.80@gmail.com>, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n\n"
"Last-Translator: Kohei Tamura <ktamura.biz.80@gmail.com>, 2022\n"
"Language-Team: Japanese (Japan) (https://www.transifex.com/openstandia/teams/79437/ja_JP/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja_JP\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Title =====
#, no-wrap
msgid "Device Authorization Grant"
msgstr "デバイス認可グラント"

#. type: Title =====
#, no-wrap
msgid "Client Initiated Backchannel Authentication Grant"
msgstr "Client Initiated Backchannel Authentication Grant"

#. type: Plain text
msgid ""
"The client requests {project_name} an auth_req_id that identifies the "
"authentication request made by the client. {project_name} creates the "
"auth_req_id."
msgstr ""
"クライアントは、クライアントによって行われた認証リクエストを識別するauth_req_idを{project_name}に要求します。{project_name}はauth_req_idを作成します。"

#. type: Plain text
msgid ""
"After receiving this auth_req_id, this client repeatedly needs to poll "
"{project_name} to obtain an Access Token, Refresh Token and ID Token from "
"{project_name} in return for the auth_req_id until the user is "
"authenticated."
msgstr ""
"このauth_req_idを受信した後、このクライアントは{project_name}を繰り返しポーリングして、ユーザーが認証されるまでauth_req_idと引き換えに{project_name}からアクセストークン、リフレッシュトークン、IDトークンを取得する必要があります。"

#. type: Title ===
#, no-wrap
msgid "OpenID Connect"
msgstr "OpenID Connect"

#. type: Plain text
msgid ""
"link:https://openid.net/connect/[OpenID Connect] (OIDC) is an authentication"
" protocol that is an extension of "
"link:https://datatracker.ietf.org/doc/html/rfc6749[OAuth 2.0].  While OAuth "
"2.0 is only a framework for building authorization protocols and is mainly "
"incomplete, OIDC is a full-fledged authentication and authorization "
"protocol.  OIDC also makes heavy use of the link:https://jwt.io[Json Web "
"Token] (JWT) set of standards.  These standards define an identity token "
"JSON format and ways to digitally sign and encrypt that data in a compact "
"and web-friendly way."
msgstr ""
"link:https://openid.net/connect/[OpenID Connect] （OIDC）は "
"link:https://datatracker.ietf.org/doc/html/rfc6749[OAuth 2.0] "
"を拡張した認証プロトコルです。OAuth "
"2.0が認可プロトコルのみを構築するためのフレームワークで、不完全であるのに対し、OIDCは完成された認証および認可のプロトコルです。OIDCはまた、 "
"link:https://jwt.io[Json Web Token] "
"（JWT）の標準セットを多用します。これらの標準は、コンパクトでWebフレンドリーな方法で、アイデンティティー・トークンのJSON形式とデジタル署名、データ暗号化の方法を定義します。"

#. type: Plain text
msgid ""
"There are really two types of use cases when using OIDC.  The first is an "
"application that asks the {project_name} server to authenticate a user for "
"them.  After a successful login, the application will receive an _identity "
"token_ and an _access token_.  The _identity token_ contains information "
"about the user such as username, email, and other profile information.  The "
"_access token_ is digitally signed by the realm and contains access "
"information (like user role mappings) that the application can use to "
"determine what resources the user is allowed to access on the application."
msgstr ""
"OIDCを使用するユースケースは、実際には2つの種類があります。1つ目は、{project_name}サーバーにユーザーの認証を要求するアプリケーションのユースケースです。ログインが成功すると、アプリケーションは"
" _IDトークン_ と _アクセストークン_ を受け取ります。 _IDトークン_ "
"には、ユーザーに関する情報（ユーザー名、電子メール、その他のプロファイル情報など）が含まれています。 _アクセストークン_ "
"はレルムによってデジタル署名されており、アプリケーションがユーザーのアクセス可能なリソースを決定するために使用できるアクセス情報（ユーザー・ロール・マッピングのような）が含まれています。"

#. type: Plain text
msgid ""
"The second type of use cases is that of a client that wants to gain access "
"to remote services.  In this case, the client asks {project_name} to obtain "
"an _access token_ it can use to invoke on other remote services on behalf of"
" the user.  {project_name} authenticates the user then asks the user for "
"consent to grant access to the client requesting it.  The client then "
"receives the _access token_.  This _access token_ is digitally signed by the"
" realm.  The client can make REST invocations on remote services using this "
"_access token_.  The REST service extracts the _access token_, verifies the "
"signature of the token, then decides based on access information within the "
"token whether or not to process the request."
msgstr ""
"2つ目のタイプは、リモートサービスへのアクセス権を取得したいクライアントのユースケースです。この場合、クライアントは、ユーザーの代理として他のリモートサービスの呼び出しに使用できる"
" _アクセストークン_ "
"の取得を{project_name}に要求します。{project_name}は、ユーザーを認証し、クライアントのアクセスを許可する同意を要求します。そして、クライアントは"
" _アクセストークン_ を受け取ります。この _アクセストークン_ はレルムによってデジタル署名されます。クライアントはこの _アクセストークン_ "
"を使用して、リモートサービスのREST呼び出しを行うことができます。REST サービスは _アクセストークン_ "
"を抽出し、トークンの署名を検証し、トークン内のアクセス情報に基づいて、リクエストを処理するかどうかを決定します。"

#. type: Plain text
msgid "Configuration|Description"
msgstr "設定|説明"

#. type: Title =====
#, no-wrap
msgid "Backchannel Logout"
msgstr "Backchannel Logout"

#. type: Title =====
#, no-wrap
msgid "Authorization Code Flow"
msgstr "認可コード・フロー"

#. type: Title =====
#, no-wrap
msgid "Implicit Flow"
msgstr "インプリシット・フロー"

#. type: Plain text
msgid ""
"The application extracts the _identity_ and _access_ tokens from the "
"callback URL."
msgstr "アプリケーションは、コールバックURLから _ID_ トークンと _アクセス_ トークンを抽出します。"

#. type: Plain text
msgid ""
"This is used by clients running on internet-connected devices that have "
"limited input capabilities or lack a suitable browser. Here's a brief "
"summary of the protocol:"
msgstr ""
"これは、入力機能が制限されているか、適切なブラウザーがない、インターネットに接続されたデバイスで実行されているクライアントによって使用されます。プロトコルの簡単な概要は次のとおりです。"

#. type: Plain text
msgid ""
"The application requests {project_name} a device code and a user code. "
"{project_name} creates a device code and a user code. {project_name} returns"
" a response including the device code and the user code to the application."
msgstr ""
"アプリケーションは{project_name}にデバイスコードとユーザーコードを要求します。{project_name}は、デバイスコードとユーザーコードを作成します。{project_name}は、デバイス"
" コードとユーザーコードを含むレスポンスをアプリケーションに返します。"

#. type: Plain text
msgid ""
"The application provides the user with the user code and the verification "
"URI. The user accesses a verification URI to be authenticated by using "
"another browser."
msgstr ""
"アプリケーションは、ユーザーコードと検証URIをユーザーに提供します。ユーザーは、別のブラウザーを使用して、認証を受けるための検証URIにアクセスします。"

#. type: Plain text
msgid ""
"The application repeatedly polls {project_name} to find out if the user "
"completed the user authorization. If user authentication is complete, the "
"application exchanges the device code for an _identity_, _access_ and "
"_refresh_ token."
msgstr ""
"アプリケーションは{project_name}を繰り返しポーリングして、ユーザーがユーザー認証を完了したかどうかを調べます。ユーザー認証が完了すると、アプリケーションはデバイス"
" コードを _ID_ トークン、 _access_ トークン、 および _refresh_ トークンと交換します。"

#. type: Plain text
msgid ""
"An administrator can configure Client Initiated Backchannel Authentication "
"(CIBA) related operations as `CIBA Policy` per realm."
msgstr ""
"管理者は、Client Initiated Backchannel Authentication (CIBA) 関連の操作をレルムごとの `CIBA "
"Policy` として設定できます。"

#. type: Plain text
msgid ""
"Also please refer to other places of {project_name} documentation like "
"link:{adapterguide_link}#_backchannel_authentication_endpoint[Backchannel "
"Authentication Endpoint section] of {adapterguide_name} and "
"link:{adapterguide_link}#_client_initiated_backchannel_authentication_grant[Client"
" Initiated Backchannel Authentication Grant section] of {adapterguide_name}."
msgstr ""
"また、{adapterguide_name}の "
"link:{adapterguide_link}#_backchannel_authentication_endpoint[Backchannel "
"Authentication Endpointのセクション] や{adapterguide_name}の "
"link:{adapterguide_link}#_client_initiated_backchannel_authentication_grant[ClientInitiated"
" Backchannel Authentication Grant] "
"のセクションなど、{project_name}ドキュメントの他の場所も参照してください。"

#. type: Title ======
#, no-wrap
msgid "CIBA Policy"
msgstr "CIBAポリシー"

#. type: Plain text
msgid ""
"An administrator carries out the following operations on the `Admin Console`"
" :"
msgstr "管理者は、 `管理コンソール` で次の操作を行います。"

#. type: Plain text
msgid "Open the `Authentication -> CIBA Policy` tab."
msgstr "`Authentication -> CIBA Policy` タブを開きます."

#. type: Plain text
msgid "Configure items and click `Save`."
msgstr "アイテムを設定し、 `Save` をクリックします。"

#. type: Plain text
msgid "The configurable items and their description follow."
msgstr "設定可能な項目とその説明は次のとおりです。"

#. type: Plain text
msgid "Backchannel Token Delivery Mode"
msgstr "Backchannel Token Delivery Mode"

#. type: Plain text
msgid "Expires In"
msgstr "Expires In"

#. type: Plain text
#, no-wrap
msgid ""
"The expiration time of the \"auth_req_id\" in seconds since the authentication request was received. The default setting is 120. This configuration is required.\n"
" For more details, see https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#successful_authentication_request_acknowdlegment[CIBA Specification].\n"
msgstr ""
"認証リクエストを受信してからの\"auth_req_id\"の有効期限（秒単位）。デフォルトの設定は120です。この設定は必須です。詳細については、 "
"https://openid.net/specs/openid-client-initiated-backchannel-authentication-"
"core-1_0.html#successful_authentication_request_acknowdlegment[CIBA "
"Specification] を参照してください。\n"

#. type: Plain text
msgid "Interval"
msgstr "Interval"

#. type: Plain text
#, no-wrap
msgid ""
"The interval in seconds the CD (Consumption Device) needs to wait for between polling requests to the token endpoint. The default setting is 5. This configuration is optional.\n"
" For more details, see https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#successful_authentication_request_acknowdlegment[CIBA Specification].\n"
msgstr ""
"CD（Consumption "
"Device）がトークン・エンドポイントへのポーリング・リクエスト間で待機する必要がある秒単位の間隔。デフォルト設定は5です。この設定はオプションです。詳細については、"
" https://openid.net/specs/openid-client-initiated-backchannel-"
"authentication-"
"core-1_0.html#successful_authentication_request_acknowdlegment[CIBA "
"Specification] を参照してください。\n"

#. type: Plain text
msgid "Authentication Requested User Hint"
msgstr "Authentication Requested User Hint"

#. type: Plain text
#, no-wrap
msgid ""
"The way of identifying the end-user for whom authentication is being requested. The default setting is \"login_hint\".  There are three modes, \"login_hint\", \"login_hint_token\" and \"id_token_hint\". {project_name} only supports \"login_hint\". This configuration is required.\n"
" For more details, see https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#rfc.section.7.1[CIBA Specification].\n"
msgstr ""
"認証が要求されているエンドユーザーを識別する方法。デフォルト設定は\"login_hint\"です。\"login_hint\"、\"login_hint_token\"、\"id_token_hint\"の3つのモードがあります。{project_name}は\"login_hint\"のみをサポートします。この設定は必須です。詳細については、"
" https://openid.net/specs/openid-client-initiated-backchannel-"
"authentication-core-1_0.html#rfc.section.5[CIBA Specification] を参照してください。\n"

#. type: Title ======
#, no-wrap
msgid "Provider Setting"
msgstr "プロバイダー設定"

#. type: Plain text
msgid "The CIBA grant uses the following two providers."
msgstr "CIBAグラントは、次の2つのプロバイダーを使用します。"

#. type: Plain text
msgid ""
"Authentication Channel Provider : provides the communication between "
"{project_name} and the entity that actually authenticates the user via AD "
"(Authentication Device)."
msgstr ""
"認証チャネル・プロバイダー：{project_name}と、AD（Authentication "
"Device）を介してユーザーを実際に認証するエンティティーとの間の通信を提供します。"

#. type: Plain text
msgid ""
"User Resolver Provider : get `UserModel` of {project_name} from the "
"information provided by the client to identify the user."
msgstr ""
"User Resolver Provider：クライアントから提供された情報から{project_name}の `UserModel` "
"を取得して、ユーザーを識別します。"

#. type: Plain text
msgid ""
"{project_name} has both default providers. However, the administrator needs "
"to set up Authentication Channel Provider like this:"
msgstr ""
"{project_name}には両方のデフォルト・プロバイダーがあります。ただし、管理者は次のように認証チャネル・プロバイダーを設定する必要があります。"

#. type: delimited block -
#, no-wrap
msgid ""
"<spi name=\"ciba-auth-channel\">\n"
"    <default-provider>ciba-http-auth-channel</default-provider>\n"
"    <provider name=\"ciba-http-auth-channel\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"httpAuthenticationChannelUri\" value=\"https://backend.internal.example.com/auth\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>\n"
msgstr ""
"<spi name=\"ciba-auth-channel\">\n"
"    <default-provider>ciba-http-auth-channel</default-provider>\n"
"    <provider name=\"ciba-http-auth-channel\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"httpAuthenticationChannelUri\" value=\"https://backend.internal.example.com/auth\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>\n"

#. type: Plain text
msgid "httpAuthenticationChannelUri"
msgstr "httpAuthenticationChannelUri"

#. type: Plain text
msgid ""
"Specifying URI of the entity that actually authenticates the user via AD "
"(Authentication Device)."
msgstr "AD（Authentication Device）を介して実際にユーザーを認証するエンティティーのURIを指定します。"

#. type: Title ======
#, no-wrap
msgid "Authentication Channel Provider"
msgstr "Authentication Channel Provider"

#. type: Plain text
msgid ""
"CIBA standard document does not specify how to authenticate the user by AD. "
"Therefore, it might be implemented at the discretion of products. "
"{project_name} delegates this authentication to an external authentication "
"entity. To communicate with the authentication entity, {project_name} "
"provides Authentication Channel Provider."
msgstr ""
"CIBA標準ドキュメントでは、ADによるユーザーの認証方法は指定されていません。したがって、製品の判断で実装される可能性があります。{project_name}は、この認証を外部認証エンティティーに委任します。認証エンティティーと通信するために、{project_name}は認証チャネル・プロバイダーを提供します。"

#. type: Plain text
msgid ""
"Its implementation of {project_name} assumes that the authentication entity "
"is under the control of the administrator of {project_name} so that "
"{project_name} trusts the authentication entity. It is not recommended to "
"use the authentication entity that the administrator of {project_name} "
"cannot control."
msgstr ""
"{project_name}の実装は、認証エンティティーが{project_name}の管理者の制御下にあることを前提としているため、{project_name}は認証エンティティーを信頼します。{project_name}の管理者が制御できない認証エンティティーを使用することはお勧めしません。"

#. type: Plain text
msgid ""
"Authentication Channel Provider is provided as SPI provider so that users of"
" {project_name} can implement their own provider in order to meet their "
"environment. {project_name} provides its default provider called HTTP "
"Authentication Channel Provider that uses HTTP to communicate with the "
"authentication entity."
msgstr ""
"認証チャネル・プロバイダーはSPIプロバイダーとして提供されるため、{project_name}のユーザーは、環境に合わせて独自のプロバイダーを実装できます。{project_name}は、HTTPを使用して認証エンティティーと通信するHTTP認証チャネル・プロバイダーと呼ばれるデフォルトのプロバイダーを提供します。"

#. type: Plain text
msgid ""
"If a user of {project_name} user want to use the HTTP Authentication Channel"
" Provider, they need to know its contract between {project_name} and the "
"authentication entity consisting of the following two parts."
msgstr ""
"{project_name}のユーザーがHTTP認証チャネル・プロバイダーを使用する場合、{project_name}と次の2つの部分で構成される認証エンティティーとの間のコントラクトを知る必要があります。"

#. type: Labeled list
#, no-wrap
msgid "Authentication Delegation Request/Response"
msgstr "Authentication Delegation Request/Response"

#. type: Plain text
msgid ""
"  {project_name} sends an authentication request to the authentication "
"entity."
msgstr "{project_name}は、認証リクエストを認証エンティティーに送信します。"

#. type: Labeled list
#, no-wrap
msgid "Authentication Result Notification/ACK"
msgstr "Authentication Result Notification/ACK"

#. type: Plain text
msgid ""
"  The authentication entity notifies the result of the authentication to "
"{project_name}."
msgstr "認証エンティティーは、認証の結果を{project_name}に通知します。"

#. type: Plain text
msgid ""
"Authentication Delegation Request/Response consists of the following "
"messaging."
msgstr "認証委任リクエスト/レスポンスは、次のメッセージで構成されます。"

#. type: Labeled list
#, no-wrap
msgid "Authentication Delegation Request"
msgstr "Authentication Delegation Request"

#. type: Plain text
msgid ""
"The request is sent from {project_name} to the authentication entity to ask "
"it for user authentication by AD."
msgstr "リクエストは{project_name}から認証エンティティーに送信され、ADによるユーザー認証を要求します。"

#. type: delimited block -
#, no-wrap
msgid "POST [delegation_reception]\n"
msgstr "POST [delegation_reception]\n"

#. type: Plain text
msgid "Headers"
msgstr "Headers"

#. type: Plain text
msgid "Name|Value|Description"
msgstr "名前|値|説明"

#. type: Plain text
msgid "Content-Type|application/json|The message body is json formatted."
msgstr "Content-Type|application/json|メッセージ本文はJSON形式です。"

#. type: Plain text
msgid ""
"Authorization|Bearer [token]|The [token] is used when the authentication "
"entity notifies the result of the authentication to {project_name}."
msgstr ""
"Authorization|Bearer "
"[token]|[トークン]は、認証エンティティーが認証の結果を{project_name}に通知するときに使用されます。"

#. type: Plain text
msgid "Parameters"
msgstr "Parameters"

#. type: Plain text
msgid "Type|Name|Description"
msgstr "タイプ|名前|説明"

#. type: Plain text
msgid "Path"
msgstr "Path"

#. type: Plain text
msgid ""
"delegation_reception|The endpoint provided by the authentication entity to "
"receive the delegation request"
msgstr "delegation_reception|委任リクストを受信するために認証エンティティーによって提供されるエンドポイント"

#. type: Plain text
msgid "Body"
msgstr "Body"

#. type: Plain text
msgid "Name|Description"
msgstr "名前|説明"

#. type: Plain text
#, no-wrap
msgid ""
"login_hint|It tells the authentication entity who is authenticated by AD. +\n"
"By default, it is the user's \"username\". +\n"
"This field is required and was defined by CIBA standard document.\n"
msgstr ""
"login_hint|ADによって認証された認証エンティティーに通知します。 +\n"
"デフォルトでは、これはユーザーの\"username\"です。 +\n"
"このフィールドは必須であり、CIBA標準ドキュメントによって定義されています。\n"

#. type: Plain text
#, no-wrap
msgid ""
"scope|It tells which scopes the authentication entity gets consent from the authenticated user. +\n"
"This field is required and was defined by CIBA standard document.\n"
msgstr ""
"scope|認証エンティティーが認証されたユーザーから同意を得るスコープを示します。 +\n"
"このフィールドは必須であり、CIBA標準ドキュメントによって定義されています。\n"

#. type: Plain text
#, no-wrap
msgid ""
"is_consent_required|It shows whether the authentication entity needs to get consent from the authenticated user about the scope. +\n"
" This field is required.\n"
msgstr ""
"is_consent_required|認証エンティティーがスコープについて認証されたユーザーから同意を得る必要があるかどうかを示します。 +\n"
"この項目は必須です。\n"

#. type: Plain text
#, no-wrap
msgid ""
"binding_message|Its value is intended to be shown in both CD and AD's UI to make the user recognize that the authentication by AD is triggered by CD. +\n"
"This field is optional and was defined by CIBA standard document.\n"
msgstr ""
"binding_message|その値は、CDとADのUIの両方に表示され、ADによる認証がCDによってトリガーされたことをユーザーに認識させることを目的としています。 +\n"
"このフィールドはオプションであり、CIBA標準ドキュメントによって定義されています。\n"

#. type: Plain text
#, no-wrap
msgid ""
"acr_values|It tells the requesting Authentication Context Class Reference from CD. +\n"
"This field is optional and was defined by CIBA standard document.\n"
msgstr ""
"acr_values|CDから要求している認証コンテキストクラス参照を通知します。 +\n"
"このフィールドはオプションであり、CIBA標準ドキュメントによって定義されています。\n"

#. type: Labeled list
#, no-wrap
msgid "Authentication Delegation Response"
msgstr "Authentication Delegation Response"

#. type: Plain text
msgid ""
"The response is returned from the authentication entity to {project_name} to"
" notify that the authentication entity received the authentication request "
"from {project_name}."
msgstr ""
"認証エンティティーから{project_name}にレスポンスが返され、認証エンティティーが{project_name}から認証リクエストを受信したことが通知されます。"

#. type: Plain text
msgid "Responses"
msgstr "Responses"

#. type: Plain text
msgid "HTTP Status Code|Description"
msgstr "HTTPステータスコード|説明"

#. type: Plain text
msgid ""
"201|It notifies {project_name} of receiving the authentication delegation "
"request."
msgstr "201|認証委任リクエストを受信したことを{project_name}に通知します。"

#. type: Plain text
msgid ""
"Authentication Result Notification/ACK consists of the following messaging."
msgstr "認証結果通知/ACKは以下のメッセージで構成されています。"

#. type: Labeled list
#, no-wrap
msgid "Authentication Result Notification"
msgstr "認証結果通知"

#. type: Plain text
msgid ""
"The authentication entity sends the result of the authentication request to "
"{project_name}."
msgstr "認証エンティティーは、認証リクエストの結果を{project_name}に送信します。"

#. type: delimited block -
#, no-wrap
msgid ""
"POST /auth/realms/[realm]/protocol/openid-connect/ext/ciba/auth/callback\n"
msgstr ""
"POST /auth/realms/[realm]/protocol/openid-connect/ext/ciba/auth/callback\n"

#. type: Plain text
msgid ""
"Authorization|Bearer [token]|The [token] must be the one the authentication "
"entity has received from {project_name} in Authentication Delegation "
"Request."
msgstr ""
"認可|ベアラー[トークン]|[トークン]は、認証エンティティーが認証委任リクエストで{project_name}から受信したものである必要があります。"

#. type: Plain text
msgid "realm|The realm name"
msgstr "レルム|レルム名"

#. type: Plain text
#, no-wrap
msgid ""
"status|It tells the result of user authentication by AD. +\n"
"It must be one of the following status. +\n"
"  SUCCEED : The authentication by AD has been successfully completed. +\n"
"  UNAUTHORIZED : The authentication by AD has not been completed. +\n"
"  CANCELLED : The authentication by AD has been cancelled by the user.\n"
msgstr ""
"status|ADによるユーザー認証の結果を示します。 +\n"
"以下のステータスのいずれかでなければなりません。 +\n"
"  SUCCEED：ADによる認証が正常に完了しました。 +\n"
"UNAUTHORIZED：ADによる認証が完了していません。 +\n"
"CANCELLED：ADによる認証がユーザーによってキャンセルされました。\n"

#. type: Labeled list
#, no-wrap
msgid "Authentication Result ACK"
msgstr "Authentication Result ACK"

#. type: Plain text
msgid ""
"The response is returned from {project_name} to the authentication entity to"
" notify {project_name} received the result of user authentication by AD from"
" the authentication entity."
msgstr ""
"レスポンスは{project_name}から認証エンティティーに返され、認証エンティティーからADによるユーザー認証の結果を{project_name}が受信したことを通知します。"

#. type: Plain text
msgid ""
"200|It notifies the authentication entity of receiving the notification of "
"the authentication result."
msgstr "200|認証結果の通知を受信したことを認証エンティティーに通知します。"

#. type: Title ======
#, no-wrap
msgid "User Resolver Provider"
msgstr "User Resolver Provider"

#. type: Plain text
msgid ""
"Even if the same user, its representation may differ in each CD, "
"{project_name} and the authentication entity."
msgstr "同じユーザーであっても、その表現はCD、{project_name}、および認証エンティティーごとに異なる場合があります。"

#. type: Plain text
msgid ""
"For CD, {project_name} and the authentication entity to recognize the same "
"user, this User Resolver Provider converts their own user representations "
"among them."
msgstr ""
"CD、{project_name}、および認証エンティティーが同じユーザーを認識するために、このユーザー・リゾルバー・プロバイダーは、それらの間で独自のユーザー表現を変換します。"

#. type: Plain text
msgid ""
"User Resolver Provider is provided as SPI provider so that users of "
"{project_name} can implement their own provider in order to meet their "
"environment. {project_name} provides its default provider called Default "
"User Resolver Provider that has the following characteristics."
msgstr ""
"ユーザー・リゾルバー・プロバイダーはSPIプロバイダーとして提供されるため、{project_name}のユーザーは、環境に合わせて独自のプロバイダーを実装できます。{project_name}は、次の特性を持つDefault"
" User ResolverProviderと呼ばれるデフォルト・プロバイダーを提供します。"

#. type: Plain text
msgid "Only support `login_hint` parameter and is used as default."
msgstr "`login_hint` パラメーターのみをサポートし、デフォルトとして使用されます。"

#. type: Plain text
msgid ""
"`username` of UserModel in {project_name} is used to represent the user on "
"CD, {project_name} and the authentication entity."
msgstr ""
"{project_name}のUserModelの `username` "
"は、CD、{project_name}、および認証エンティティーのユーザーを表すために使用されます。"

#. type: Title ====
#, no-wrap
msgid "OIDC Logout"
msgstr "OIDCログアウト"

#. type: Plain text
msgid ""
"OIDC has three different specifications relevant to logout mechanisms, all "
"of these are currently in draft status:"
msgstr "OIDCには、ログアウト機構に関連する3つの異なる仕様があり、これらはすべて現在ドラフトの状態です。"

#. type: Plain text
msgid ""
"https://openid.net/specs/openid-connect-session-1_0.html[Session Management]"
msgstr ""
"https://openid.net/specs/openid-connect-session-1_0.html[Session Management]"

#. type: Plain text
msgid ""
"https://openid.net/specs/openid-connect-frontchannel-1_0.html[Front-Channel "
"Logout]"
msgstr ""
"https://openid.net/specs/openid-connect-frontchannel-1_0.html[Front-Channel "
"Logout]"

#. type: Plain text
msgid ""
"https://openid.net/specs/openid-connect-backchannel-1_0.html[Back-Channel "
"Logout]"
msgstr ""
"https://openid.net/specs/openid-connect-backchannel-1_0.html[Back-Channel "
"Logout]"

#. type: Plain text
msgid ""
"Again since all of this is described in the OIDC specification we will only "
"give a brief overview here."
msgstr "繰り返しになりますが、これはすべてOIDCの仕様で説明されているため、ここでは簡単な概要のみを示します。"

#. type: Title =====
#, no-wrap
msgid "Session Management"
msgstr "Session Management"

#. type: Plain text
msgid ""
"This is a browser-based logout. The application obtains session status "
"information from {project_name} at a regular basis.  When the session is "
"terminated at {project_name} the application will notice and trigger it's "
"own logout."
msgstr ""
"これはブラウザーベースのログアウトです。アプリケーションは、定期的に{project_name}からセッション・ステータス情報を取得します。セッションが{project_name}で終了すると、アプリケーションはそれに気づき、自身のログアウトをトリガーします。"

#. type: Plain text
msgid ""
"This is also a browser-based logout where the logout starts by redirecting "
"the user to a specific endpoint at {project_name}."
msgstr ""
"これもブラウザベースのログアウトで、ログアウトが始まると、ユーザーは{project_name}の特定のエンドポイントにリダイレクトされます。"

#. type: Plain text
msgid ""
"Once the user is redirected to the logout endpoint, {project_name} is going "
"to send logout requests to clients to let them to invalidate their local "
"user sessions, and potentially redirect the user to some URL once the logout"
" process is finished."
msgstr ""
"ユーザーがログアウト エンドポイントにリダイレクトされると、 {project_name} はクライアントにログアウト リクエストを送信して、ローカル "
"ユーザー セッションを無効にし、ログアウト プロセスが終了したらユーザーを何らかの URL にリダイレクトするようにします。"

#. type: Plain text
msgid ""
"Depending on the client configuration, logout requests can be sent to "
"clients through the front-channel or through the back-channel."
msgstr ""
"クライアントの設定により、ログアウト要求は、フロントチャネルを介してクライアントに送信される場合と、バックチャネルを介して送信される場合があります。"

#. type: Plain text
msgid ""
"To configure clients to receive logout requests through the front-channel, "
"look at the <<_front-channel-logout, Front-Channel Logout>> client setting. "
"When using this method, consider the following:"
msgstr ""
"フロントチャネルでログアウト要求を受信するようにクライアントを設定するには、<_front-channel-logout, Front-Channel "
"Logout>&lt;&gt;クライアントの設定</_front-channel-logout,>を見てください。<_front-channel-"
"logout, Front-Channel Logout>この方法を使用する場合、以下の点を考慮してください。</_front-channel-"
"logout,>"

#. type: Plain text
msgid ""
"Logout requests sent by {project_name} to clients rely on the browser and on"
" embedded `iframes` that are rendered for the logout page."
msgstr ""
"{project_name} がクライアントに送信するログアウト要求は、ブラウザと、ログアウトページでレンダリングされる埋め込み `iframe` "
"に依存しています。"

#. type: Plain text
msgid ""
"By being based on `iframes`, front-channel logout might be impacted by "
"Content Security Policies (CSP) and logout requests might be blocked."
msgstr ""
"フロントチャネルのログアウトは、「iframe」に基づいているため、コンテンツセキュリティポリシー（CSP）の影響を受け、ログアウト要求がブロックされる可能性があります。"

#. type: Plain text
msgid ""
"If the user closes the browser prior to rendering the logout page or before "
"logout requests are actually sent to clients, their sessions at the client "
"might not be invalidated."
msgstr ""
"ログアウトページを表示する前、またはログアウト要求が実際にクライアントに送信される前にユーザーがブラウザを閉じた場合、クライアントでのセッションが無効にならない可能性があります。"

#. type: delimited block =
msgid ""
"Consider using Back-Channel Logout as it provides a more reliable and secure"
" approach to log out users and terminate their sessions on the clients."
msgstr ""
"ユーザーをログアウトさせ、クライアント上のセッションを終了させるには、より信頼性が高く安全な方法であるバックチャネルログアウトの使用を検討してください。"

#. type: Plain text
msgid ""
"If the client is not enabled with front-channel logout, then {project_name} "
"is going to try first to send logout requests through the back-channel using"
" the <<_back-channel-logout-url, Back-Channel Logout URL>>. If not defined, "
"the server is going to fall back to using the <<_admin-url, Admin URL>>."
msgstr ""
"クライアントがフロントチャネルのログアウトを有効にしていない場合、 {project_name} はまず<_back-channel-logout-"
"url, Back-Channel Logout URL>&lt;&gt;</_back-channel-logout-"
"url,>を使ってバックチャネルでログアウト要求を送ろうとします。<_back-channel-logout-url, Back-Channel "
"Logout URL>定義されていない場合、サーバは<_admin-url, Admin URL>&lt;&gt;</_admin-"
"url,></_back-channel-logout-url,>の使用に戻ります。"

#. type: Plain text
msgid ""
"This is a non browser-based logout that uses direct backchannel "
"communication between {project_name} and clients.  {project_name} sends a "
"HTTP POST request containing a logout token to all clients logged into "
"{project_name}. These requests are sent to a registered backchannel logout "
"URLs at {project_name} and are supposed to trigger a logout at client side."
msgstr ""
"これは、{project_name}とクライアント間の直接バックチャネル通信を使用する非ブラウザーベースのログアウトです。{project_name}は、ログアウト・トークンを含むHTTP"
" "
"POSTリクエストを{project_name}にログインしているすべてのクライアントに送信します。これらのリクエストは、{project_name}の登録済みバックチャネル・ログアウトURLに送信され、クライアント側でログアウトをトリガーすることになっています。"

#. type: Title ====
#, no-wrap
msgid "OIDC Auth Flows"
msgstr "OIDC認証フロー"

#. type: Plain text
msgid ""
"OIDC has different ways for a client or application to authenticate a user "
"and receive an _identity_ and _access_ token.  Which path you use depends "
"greatly on the type of application or client requesting access.  All of "
"these flows are described in the OIDC and OAuth 2.0 specifications so only a"
" brief overview will be provided here."
msgstr ""
"OIDCには、クライアントまたはアプリケーションがユーザーを認証し、 _ID_ トークンおよび _アクセス_ "
"トークンを受け取るさまざまな方法があります。どの方法を使用するかは、アクセスを要求するアプリケーションまたはクライアントのタイプによって大きく異なります。これらのフローはすべてOIDCおよびOAuth"
" 2.0の仕様で説明されていますので、ここでは簡単な概要のみを説明します。"

#. type: Plain text
msgid ""
"This is a browser-based protocol and it is what we recommend you use to "
"authenticate and authorize browser-based applications.  It makes heavy use "
"of browser redirects to obtain an _identity_ and _access_ token.  Here's a "
"brief summary:"
msgstr ""
"これはブラウザーベースのプロトコルであり、ブラウザーベースのアプリケーションの認証と認可に使用することをお勧めします。 _ID_ トークンと "
"_アクセス_ トークンを取得するために、ブラウザーのリダイレクトを頻繁に使用します。概要を以下に示します。"

#. type: Plain text
msgid ""
"Browser visits application.  The application notices the user is not logged "
"in, so it redirects the browser to {project_name} to be authenticated.  The "
"application passes along a callback URL (a redirect URL) as a query "
"parameter in this browser redirect that {project_name} will use when it "
"finishes authentication."
msgstr ""
"ブラウザーがアプリケーションにアクセスします。アプリケーションは、ユーザーがログインしていないことを検知し、認証させるためにブラウザーを{project_name}にリダイレクトします。アプリケーションは、{project_name}が認証を完了したときに使用するブラウザー・リダイレクトのコールバックURL（リダイレクトURL）をクエリー・パラメーターとして渡します。"

#. type: Plain text
msgid ""
"{project_name} authenticates the user and creates a one-time, very short "
"lived, temporary code.  {project_name} redirects back to the application "
"using the callback URL provided earlier and additionally adds the temporary "
"code as a query parameter in the callback URL."
msgstr ""
"{project_name}はユーザーを認証し、1回限りで非常に存続期間の短い、一時的なコードを作成します。{project_name}は、以前に提供されたコールバックURLを使用してアプリケーションにリダイレクトします。コールバックURLには、クエリー・パラメーターとして一時コードが追加されます。"

#. type: Plain text
msgid ""
"The application extracts the temporary code and makes a background out of "
"band REST invocation to {project_name} to exchange the code for an "
"_identity_, _access_ and _refresh_ token.  Once this temporary code has been"
" used once to obtain the tokens, it can never be used again.  This prevents "
"potential replay attacks."
msgstr ""
"アプリケーションは一時コードを抽出し、それを _ID_ トークン、 _アクセス_ トークンおよび _リフレッシュ_ "
"トークンと交換するため、バックグラウンドで帯域外の{project_name}へのREST呼び出しを行います。この一時コードを一度使用してトークンを取得すると、それを再び使用することはできません。これにより潜在的なリプレイ攻撃が防止されます。"

#. type: Plain text
msgid ""
"It is important to note that _access_ tokens are usually short lived and "
"often expired after only minutes.  The additional _refresh_ token that was "
"transmitted by the login protocol allows the application to obtain a new "
"access token after it expires.  This refresh protocol is important in the "
"situation of a compromised system.  If access tokens are short lived, the "
"whole system is only vulnerable to a stolen token for the lifetime of the "
"access token.  Future refresh token requests will fail if an admin has "
"revoked access.  This makes things more secure and more scalable."
msgstr ""
"_アクセス_ トークンは通常短命であり、しばしば数分後に失効されることに注意することが重要です。ログイン・プロトコルによって送信された追加の "
"_リフレッシュ_ "
"トークンにより、アプリケーションは有効期限が切れた後に新しいアクセストークンを取得できます。このリフレッシュ・プロトコルは、システムが侵害された状況で重要です。アクセストークンが短命である場合、システム全体は、アクセストークンの存続期間中に盗まれたトークンに対してのみ脆弱です。管理者がアクセスを取り消した場合、その後のリフレッシュトークン・リクエストは失敗します。これにより、より安全でスケーラブルになります。"

#. type: Plain text
msgid ""
"Another important aspect of this flow is the concept of a _public_ vs. a "
"_confidential_ client.  _Confidential_ clients are required to provide a "
"client secret when they exchange the temporary codes for tokens.  _Public_ "
"clients are not required to provide this client secret.  _Public_ clients "
"are perfectly fine so long as HTTPS is strictly enforced and you are very "
"strict about what redirect URIs are registered for the client.  "
"HTML5/JavaScript clients always have to be _public_ clients because there is"
" no way to transmit the client secret to them in a secure manner.  Again, "
"this is ok so long as you use HTTPS and strictly enforce redirect URI "
"registration.  This guide goes more detail into this in the xref:assembly-"
"managing-clients_{context}[Managing Clients] chapter."
msgstr ""
"このフローのもう一つの重要な点は、_public_と_confidential_のクライアントの概念です。  "
"_confidential_のクライアントは、一時的なコードをトークンに交換する際に、クライアントシークレットを提供する必要があります。  "
"公開クライアントは、このクライアントシークレットを提供する必要はありません。  "
"_Public_クライアントは、HTTPSが厳密に適用され、クライアントのために登録されるリダイレクトURIが非常に厳密である限り、全く問題ありません。"
"  HTML5/JavaScript クライアントは、クライアントシークレットを安全な方法で送信する方法がないため、常に _public_ "
"クライアントでなければなりません。  繰り返しになりますが、HTTPS を使用し、リダイレクト URI の登録を厳密に実施していれば問題ありません。  "
"このガイドでは、xref:assembly-managing-clients_{context}[Managing "
"Clients]の章で詳しく説明しています。"

#. type: Plain text
msgid ""
"{project_name} also supports the optional "
"https://datatracker.ietf.org/doc/html/rfc7636[Proof Key for Code Exchange] "
"specification."
msgstr ""
"{project_name}は、オプションの https://datatracker.ietf.org/doc/html/rfc7636[Proof "
"Key for Code Exchange] の仕様もサポートしています。"

#. type: Plain text
msgid ""
"This is a browser-based protocol that is similar to Authorization Code Flow "
"except there are fewer requests and no refresh tokens involved.  We do not "
"recommend this flow as there remains the possibility of _access_ tokens "
"being leaked in the browser history as tokens are transmitted via redirect "
"URIs (see below).  Also, since this flow doesn't provide the client with a "
"refresh token, access tokens would either have to be long-lived or users "
"would have to re-authenticate when they expired.  This flow is supported "
"because it is in the OIDC and OAuth 2.0 specification.  Here's a brief "
"summary of the protocol:"
msgstr ""
"これは、リクエストが少なく、リフレッシュトークンが含まれていない点を除いて、認可コードフローと同様のブラウザーベースのプロトコルです。トークンがリダイレクトURI（以下を参照）を介して送信されるため、ブラウザーの履歴に"
" _アクセス_ "
"トークンがリークする可能性があるため、このフローはお勧めしません。また、このフローではクライアントにリフレッシュトークンが提供されないため、アクセストークンを長くするか、期限切れになったときに再認証する必要があります。このフローは、OIDCおよびOAuth"
" 2.0の仕様にあるため、サポートされています。プロトコルの概要を以下に示します。"

#. type: Plain text
msgid ""
"{project_name} authenticates the user and creates an _identity_ and _access_"
" token.  {project_name} redirects back to the application using the callback"
" URL provided earlier and additionally adding the _identity_ and _access_ "
"tokens as query parameters in the callback URL."
msgstr ""
"{project_name}はユーザーを認証し、 _ID_ トークンと _アクセス_ "
"トークンを作成します。{project_name}は、前述のコールバックURLを使用してアプリケーションにリダイレクトし、さらに _ID_ トークンと "
"_アクセス_ トークンをクエリー・パラメーターとしてコールバックURLに追加します。"

#. type: Title =====
#, no-wrap
msgid "Resource Owner Password Credentials Grant (Direct Access Grants)"
msgstr "リソース・オーナー・パスワード・クレデンシャル・グラント（ダイレクト・アクセス・グラント）"

#. type: Plain text
msgid ""
"This is referred to in the Admin Console as _Direct Access Grants_. This is "
"used by REST clients that want to obtain a token on behalf of a user.  It is"
" one HTTP POST request that contains the credentials of the user as well as "
"the id of the client and the client's secret (if it is a confidential "
"client).  The user's credentials are sent within form parameters.  The HTTP "
"response contains _identity_, _access_, and _refresh_ tokens."
msgstr ""
"これは、管理コンソールでは _Direct Access Grants_ "
"と呼ばれます。ユーザーに代わってトークンを取得するRESTクライアントによって使用されます。これは、クライアントIDとクライアント・シークレット（コンフィデンシャル・クライアントの場合）と同様に、ユーザーのクレデンシャルを含む1つのHTTP"
" POSTリクエストとなります。ユーザーのクレデンシャルは、フォーム・パラメーター内で送信されます。HTTPレスポンスには、 _ID_  トークン、 "
"_アクセス_ トークン、および _リフレッシュ_ トークンが含まれています。"

#. type: Title =====
#, no-wrap
msgid "Client Credentials Grant"
msgstr "クライアント・クレデンシャル・グラント"

#. type: Plain text
msgid ""
"This is also used by REST clients, but instead of obtaining a token that "
"works on behalf of an external user, a token is created based on the "
"metadata and permissions of a service account that is associated with the "
"client.  More info together with example is in <<_service_accounts,Service "
"Accounts>> chapter."
msgstr ""
"これはRESTクライアントでも使用されますが、外部ユーザーの代わりに動作するトークンを取得する代わりに、クライアントに関連付けられているサービス・アカウントのメタデータとパーミッションに基づいてトークンが作成されます。さらに詳しい情報は、<<_service_accounts,サービス・アカウント>>の章にあります。"

#. type: Plain text
msgid ""
"This is used by clients who want to initiate the authentication flow by "
"communicating with the OpenID Provider directly without redirect through the"
" user's browser like OAuth 2.0's authorization code grant. Here's a brief "
"summary of the protocol:"
msgstr ""
"これは、OAuth "
"2.0の認可コードグラントのように、ユーザーのブラウザーを介してリダイレクトせずに、OpenIDプロバイダーと直接通信することによって認証フローを開始したいクライアントによって使用されます。プロトコルの概要は次のとおりです。"

#. type: Plain text
#, no-wrap
msgid ""
"Specifying how the CD (Consumption Device) gets the authentication result and related tokens. There are three modes, \"poll\", \"ping\" and \"push\". {project_name} only supports \"poll\" and \"ping\" modes.\n"
"The default setting is \"poll\". This configuration is used as the default mode for clients, however every client can override the mode.\n"
" For more details, see https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#rfc.section.5[CIBA Specification].\n"
msgstr ""
"CD（Consumption Device）には認証結果と関連トークンを取得する方法を指定します。\"poll\"、\"ping\"、\"push\"の3つのモードがあります。{project_name}は\"poll\"と\"ping\"モードのみをサポートします。\n"
"デフォルトの設定は\"poll\"です。この設定はクライアントのデフォルトモードとして使用されますが、すべてのクライアントがモードをオーバーライドすることができます。\n"
"詳細については、 https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#rfc.section.5[CIBA Specification] を参照してください。\n"

#. type: Plain text
msgid ""
"Besides the mentioned parameters, any custom parameter that is sent to the "
"Backchannel Authentication Endpoint, will be forwarded to Channel Provider "
"as well."
msgstr "上記のパラメータ以外にも，バックチャネル認証エンドポイントに送信されたカスタムパラメーターは，チャネル・プロバイダーに転送されます。"

#. type: Title =====
#, no-wrap
msgid "Front-Channel Logout"
msgstr "フロントチャンネルのログアウト"

#. type: Title ====
#, no-wrap
msgid "{project_name} Server OIDC URI Endpoints"
msgstr "{project_name}サーバーOIDC URIエンドポイント"

#. type: Plain text
msgid ""
"Here's a list of OIDC endpoints that the {project_name} publishes.  These "
"URLs are useful if you are using a non-{project_name} client adapter to talk"
" OIDC with the auth server.  These are all relative URLs and the root of the"
" URL being the HTTP(S) protocol, hostname, and usually path prefixed with "
"_/auth_, for example $$https://localhost:8080/auth$$."
msgstr ""
"{project_name}が発行するOIDCエンドポイントのリストです。これらのURLは、{project_name}以外のクライアント・アダプターを使用して、認証サーバーとOIDCでやりとりしている場合に便利です。これらはすべてが相対URLであり、URLのルートはHTTP(S)プロトコル、ホスト名、通常は"
" _/auth_ のプレフィックス付きのパスからなります。たとえば、 $$https://localhost:8080/auth$$ 。"

#. type: Plain text
msgid ""
"You can also find these endpoints under \"OpenID Endpoint Configuration\" in"
" your realm settings."
msgstr "これらのエンドポイントは、レルム設定の「OpenID Endpoint Configuration」の下にもあります。"

#. type: Plain text
#, no-wrap
msgid ""
"/realms/{realm-name}/protocol/openid-connect/auth::\n"
"  This is the URL endpoint for obtaining a temporary code in the Authorization Code Flow or for obtaining tokens via the\n"
"  Implicit Flow or Hybrid Flow.\n"
"/realms/{realm-name}/protocol/openid-connect/token::\n"
"  This is the URL endpoint for the Authorization Code Flow to turn a temporary code into a token, or for obtaining tokens\n"
"  directly via Resource Owner Password Credentials (Direct Access Grants) or Client Credentials.\n"
"/realms/{realm-name}/protocol/openid-connect/logout::\n"
"  This is the URL endpoint for performing logouts.\n"
"/realms/{realm-name}/protocol/openid-connect/userinfo::\n"
"  This is the URL endpoint for the User Info service described in the OIDC specification.\n"
"/realms/{realm-name}/protocol/openid-connect/revoke::\n"
"  This is the URL endpoint for OAuth 2.0 Token Revocation described in https://datatracker.ietf.org/doc/html/rfc7009[RFC7009].\n"
"/realms/{realm-name}/protocol/openid-connect/certs::\n"
"  This is the URL endpoint for the JSON Web Key Set (JWKS) containing the public keys used to verify any JSON Web Token (jwks_uri)\n"
"/realms/{realm-name}/protocol/openid-connect/auth/device::\n"
"  This is the URL endpoint for Device Authorization Grant to obtain a device code and a user code.\n"
"/realms/{realm-name}/protocol/openid-connect/ext/ciba/auth::\n"
"  This is the URL endpoint for Client Initiated Backchannel Authentication Grant to obtain an auth_req_id that identifies the authentication request made by the client.\n"
"/realms/{realm-name}/protocol/openid-connect/logout/backchannel-logout::\n"
"  This is the URL endpoint for performing backchannel logouts described in the OIDC specification.\n"
msgstr ""
"/realms/{realm-name}/protocol/openid-connect/auth::\n"
"  これは、認可コード・フローで一時コードを取得するため、またはインプリシット・フローまたはハイブリット・フローを使用してトークンを取得するためのURLエンドポイントです。\n"
"/realms/{realm-name}/protocol/openid-connect/token::\n"
"  これは、一時コードをトークンに変換する、またはリソースオーナーのパスワード・クレデンシャル（ダイレクト・アクセス・グラント）またはクライアント・クレデンシャルを介してトークンを直接取得するための認可コードフローのURLエンドポイントです。\n"
"/realms/{realm-name}/protocol/openid-connect/logout::\n"
"  これは、ログアウトを実行するためのURLエンドポイントです。\n"
"/realms/{realm-name}/protocol/openid-connect/userinfo::\n"
"  これは、OIDC仕様で説明されているUserInfoサービスのURLエンドポイントです。\n"
"/realms/{realm-name}/protocol/openid-connect/revoke::\n"
"  これは、 https://datatracker.ietf.org/doc/html/rfc7009[RFC7009] で説明されているOAuth 2.0トークン無効化のURLエンドポイントです。\n"
"/realms/{realm-name}/protocol/openid-connect/certs::\n"
"これは、JSON Webトークンの検証に使用される公開鍵を含むJSON Webキー セット（JWKS）のURLエンドポイントです（jwks_uri）。\n"
"/realms/{realm-name}/protocol/openid-connect/auth/device::\n"
"これは、デバイスコードとユーザーコードを取得するためのデバイス認可グラントのURLエンドポイントです。\n"
"/realms/{realm-name}/protocol/openid-connect/ext/ciba/auth::\n"
"これは、クライアントによって行われた認証リクエストを識別するauth_req_idを取得するためのクライアント主導のバックチャネル認証グラントのURLエンドポイントです。\n"
"/realms/{realm-name}/protocol/openid-connect/logout/backchannel-logout::\n"
"これは、OIDC仕様で説明されているバックチャネル・ログアウトを実行するためのURLエンドポイントです。\n"

#. type: Plain text
msgid "In all of these replace _{realm-name}_ with the name of the realm."
msgstr "これらのURLすべてで、 _{realm-name}_ はレルムの名前に置き換えてください。"
