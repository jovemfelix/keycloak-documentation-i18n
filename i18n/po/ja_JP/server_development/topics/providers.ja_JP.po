# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Nomura Research Institute, Ltd.
# This file is distributed under the same license as the keycloak-documentation-i18n package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# jic_m_mito <jic-m-mito@nri.co.jp>, 2018
# Hiroyuki Wada <wadahiro@gmail.com>, 2018
# Kohei Tamura <ktamura.biz.80@gmail.com>, 2018
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n\n"
"Last-Translator: Kohei Tamura <ktamura.biz.80@gmail.com>, 2018\n"
"Language-Team: Japanese (Japan) (https://www.transifex.com/openstandia/teams/79437/ja_JP/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja_JP\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Title ==
#, no-wrap
msgid "Service Provider Interfaces (SPI)"
msgstr "サービス・プロバイダー・インターフェイス（SPI）"

#. type: Plain text
msgid ""
"{project_name} is designed to cover most use-cases without requiring custom "
"code, but we also want it to be customizable.  To achieve this "
"{project_name} has a number of Service Provider Interfaces (SPI) for which "
"you can implement your own providers."
msgstr ""
"{project_name}は、必要なカスタム・コードが無くても、ほとんどのユースケースをカバーできるように作られていますが、カスタマイズもできるようにする必要があります。これを実現するために、{project_name}には独自のプロバイダーを実装できる多数のサービス・プロバイダー・インタフェース（SPI）があります。"

#. type: Title ===
#, no-wrap
msgid "Implementing a SPI"
msgstr "SPIの実装"

#. type: Plain text
msgid ""
"To implement an SPI you need to implement its ProviderFactory and Provider "
"interfaces. You also need to create a service configuration file."
msgstr ""
"SPIを実装するには、SPIのProviderFactoryとプロバイダー・インターフェイスを実装する必要があります。また、サービス設定ファイルを作成する必要があります。"

#. type: Plain text
msgid ""
"For example, to implement the Theme Selector Spi you need to implement "
"ThemeSelectorProviderFactory and ThemeSelectorProvider and also provide the "
"file `META-INF/services/org.keycloak.theme.ThemeSelectorProviderFactory`."
msgstr ""
"たとえば、Theme Selector "
"SPIを実装するには、ThemeSelectorProviderFactoryとThemeSelectorProviderを実装して、 `META-"
"INF/services/org.keycloak.theme.ThemeSelectorProviderFactory` "
"のファイルを提供する必要があります。"

#. type: Plain text
msgid "Example ThemeSelectorProviderFactory:"
msgstr "ThemeSelectorProviderFactoryのサンプルを次に示します。"

#. type: delimited block -
#, no-wrap
msgid "package org.acme.provider;\n"
msgstr "package org.acme.provider;\n"

#. type: delimited block -
#, no-wrap
msgid "import ...\n"
msgstr "import ...\n"

#. type: delimited block -
#, no-wrap
msgid ""
"public class MyThemeSelectorProviderFactory implements "
"ThemeSelectorProviderFactory {\n"
msgstr ""
"public class MyThemeSelectorProviderFactory implements "
"ThemeSelectorProviderFactory {\n"

#. type: delimited block -
#, no-wrap
msgid ""
"      @Override\n"
"        public ThemeSelectorProvider create(KeycloakSession session) {\n"
"            return new MyThemeSelectorProvider(session);\n"
"        }\n"
msgstr ""
"      @Override\n"
"        public ThemeSelectorProvider create(KeycloakSession session) {\n"
"            return new MyThemeSelectorProvider(session);\n"
"        }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        @Override\n"
"        public void init(Config.Scope config) {\n"
"        }\n"
msgstr ""
"        @Override\n"
"        public void init(Config.Scope config) {\n"
"        }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        @Override\n"
"        public void postInit(KeycloakSessionFactory factory) {\n"
"        }\n"
msgstr ""
"        @Override\n"
"        public void postInit(KeycloakSessionFactory factory) {\n"
"        }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        @Override\n"
"        public void close() {\n"
"        }\n"
msgstr ""
"        @Override\n"
"        public void close() {\n"
"        }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        @Override\n"
"        public String getId() {\n"
"            return \"myThemeSelector\";\n"
"        }\n"
"}\n"
msgstr ""
"        @Override\n"
"        public String getId() {\n"
"            return \"myThemeSelector\";\n"
"        }\n"
"}\n"

#. type: Plain text
msgid ""
"Keycloak creates a single instance of provider factories which makes it "
"possible to store state for multiple requests.  Provider instances are "
"created by calling create on the factory for each requests so these should "
"be light-weight object."
msgstr ""
"Keycloakは、複数のリクエストの状態を格納することを可能にするプロバイダー・ファクトリーの単一のインスタンスを作成します。プロバイダー・インスタンスは、それぞれのリクエストに対してファクトリーでcreateを呼び出すことによって作成されるため、軽量オブジェクトである必要があります。"

#. type: Plain text
msgid "Example ThemeSelectorProvider:"
msgstr "ThemeSelectorProviderのサンプルを次に示します。"

#. type: delimited block -
#, no-wrap
msgid ""
"public class MyThemeSelectorProvider implements ThemeSelectorProvider {\n"
msgstr ""
"public class MyThemeSelectorProvider implements ThemeSelectorProvider {\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    public MyThemeSelectorProvider(KeycloakSession session) {\n"
"    }\n"
msgstr ""
"    public MyThemeSelectorProvider(KeycloakSession session) {\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public String getThemeName(Theme.Type type) {\n"
"        return \"my-theme\";\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public String getThemeName(Theme.Type type) {\n"
"        return \"my-theme\";\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"\t@Override\n"
"\tpublic void close() {\n"
"\t}\n"
"}\n"
msgstr ""
"\t@Override\n"
"\tpublic void close() {\n"
"\t}\n"
"}\n"

#. type: Plain text
msgid ""
"Example service configuration file (`META-"
"INF/services/org.keycloak.theme.ThemeSelectorProviderFactory`):"
msgstr ""
"サービス設定ファイル（ `META-"
"INF/services/org.keycloak.theme.ThemeSelectorProviderFactory` ）を次に示します。"

#. type: delimited block -
#, no-wrap
msgid "org.acme.provider.MyThemeSelectorProviderFactory\n"
msgstr "org.acme.provider.MyThemeSelectorProviderFactory\n"

#. type: Plain text
msgid ""
"You can configure your provider through `standalone.xml`, `standalone-"
"ha.xml`, or `domain.xml`.  See the "
"link:{installguide_link}[{installguide_name}] for more details on where the "
"`standalone.xml`, `standalone-ha.xml`, or `domain.xml` file lives."
msgstr ""
"`standalone.xml` 、 `standalone-ha.xml` 、または `domain.xml` "
"を介してプロバイダーを設定することができます。 `standalone.xml` 、 `standalone-ha.xml` 、または "
"`domain.xml` "
"ファイルがある場所についての詳細は、link:{installguide_link}[{installguide_name}]を参照してください。"

#. type: Plain text
msgid "For example by adding the following to `standalone.xml`:"
msgstr "たとえば、下記を `standalone.xml` に追加します。"

#. type: delimited block -
#, no-wrap
msgid ""
"<spi name=\"themeSelector\">\n"
"    <provider name=\"myThemeSelector\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"theme\" value=\"my-theme\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>\n"
msgstr ""
"<spi name=\"themeSelector\">\n"
"    <provider name=\"myThemeSelector\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"theme\" value=\"my-theme\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>\n"

#. type: Plain text
msgid "Then you can retrieve the config in the `ProviderFactory` init method:"
msgstr "そうすると、 `ProviderFactory` のinitメソッドで設定を取得することができます。"

#. type: delimited block -
#, no-wrap
msgid ""
"public void init(Config.Scope config) {\n"
"    String themeName = config.get(\"theme\");\n"
"}\n"
msgstr ""
"public void init(Config.Scope config) {\n"
"    String themeName = config.get(\"theme\");\n"
"}\n"

#. type: Plain text
msgid "Your provider can also lookup other providers if needed. For example:"
msgstr "また、プロバイダーも必要に応じて他のプロバイダーを参照することができます。たとえば、"

#. type: delimited block -
#, no-wrap
msgid ""
"public class MyThemeSelectorProvider implements EventListenerProvider {\n"
msgstr ""
"public class MyThemeSelectorProvider implements EventListenerProvider {\n"

#. type: delimited block -
#, no-wrap
msgid "    private KeycloakSession session;\n"
msgstr "    private KeycloakSession session;\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    public MyThemeSelectorProvider(KeycloakSession session) {\n"
"        this.session = session;\n"
"    }\n"
msgstr ""
"    public MyThemeSelectorProvider(KeycloakSession session) {\n"
"        this.session = session;\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public String getThemeName(Theme.Type type) {\n"
"        return session.getContext().getRealm().getLoginTheme();\n"
"    }\n"
"}\n"
msgstr ""
"    @Override\n"
"    public String getThemeName(Theme.Type type) {\n"
"        return session.getContext().getRealm().getLoginTheme();\n"
"    }\n"
"}\n"

#. type: Title ====
#, no-wrap
msgid "Show info from your SPI implementation in admin console"
msgstr "管理コンソールでのSPI実装の情報表示"

#. type: Plain text
msgid ""
"Sometimes it is useful to show additional info about your Provider to a "
"{project_name} administrator. You can show provider build time informations "
"(eg. version of custom provider currently installed), current configuration "
"of the provider (eg. url of remote system your provider talks to) or some "
"operational info (average time of response from remote system your provider "
"talks to). {project_name} admin console provides Server Info page to show "
"this kind of information."
msgstr ""
"{project_name}管理者にプロバイダーに関する追加情報を表示すると、便利なことがあります。 "
"プロバイダー・ビルド・タイム情報（たとえば、現在インストール済みのカスタム・プロバイダーのバージョン）、プロバイダーの現在の設定（たとえば、プロバイダーが通信するリモートシステムのURL）、または動作情報（たとえば、プロバイダーが通信するリモートシステムからの平均レスポンス・タイム）を表示することができます。{project_name}管理コンソールでは、サーバーの情報ページが提供され、この種の情報が表示されます。"

#. type: Plain text
msgid ""
"To show info from your provider it is enough to implement "
"`org.keycloak.provider.ServerInfoAwareProviderFactory` interface in your "
"`ProviderFactory`."
msgstr ""
"プロバイダーからの情報を表示するには、 `ProviderFactory` 内で "
"`org.keycloak.provider.ServerInfoAwareProviderFactory` インターフェイスを実装するだけです。"

#. type: Plain text
msgid ""
"Example implementation for `MyThemeSelectorProviderFactory` from previous "
"example:"
msgstr "前のサンプルの `MyThemeSelectorProviderFactory` のサンプル実装を次に示します。"

#. type: delimited block -
#, no-wrap
msgid ""
"public class MyThemeSelectorProvider implements ThemeSelectorProvider, ServerInfoAwareProviderFactory {\n"
"    ...\n"
msgstr ""
"public class MyThemeSelectorProvider implements ThemeSelectorProvider, ServerInfoAwareProviderFactory {\n"
"    ...\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> getOperationalInfo() {\n"
"        Map<String, String> ret = new LinkedHashMap<>();\n"
"        ret.put(\"theme-name\", \"my-theme\");\n"
"        return ret;\n"
"    }\n"
"}\n"
msgstr ""
"    @Override\n"
"    public Map<String, String> getOperationalInfo() {\n"
"        Map<String, String> ret = new LinkedHashMap<>();\n"
"        ret.put(\"theme-name\", \"my-theme\");\n"
"        return ret;\n"
"    }\n"
"}\n"

#. type: Title ===
#, no-wrap
msgid "Registering provider implementations"
msgstr "プロバイダー実装の登録"

#. type: Plain text
msgid ""
"There are two ways to register provider implementations. In most cases the "
"simplest way is to use the {project_name} deployer approach as this handles "
"a number of dependencies automatically for you. It also supports hot "
"deployment as well as re-deployment."
msgstr ""
"プロバイダーの実装を登録するには2通りの方法があります。ほとんどの場合、最も簡単な方法は、{project_name} "
"deployerのアプローチを使用することです。なぜなら、この方法だと自動的にたくさんの依存関係が処理されるからです。また、リデプロイだけでなくホットデプロイもサポートされます。"

#. type: Plain text
msgid "The alternative approach is to deploy as a module."
msgstr "代替のアプローチとしては、モジュールとしてデプロイするという方法があります。"

#. type: Plain text
msgid ""
"If you are creating a custom SPI you will need to deploy it as a module, "
"otherwise we recommend using the {project_name} deployer approach."
msgstr ""
"カスタムSPIを作成する場合は、モジュールとして展開する必要があります。それ以外の場合は、{project_name} "
"deployerのアプローチを使用することをお勧めします。"

#. type: Title ====
#, no-wrap
msgid "Using the {project_name} Deployer"
msgstr "{project_name} Deployer の使用"

#. type: Plain text
msgid ""
"If you copy your provider jar to the {project_name} "
"`standalone/deployments/` directory, your provider will automatically be "
"deployed.  Hot deployment works too.  Additionally, your provider jar works "
"similarly to other components deployed in a {appserver_name} environment in "
"that they can use facilities like the `jboss-deployment-structure.xml` file."
"  This file allows you to set up dependencies on other components and load "
"third-party jars and modules."
msgstr ""
"プロバイダーのJARを{project_name}の `standalone/deployments/` "
"ディレクトリーにコピーすると、プロバイダーが自動的にデプロイされます。ホットデプロイも機能します。さらにプロバイダーのJARは、{appserver_name}環境でデプロイされた他のコンポーネントと同じように機能し、その環境下では"
" `jboss-deployment-structure.xml` "
"ファイルと同じようにファシリティーを使用することができます。このファイルによって、他のコンポーネントへの依存関係を設定してサードパーティーのJARとモジュールを読み込むことができます。"

#. type: Plain text
msgid ""
"Provider jars can also be contained within other deployable units like EARs "
"and WARs.  Deploying with a EAR actually makes it really easy to use third "
"party jars as you can just put these libraries in the EAR's `lib/` "
"directory."
msgstr ""
"また、プロバイダーjarを、EARおよびWARと同じように、デプロイ可能な他のユニット内に含めておくこともできます。EARでデプロイすると、実際、第三者のjarを非常に簡単に使用できるようになります。なぜなら、これらのライブラリーをEARの"
" `lib/` ディレクトリーに置くだけで済むからです。"

#. type: Title ====
#, no-wrap
msgid "Register a provider using Modules"
msgstr "モジュールを使用したプロバイダーの登録"

#. type: Plain text
msgid ""
"To register a provider using Modules first create a module.  To do this you "
"can either use the jboss-cli script or manually create a folder inside "
"`KEYCLOAK_HOME/modules` and add your jar and a `module.xml`.  For example to"
" add the event listener sysout example provider using the `jboss-cli` script"
" execute:"
msgstr ""
"たとえばモジュールを使用するプロバイダーを登録すると、まずモジュールが作成されます。これを実行するには、jboss-cliスクリプトを使用するか、手動で"
" `KEYCLOAK_HOME/modules` 内にフォルダーを作成して、jarと `module.xml` を追加します。たとえば、 `jboss-"
"cli` スクリプトを使用してイベントリスナーのsysoutサンプル・プロバイダーを追加するには、以下を実行します。"

#. type: delimited block -
#, no-wrap
msgid ""
"KEYCLOAK_HOME/bin/jboss-cli.sh --command=\"module add "
"--name=org.acme.provider --resources=target/provider.jar "
"--dependencies=org.keycloak.keycloak-core,org.keycloak.keycloak-server-"
"spi\"\n"
msgstr ""
"KEYCLOAK_HOME/bin/jboss-cli.sh --command=\"module add "
"--name=org.acme.provider --resources=target/provider.jar "
"--dependencies=org.keycloak.keycloak-core,org.keycloak.keycloak-server-"
"spi\"\n"

#. type: Plain text
msgid ""
"Or to manually create it start by creating the folder "
"`KEYCLOAK_HOME/modules/org/acme/provider/main`.  Then copy `provider.jar` to"
" this folder and create `module.xml` with the following content:"
msgstr ""
"または、それを手動で作成するには、 `KEYCLOAK_HOME/modules/org/acme/provider/main` "
"フォルダーを作成して起動します。次に `provider.jar` をこのフォルダーにコピーし、以下の内容で `module.xml` を作成します。"

#. type: delimited block -
#, no-wrap
msgid ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<module xmlns=\"urn:jboss:module:1.3\" name=\"org.acme.provider\">\n"
"    <resources>\n"
"        <resource-root path=\"provider.jar\"/>\n"
"    </resources>\n"
"    <dependencies>\n"
"        <module name=\"org.keycloak.keycloak-core\"/>\n"
"        <module name=\"org.keycloak.keycloak-server-spi\"/>\n"
"    </dependencies>\n"
"</module>\n"
msgstr ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<module xmlns=\"urn:jboss:module:1.3\" name=\"org.acme.provider\">\n"
"    <resources>\n"
"        <resource-root path=\"provider.jar\"/>\n"
"    </resources>\n"
"    <dependencies>\n"
"        <module name=\"org.keycloak.keycloak-core\"/>\n"
"        <module name=\"org.keycloak.keycloak-server-spi\"/>\n"
"    </dependencies>\n"
"</module>\n"

#. type: Plain text
msgid ""
"Once you've created the module you need to register this module with "
"{project_name}.  This is done by editing the keycloak-server subsystem "
"section of `standalone.xml`, `standalone-ha.xml`, or `domain.xml`, and "
"adding it to the providers:"
msgstr ""
"モジュールを作成すると、{project_name}でこのモジュールを登録する必要があります。 これは `standalone.xml` 、 "
"`standalone-ha.xml` 、または `domain.xml` のkeycloak-"
"serverサブシステムセクションを編集し、それをプロバイダーに追加することにより行われます。"

#. type: delimited block -
#, no-wrap
msgid ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak-server:1.1\">\n"
"    <web-context>auth</web-context>\n"
"    <providers>\n"
"        <provider>module:org.keycloak.examples.event-sysout</provider>\n"
"    </providers>\n"
"    ...\n"
msgstr ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak-server:1.1\">\n"
"    <web-context>auth</web-context>\n"
"    <providers>\n"
"        <provider>module:org.keycloak.examples.event-sysout</provider>\n"
"    </providers>\n"
"    ...\n"

#. type: Title ====
#, no-wrap
msgid "Disabling a provider"
msgstr "プロバイダーの無効化"

#. type: Plain text
msgid ""
"You can disable a provider by setting the enabled attribute for the provider"
" to false in `standalone.xml`, `standalone-ha.xml`, or `domain.xml`.  For "
"example to disable the Infinispan user cache provider add:"
msgstr ""
"`standalone.xml` 、 `standalone-ha.xml` 、または `domain.xml` "
"内で、プロバイダーの有効な属性をfalseに設定することによって、プロバイダーを無効にすることができます。たとえば、Infinispanユーザー・キャッシュ・プロバイダーを無効にするには、以下を追加します。"

#. type: delimited block -
#, no-wrap
msgid ""
"<spi name=\"userCache\">\n"
"    <provider name=\"infinispan\" enabled=\"false\"/>\n"
"</spi>\n"
msgstr ""
"<spi name=\"userCache\">\n"
"    <provider name=\"infinispan\" enabled=\"false\"/>\n"
"</spi>\n"

#. type: Title ===
#, no-wrap
msgid "Leveraging Java EE"
msgstr "Java EEの活用"

#. type: Plain text
msgid ""
"The service providers can be packaged within any Java EE component so long "
"as you set up the `META-INF/services` file correctly to point to your "
"providers.  For example, if your provider needs to use third party "
"libraries, you can package up your provider within an ear and store these "
"third pary libraries in the ear's `lib/` directory.  Also note that provider"
" jars can make use of the `jboss-deployment-structure.xml` file that EJBs, "
"WARS, and EARs can use in a {appserver_name} environment.  See the "
"{appserver_name} documentation for more details on this file.  It allows you"
" to pull in external dependencies among other fine grain actions."
msgstr ""
"サービス・プロバイダーは、プロバイダーを指し示すように `META-INF/services` ファイルを正しく設定している限りは、いかなるJava "
"EEコンポーネント内でもこれをパッケージ化することができます。たとえば、プロバイダーがサードパーティーのライブラリーを使用する必要がある場合、プロバイダーをEAR内にパッケージ化し、これらのサードパーティーのライブラリーをEARの"
" `lib/` ディレクトリーに格納します。また、プロバイダーjarは、{appserver_name}環境でEJB、WAR、およびEARが使用可能な "
"`jboss-deployment-structure.xml` "
"ファイルを使用することができる点に注意してください。このファイルについて、詳しくは、{appserver_name}のドキュメントを参照ください。これにより、他の細かい動作間で外部との依存関係を引き出すことができます。"

#. type: Plain text
msgid ""
"`ProviderFactory` implementations are required to be plain java objects.  "
"But, we also currently support implementing provider classes as Stateful "
"EJBs.  This is how you would do it:"
msgstr ""
"`ProviderFactory` "
"の実装はプレーンなJavaオブジェクトである必要があります。ただし、現在は、ステートフルEJBとしてプロバイダー・クラスとして実装することもサポートもしています。"
" "

#. type: delimited block -
#, no-wrap
msgid ""
"@Stateful\n"
"@Local(EjbExampleUserStorageProvider.class)\n"
"public class EjbExampleUserStorageProvider implements UserStorageProvider,\n"
"        UserLookupProvider,\n"
"        UserRegistrationProvider,\n"
"        UserQueryProvider,\n"
"        CredentialInputUpdater,\n"
"        CredentialInputValidator,\n"
"        OnUserCache\n"
"{\n"
"    @PersistenceContext\n"
"    protected EntityManager em;\n"
msgstr ""
"@Stateful\n"
"@Local(EjbExampleUserStorageProvider.class)\n"
"public class EjbExampleUserStorageProvider implements UserStorageProvider,\n"
"        UserLookupProvider,\n"
"        UserRegistrationProvider,\n"
"        UserQueryProvider,\n"
"        CredentialInputUpdater,\n"
"        CredentialInputValidator,\n"
"        OnUserCache\n"
"{\n"
"    @PersistenceContext\n"
"    protected EntityManager em;\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    protected ComponentModel model;\n"
"    protected KeycloakSession session;\n"
msgstr ""
"    protected ComponentModel model;\n"
"    protected KeycloakSession session;\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    public void setModel(ComponentModel model) {\n"
"        this.model = model;\n"
"    }\n"
msgstr ""
"    public void setModel(ComponentModel model) {\n"
"        this.model = model;\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    public void setSession(KeycloakSession session) {\n"
"        this.session = session;\n"
"    }\n"
msgstr ""
"    public void setSession(KeycloakSession session) {\n"
"        this.session = session;\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Remove\n"
"    @Override\n"
"    public void close() {\n"
"    }\n"
"...\n"
"}\n"
msgstr ""
"    @Remove\n"
"    @Override\n"
"    public void close() {\n"
"    }\n"
"...\n"
"}\n"

#. type: Plain text
msgid ""
"You have to define the `@Local` annotation and specify your provider class "
"there.  If you don't do this, EJB will not proxy the provider instance "
"correctly and your provider won't work."
msgstr ""
"ここで、 `@Local` "
"アノテーションを定義し、プロバイダー・クラスを指定する必要があります。これを行わないと、EJBはプロバイダー・インスタンスを正しくプロキシーせず、プロバイダーは機能しません。"

#. type: Plain text
msgid ""
"You must put the `@Remove` annotation on the `close()` method of your "
"provider.  If you don't, the stateful bean will never be cleaned up and you "
"may eventually see error messages."
msgstr ""
"`@Remove` アノテーションをプロバイダーの `close()` "
"メソッドに付与する必要があります。これを行わないと、ステートフルbeanは決してクリーンアップされず、最終的にエラーメッセージが表示されることになります。"

#. type: Plain text
msgid ""
"Implementations of `ProviderFactory` are required to be plain java objects."
"  Your factory class would perform a JNDI lookup of the Stateful EJB in its "
"create() method."
msgstr ""
"`ProviderFactory` の実装はプレーンなJavaオブジェクトである必要があります。ファクトリー・クラスは、その create() "
"メソッド内でステートフルEJBのJNDIルックアップを実行します。"

#. type: delimited block -
#, no-wrap
msgid ""
"public class EjbExampleUserStorageProviderFactory\n"
"        implements UserStorageProviderFactory<EjbExampleUserStorageProvider> {\n"
msgstr ""
"public class EjbExampleUserStorageProviderFactory\n"
"        implements UserStorageProviderFactory<EjbExampleUserStorageProvider> {\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public EjbExampleUserStorageProvider create(KeycloakSession session, ComponentModel model) {\n"
"        try {\n"
"            InitialContext ctx = new InitialContext();\n"
"            EjbExampleUserStorageProvider provider = (EjbExampleUserStorageProvider)ctx.lookup(\n"
"                     \"java:global/user-storage-jpa-example/\" + EjbExampleUserStorageProvider.class.getSimpleName());\n"
"            provider.setModel(model);\n"
"            provider.setSession(session);\n"
"            return provider;\n"
"        } catch (Exception e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public EjbExampleUserStorageProvider create(KeycloakSession session, ComponentModel model) {\n"
"        try {\n"
"            InitialContext ctx = new InitialContext();\n"
"            EjbExampleUserStorageProvider provider = (EjbExampleUserStorageProvider)ctx.lookup(\n"
"                     \"java:global/user-storage-jpa-example/\" + EjbExampleUserStorageProvider.class.getSimpleName());\n"
"            provider.setModel(model);\n"
"            provider.setSession(session);\n"
"            return provider;\n"
"        } catch (Exception e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }\n"

#. type: Title ===
#, no-wrap
msgid "Available SPIs"
msgstr "利用可能なSPI"

#. type: Plain text
msgid ""
"If you want to see list of all available SPIs at runtime, you can check "
"`Server Info` page in admin console as described in "
"<<_providers_admin_console,Admin Console>> section."
msgstr ""
"利用可能なすべてのSPIのリストを実行時に確認する必要がある場合は、<<_providers_admin_console, "
"管理コンソール>>セクションでの説明通りに、管理コンソール内の `Server Info` ページを確認します。"
