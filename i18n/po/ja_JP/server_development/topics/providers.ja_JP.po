# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Nomura Research Institute, Ltd.
# This file is distributed under the same license as the keycloak-documentation-i18n package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# jic_m_mito <jic-m-mito@nri.co.jp>, 2020
# katakura__pro <h.katakura@pro-japan.co.jp>, 2020
# Hiroyuki Wada <wadahiro@gmail.com>, 2021
# Kohei Tamura <ktamura.biz.80@gmail.com>, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n\n"
"Last-Translator: Kohei Tamura <ktamura.biz.80@gmail.com>, 2022\n"
"Language-Team: Japanese (Japan) (https://www.transifex.com/openstandia/teams/79437/ja_JP/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja_JP\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Title ====
#, no-wrap
msgid "Disabling a provider"
msgstr "プロバイダーの無効化"

#. type: Title ====
#, no-wrap
msgid "Authenticator"
msgstr "オーセンティケーター"

#. type: delimited block -
#, no-wrap
msgid "import ...\n"
msgstr "import ...\n"

#. type: Title ==
#, no-wrap
msgid "Service Provider Interfaces (SPI)"
msgstr "サービス・プロバイダー・インターフェイス（SPI）"

#. type: Plain text
msgid ""
"{project_name} is designed to cover most use-cases without requiring custom "
"code, but we also want it to be customizable.  To achieve this "
"{project_name} has a number of Service Provider Interfaces (SPI) for which "
"you can implement your own providers."
msgstr ""
"{project_name}は、必要なカスタム・コードが無くても、ほとんどのユースケースをカバーできるように作られていますが、カスタマイズもできるようにする必要があります。これを実現するために、{project_name}には独自のプロバイダーを実装できる多数のサービス・プロバイダー・インタフェース（SPI）があります。"

#. type: Title ===
#, no-wrap
msgid "Implementing an SPI"
msgstr "SPIの実装"

#. type: Plain text
msgid ""
"To implement an SPI you need to implement its ProviderFactory and Provider "
"interfaces. You also need to create a service configuration file."
msgstr ""
"SPIを実装するには、SPIのProviderFactoryとProviderインターフェイスを実装する必要があります。また、サービス設定ファイルを作成する必要があります。"

#. type: Plain text
msgid ""
"For example, to implement the Theme Selector SPI you need to implement "
"ThemeSelectorProviderFactory and ThemeSelectorProvider and also provide the "
"file `META-INF/services/org.keycloak.theme.ThemeSelectorProviderFactory`."
msgstr ""
"たとえば、Theme Selector "
"SPIを実装するには、ThemeSelectorProviderFactoryとThemeSelectorProviderを実装して、 `META-"
"INF/services/org.keycloak.theme.ThemeSelectorProviderFactory` "
"のファイルを提供する必要があります。"

#. type: Plain text
msgid "Example ThemeSelectorProviderFactory:"
msgstr "ThemeSelectorProviderFactoryのサンプルを次に示します。"

#. type: delimited block -
#, no-wrap
msgid "package org.acme.provider;\n"
msgstr "package org.acme.provider;\n"

#. type: delimited block -
#, no-wrap
msgid ""
"public class MyThemeSelectorProviderFactory implements "
"ThemeSelectorProviderFactory {\n"
msgstr ""
"public class MyThemeSelectorProviderFactory implements "
"ThemeSelectorProviderFactory {\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public ThemeSelectorProvider create(KeycloakSession session) {\n"
"        return new MyThemeSelectorProvider(session);\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public ThemeSelectorProvider create(KeycloakSession session) {\n"
"        return new MyThemeSelectorProvider(session);\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void init(Config.Scope config) {\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public void init(Config.Scope config) {\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void postInit(KeycloakSessionFactory factory) {\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public void postInit(KeycloakSessionFactory factory) {\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void close() {\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public void close() {\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public String getId() {\n"
"        return \"myThemeSelector\";\n"
"    }\n"
"}\n"
msgstr ""
"    @Override\n"
"    public String getId() {\n"
"        return \"myThemeSelector\";\n"
"    }\n"
"}\n"

#. type: Plain text
msgid ""
"Keycloak creates a single instance of provider factories which makes it "
"possible to store state for multiple requests.  Provider instances are "
"created by calling create on the factory for each request so these should be"
" light-weight object."
msgstr ""
"Keycloakは、複数のリクエストの状態を格納することを可能にするプロバイダー・ファクトリーの単一のインスタンスを作成します。プロバイダー・インスタンスは、それぞれのリクエストに対してファクトリーでcreateを呼び出すことによって作成されるため、軽量オブジェクトである必要があります。"

#. type: Plain text
msgid "Example ThemeSelectorProvider:"
msgstr "ThemeSelectorProviderのサンプルを次に示します。"

#. type: delimited block -
#, no-wrap
msgid ""
"public class MyThemeSelectorProvider implements ThemeSelectorProvider {\n"
msgstr ""
"public class MyThemeSelectorProvider implements ThemeSelectorProvider {\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    public MyThemeSelectorProvider(KeycloakSession session) {\n"
"    }\n"
msgstr ""
"    public MyThemeSelectorProvider(KeycloakSession session) {\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public String getThemeName(Theme.Type type) {\n"
"        return \"my-theme\";\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public String getThemeName(Theme.Type type) {\n"
"        return \"my-theme\";\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"\tpublic void close() {\n"
"    }\n"
"}\n"
msgstr ""
"    @Override\n"
"\tpublic void close() {\n"
"    }\n"
"}\n"

#. type: Plain text
msgid ""
"Example service configuration file (`META-"
"INF/services/org.keycloak.theme.ThemeSelectorProviderFactory`):"
msgstr ""
"サービス設定ファイル（ `META-"
"INF/services/org.keycloak.theme.ThemeSelectorProviderFactory` ）を次に示します。"

#. type: delimited block -
#, no-wrap
msgid "org.acme.provider.MyThemeSelectorProviderFactory\n"
msgstr "org.acme.provider.MyThemeSelectorProviderFactory\n"

#. type: Plain text
msgid ""
"You can configure your provider through `standalone.xml`, `standalone-"
"ha.xml`, or `domain.xml`."
msgstr ""
"プロバイダーは、 `standalone.xml` 、 `standalone-ha.xml` 、または `domain.xml` で設定できます。"

#. type: Plain text
msgid "For example by adding the following to `standalone.xml`:"
msgstr "たとえば、下記を `standalone.xml` に追加します。"

#. type: delimited block -
#, no-wrap
msgid ""
"<spi name=\"themeSelector\">\n"
"    <provider name=\"myThemeSelector\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"theme\" value=\"my-theme\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>\n"
msgstr ""
"<spi name=\"themeSelector\">\n"
"    <provider name=\"myThemeSelector\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"theme\" value=\"my-theme\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>\n"

#. type: Plain text
msgid "Then you can retrieve the config in the `ProviderFactory` init method:"
msgstr "そうすると、 `ProviderFactory` のinitメソッドで設定を取得することができます。"

#. type: delimited block -
#, no-wrap
msgid ""
"public void init(Config.Scope config) {\n"
"    String themeName = config.get(\"theme\");\n"
"}\n"
msgstr ""
"public void init(Config.Scope config) {\n"
"    String themeName = config.get(\"theme\");\n"
"}\n"

#. type: Plain text
msgid "Your provider can also lookup other providers if needed. For example:"
msgstr "また、プロバイダーも必要に応じて他のプロバイダーを参照することができます。以下が例です。"

#. type: delimited block -
#, no-wrap
msgid "    private KeycloakSession session;\n"
msgstr "    private KeycloakSession session;\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    public MyThemeSelectorProvider(KeycloakSession session) {\n"
"        this.session = session;\n"
"    }\n"
msgstr ""
"    public MyThemeSelectorProvider(KeycloakSession session) {\n"
"        this.session = session;\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public String getThemeName(Theme.Type type) {\n"
"        return session.getContext().getRealm().getLoginTheme();\n"
"    }\n"
"}\n"
msgstr ""
"    @Override\n"
"    public String getThemeName(Theme.Type type) {\n"
"        return session.getContext().getRealm().getLoginTheme();\n"
"    }\n"
"}\n"

#. type: Title ====
#, no-wrap
msgid "Show info from your SPI implementation in admin console"
msgstr "管理コンソールでのSPI実装の情報表示"

#. type: Plain text
msgid ""
"Sometimes it is useful to show additional info about your Provider to a "
"{project_name} administrator. You can show provider build time information "
"(eg. version of custom provider currently installed), current configuration "
"of the provider (eg. url of remote system your provider talks to) or some "
"operational info (average time of response from remote system your provider "
"talks to). {project_name} admin console provides Server Info page to show "
"this kind of information."
msgstr ""
"{project_name}管理者にプロバイダーに関する追加情報を表示すると、便利なことがあります。 "
"プロバイダー・ビルド・タイム情報（たとえば、現在インストール済みのカスタム・プロバイダーのバージョン）、プロバイダーの現在の設定（たとえば、プロバイダーが通信するリモートシステムのURL）、または動作情報（たとえば、プロバイダーが通信するリモートシステムからの平均レスポンス・タイム）を表示することができます。{project_name}管理コンソールでは、サーバーの情報ページが提供され、この種の情報が表示されます。"

#. type: Plain text
msgid ""
"To show info from your provider it is enough to implement "
"`org.keycloak.provider.ServerInfoAwareProviderFactory` interface in your "
"`ProviderFactory`."
msgstr ""
"プロバイダーからの情報を表示するには、 `ProviderFactory` 内で "
"`org.keycloak.provider.ServerInfoAwareProviderFactory` インターフェイスを実装するだけです。"

#. type: Plain text
msgid ""
"Example implementation for `MyThemeSelectorProviderFactory` from previous "
"example:"
msgstr "前のサンプルの `MyThemeSelectorProviderFactory` のサンプル実装を次に示します。"

#. type: delimited block -
#, no-wrap
msgid ""
"public class MyThemeSelectorProviderFactory implements ThemeSelectorProviderFactory, ServerInfoAwareProviderFactory {\n"
"    ...\n"
msgstr ""
"public class MyThemeSelectorProviderFactory implements ThemeSelectorProviderFactory, ServerInfoAwareProviderFactory {\n"
"    ...\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> getOperationalInfo() {\n"
"        Map<String, String> ret = new LinkedHashMap<>();\n"
"        ret.put(\"theme-name\", \"my-theme\");\n"
"        return ret;\n"
"    }\n"
"}\n"
msgstr ""
"    @Override\n"
"    public Map<String, String> getOperationalInfo() {\n"
"        Map<String, String> ret = new LinkedHashMap<>();\n"
"        ret.put(\"theme-name\", \"my-theme\");\n"
"        return ret;\n"
"    }\n"
"}\n"

#. type: Title ===
#, no-wrap
msgid "Use available providers"
msgstr "利用可能なプロバイダーを使用する"

#. type: Plain text
msgid ""
"In your provider implementation, you can use other providers available in "
"{project_name}. The existing providers can be typically retrieved with the "
"usage of the `KeycloakSession`, which is available to your provider as "
"described in the section <<_implementing_spi,Implementing an SPI>>."
msgstr ""
"プロバイダーの実装では、{project_name} で利用可能な他のプロバイダーを使用できます。通常、既存のプロバイダーは "
"`KeycloakSession` を使用して取得できます。セクション<<_implementing_spi,SPI "
"の実装>>で説明されているように、これをプロバイダーに利用できます。"

#. type: Plain text
msgid "{project_name} has two provider types:"
msgstr "{project_name} には次の2つのプロバイダーのタイプがあります。"

#. type: Plain text
#, no-wrap
msgid ""
"*Single-implementation provider types* - There can be only a single active implementation of the particular provider type in {project_name} runtime.\n"
"For example `HostnameProvider` specifies the hostname to be used by {project_name} and that is shared for the whole {project_name} server.\n"
"Hence there can be only single implementation of this provider active for the {project_name} server. If there are multiple provider implementations available to the server runtime,\n"
"one of them needs to be specified in the keycloak subsystem configuration in the `standalone.xml` as the default one. For example such as:\n"
msgstr ""
"*単一実装のプロバイダータイプ* - {project_name} "
"ランタイムには、特定のプロバイダータイプの単一のアクティブな実装のみが存在できます。たとえば、 `HostnameProvider` "
"は、{project_name}によって使用されるホスト名を指定し、{project_name}サーバー全体で共有されます。したがって、{project_name}サーバーに対してアクティブなこのプロバイダーの実装は"
" 1 つしかありません。サーバーランタイムで使用できるプロバイダー実装が複数ある場合、そのうちの1つは、 `standalone.xml` "
"のkeycloakサブシステム設定でデフォルトとして指定する必要があります。たとえば、次のようなものです。\n"

#. type: delimited block -
#, no-wrap
msgid ""
"<spi name=\"hostname\">\n"
"    <default-provider>default</default-provider>\n"
"    ...\n"
"</spi>\n"
msgstr ""
"<spi name=\"hostname\">\n"
"    <default-provider>default</default-provider>\n"
"    ...\n"
"</spi>\n"

#. type: Plain text
msgid ""
"The value `default` used as the value of `default-provider` must match the "
"ID returned by the `ProviderFactory.getId()` of the particular provider "
"factory implementation.  In the code, you can obtain the provider such as "
"`keycloakSession.getProvider(HostnameProvider.class)`"
msgstr ""
"`default-provider` の値として使用される `default` の値は、特定のプロバイダー・ファクトリーの実装の "
"`ProviderFactory.getId()` によって返されるIDと一致する必要があります。コードでは、 "
"`keycloakSession.getProvider(HostnameProvider.class)` などのプロバイダーを取得できます。"

#. type: Plain text
#, no-wrap
msgid ""
"*Multiple implementation provider types* - Those are provider types, that allow multiple implementations available and working together\n"
"in the {project_name} runtime. For example `EventListener` provider allows to have multiple implementations available and registered, which means\n"
"that particular event can be sent to all the listeners (jboss-logging, sysout etc). In the code, you can obtain a specified instance of the provider\n"
"for example such as `session.getProvider(EventListener.class, \"jboss-logging\")` . You need to specify `provider_id` of the provider as the second argument\n"
"as there can be multiple instances of this provider type as described above. The provider ID must match the ID returned by the `ProviderFactory.getId()` of the\n"
"particular provider factory implementation. Some provider types can be retrieved with the usage of `ComponentModel` as the second argument and some (for example `Authenticator`) even\n"
"need to be retrieved with the usage of `KeycloakSessionFactory`. It is not recommended to implement your own providers this way as it may be deprecated in the future.\n"
msgstr ""
"*複数の実装プロバイダー・タイプ* - "
"複数の実装が利用可能で、{project_name}ランタイムで一緒に動作できるプロバイダー・タイプです。たとえば、 `EventListener` "
"プロバイダーでは、複数の実装を使用可能にして登録できます。これは、特定のイベントをすべてのリスナー (jboss-logging、sysout など) "
"に送信できることを意味します。コードでは、例えば `session.getProvider(EventListener.class, \"jboss-"
"logging\")` "
"などのプロバイダーの指定されたインスタンスを取得できます。上記のように、このプロバイダー・タイプには複数のインスタンスが存在する可能性があるため、プロバイダーの"
" `provider_id` を 2 番目の引数として指定する必要があります。プロバイダーIDは、特定のプロバイダー ファクトリ実装の "
"`ProviderFactory.getId()` によって返されるIDと一致する必要があります。一部のプロバイダー・タイプは、2番目の引数として "
"`ComponentModel` を使用して取得でき、一部 (たとえば `Authenticator` ) は "
"`KeycloakSessionFactory` "
"を使用して取得する必要さえあります。将来的に廃止される可能性があるため、この方法で独自のプロバイダーを実装することはお勧めしません。\n"

#. type: Title ===
#, no-wrap
msgid "Registering provider implementations"
msgstr "プロバイダー実装の登録"

#. type: Plain text
msgid ""
"There are two ways to register provider implementations. In most cases the "
"simplest way is to use the {project_name} deployer approach as this handles "
"a number of dependencies automatically for you. It also supports hot "
"deployment as well as re-deployment."
msgstr ""
"プロバイダーの実装を登録するには2通りの方法があります。ほとんどの場合、最も簡単な方法は、{project_name} "
"deployerのアプローチを使用することです。なぜなら、この方法だと自動的にたくさんの依存関係が処理されるからです。また、リデプロイだけでなくホットデプロイもサポートされます。"

#. type: Plain text
msgid "The alternative approach is to deploy as a module."
msgstr "代替のアプローチとしては、モジュールとしてデプロイするという方法があります。"

#. type: Plain text
msgid ""
"If you are creating a custom SPI you will need to deploy it as a module, "
"otherwise we recommend using the {project_name} deployer approach."
msgstr ""
"カスタムSPIを作成する場合は、モジュールとして展開する必要があります。それ以外の場合は、{project_name} "
"deployerのアプローチを使用することをお勧めします。"

#. type: Title ====
#, no-wrap
msgid "Using the {project_name} Deployer"
msgstr "{project_name} Deployer の使用"

#. type: Plain text
msgid ""
"If you copy your provider jar to the {project_name} "
"`standalone/deployments/` directory, your provider will automatically be "
"deployed.  Hot deployment works too.  Additionally, your provider jar works "
"similarly to other components deployed in a {appserver_name} environment in "
"that they can use facilities like the `jboss-deployment-structure.xml` file."
"  This file allows you to set up dependencies on other components and load "
"third-party jars and modules."
msgstr ""
"プロバイダーのJARを{project_name}の `standalone/deployments/` "
"ディレクトリーにコピーすると、プロバイダーが自動的にデプロイされます。ホットデプロイも機能します。さらに、プロバイダーのJARファイルは `jboss-"
"deployment-structure.xml` "
"ファイルのような機能を使うことができるという点で、{appserver_name}環境にデプロイされた他のコンポーネントと同様に機能します。このファイルによって、他のコンポーネントへの依存関係を設定してサードパーティーのJARとモジュールを読み込むことができます。"

#. type: Plain text
msgid ""
"Provider jars can also be contained within other deployable units like EARs "
"and WARs.  Deploying with a EAR actually makes it really easy to use third "
"party jars as you can just put these libraries in the EAR's `lib/` "
"directory."
msgstr ""
"また、プロバイダーJARを、EARおよびWARと同じように、デプロイ可能な他のユニット内に含めておくこともできます。EARでデプロイすると、実際、サードパーティーのJARを非常に簡単に使用できるようになります。なぜなら、これらのライブラリーをEARの"
" `lib/` ディレクトリーに置くだけで済むからです。"

#. type: Title ====
#, no-wrap
msgid "Register a provider using Modules"
msgstr "Modulesを使用したプロバイダーの登録"

#. type: Plain text
msgid ""
"To register a provider using Modules first create a module.  To do this you "
"can either use the jboss-cli script or manually create a folder inside "
"`KEYCLOAK_HOME/modules` and add your jar and a `module.xml`.  For example to"
" add the event listener sysout example provider using the `jboss-cli` script"
" execute:"
msgstr ""
"Modulesを使用してプロバイダーを登録するには、まずモジュールを作成します。これを実行するには、jboss-cliスクリプトを使用するか、手動で "
"`KEYCLOAK_HOME/modules` 内にフォルダーを作成して、JARと `module.xml` を追加します。たとえば、 `jboss-"
"cli` スクリプトを使用してイベントリスナーのsysoutサンプル・プロバイダーを追加するには、以下を実行します。"

#. type: delimited block -
#, no-wrap
msgid ""
"KEYCLOAK_HOME/bin/jboss-cli.sh --command=\"module add "
"--name=org.acme.provider --resources=target/provider.jar "
"--dependencies=org.keycloak.keycloak-core,org.keycloak.keycloak-server-"
"spi\"\n"
msgstr ""
"KEYCLOAK_HOME/bin/jboss-cli.sh --command=\"module add "
"--name=org.acme.provider --resources=target/provider.jar "
"--dependencies=org.keycloak.keycloak-core,org.keycloak.keycloak-server-"
"spi\"\n"

#. type: Plain text
msgid ""
"Or to manually create it start by creating the folder "
"`KEYCLOAK_HOME/modules/org/acme/provider/main`.  Then copy `provider.jar` to"
" this folder and create `module.xml` with the following content:"
msgstr ""
"または、それを手動で作成するには、まずは `KEYCLOAK_HOME/modules/org/acme/provider/main` "
"フォルダーを作成します。次に `provider.jar` をこのフォルダーにコピーし、以下の内容で `module.xml` を作成します。"

#. type: delimited block -
#, no-wrap
msgid ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<module xmlns=\"urn:jboss:module:1.3\" name=\"org.acme.provider\">\n"
"    <resources>\n"
"        <resource-root path=\"provider.jar\"/>\n"
"    </resources>\n"
"    <dependencies>\n"
"        <module name=\"org.keycloak.keycloak-core\"/>\n"
"        <module name=\"org.keycloak.keycloak-server-spi\"/>\n"
"    </dependencies>\n"
"</module>\n"
msgstr ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<module xmlns=\"urn:jboss:module:1.3\" name=\"org.acme.provider\">\n"
"    <resources>\n"
"        <resource-root path=\"provider.jar\"/>\n"
"    </resources>\n"
"    <dependencies>\n"
"        <module name=\"org.keycloak.keycloak-core\"/>\n"
"        <module name=\"org.keycloak.keycloak-server-spi\"/>\n"
"    </dependencies>\n"
"</module>\n"

#. type: Plain text
msgid ""
"Once you've created the module you need to register this module with "
"{project_name}.  This is done by editing the keycloak-server subsystem "
"section of `standalone.xml`, `standalone-ha.xml`, or `domain.xml`, and "
"adding it to the providers:"
msgstr ""
"モジュールを作成したら、{project_name}にこのモジュールを登録する必要があります。登録は、 `standalone.xml` 、 "
"`standalone-ha.xml` 、または `domain.xml` のkeycloak-"
"serverサブシステムのセクションを編集し、それをプロバイダーに追加することにより行われます。"

#. type: delimited block -
#, no-wrap
msgid ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak-server:1.1\">\n"
"    <web-context>auth</web-context>\n"
"    <providers>\n"
"        <provider>module:org.keycloak.examples.event-sysout</provider>\n"
"    </providers>\n"
"    ...\n"
msgstr ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak-server:1.1\">\n"
"    <web-context>auth</web-context>\n"
"    <providers>\n"
"        <provider>module:org.keycloak.examples.event-sysout</provider>\n"
"    </providers>\n"
"    ...\n"

#. type: Plain text
msgid ""
"You can disable a provider by setting the enabled attribute for the provider"
" to false in `standalone.xml`, `standalone-ha.xml`, or `domain.xml`.  For "
"example to disable the Infinispan user cache provider add:"
msgstr ""
"`standalone.xml` 、 `standalone-ha.xml` 、または `domain.xml` "
"内で、プロバイダーのenabled属性をfalseに設定することによって、プロバイダーを無効にすることができます。たとえば、Infinispanユーザー・キャッシュ・プロバイダーを無効にするには、以下を追加します。"

#. type: delimited block -
#, no-wrap
msgid ""
"<spi name=\"userCache\">\n"
"    <provider name=\"infinispan\" enabled=\"false\"/>\n"
"</spi>\n"
msgstr ""
"<spi name=\"userCache\">\n"
"    <provider name=\"infinispan\" enabled=\"false\"/>\n"
"</spi>\n"

#. type: Title ===
#, no-wrap
msgid "Leveraging Jakarta EE"
msgstr "Jakarta EEの活用"

#. type: Plain text
msgid ""
"The service providers can be packaged within any Jakarta EE component so "
"long as you set up the `META-INF/services` file correctly to point to your "
"providers.  For example, if your provider needs to use third party "
"libraries, you can package up your provider within an ear and store these "
"third party libraries in the ear's `lib/` directory.  Also note that "
"provider jars can make use of the `jboss-deployment-structure.xml` file that"
" EJBs, WARS, and EARs can use in a {appserver_name} environment.  See the "
"{appserver_name} documentation for more details on this file.  It allows you"
" to pull in external dependencies among other fine grain actions."
msgstr ""
"サービス・プロバイダーは、プロバイダーを指すように `META-INF/services` ファイルを正しくセットアップすれば、どのJakarta "
"EEコンポーネント内でもパッケージ化することができます。たとえば、プロバイダーがサードパーティーのライブラリーを使用する必要がある場合、プロバイダーをEARの中にパッケージングして、EARの"
" `lib/` "
"ディレクトリーにサードパーティーのライブラリーを格納することができます。また、プロバイダーのjarは、EJB、WAR、およびEARが{appserver_name}の環境で使用できる"
" `jboss-deployment-structure.xml` "
"ファイルを利用できることに注意してください。このファイルの詳細については、{appserver_name}のドキュメントを参照してください。このファイルによって、他の細かいアクションの中で、外部の依存関係を取り込むことができます。"

#. type: Plain text
msgid ""
"`ProviderFactory` implementations are required to be plain java objects.  "
"But, we also currently support implementing provider classes as Stateful "
"EJBs.  This is how you would do it:"
msgstr ""
"`ProviderFactory` "
"の実装はプレーンなJavaオブジェクトである必要があります。ただし、現在は、ステートフルEJBとしてプロバイダー・クラスとして実装することもサポートもしています。"
" "

#. type: delimited block -
#, no-wrap
msgid ""
"@Stateful\n"
"@Local(EjbExampleUserStorageProvider.class)\n"
"public class EjbExampleUserStorageProvider implements UserStorageProvider,\n"
"        UserLookupProvider,\n"
"        UserRegistrationProvider,\n"
"        UserQueryProvider,\n"
"        CredentialInputUpdater,\n"
"        CredentialInputValidator,\n"
"        OnUserCache\n"
"{\n"
"    @PersistenceContext\n"
"    protected EntityManager em;\n"
msgstr ""
"@Stateful\n"
"@Local(EjbExampleUserStorageProvider.class)\n"
"public class EjbExampleUserStorageProvider implements UserStorageProvider,\n"
"        UserLookupProvider,\n"
"        UserRegistrationProvider,\n"
"        UserQueryProvider,\n"
"        CredentialInputUpdater,\n"
"        CredentialInputValidator,\n"
"        OnUserCache\n"
"{\n"
"    @PersistenceContext\n"
"    protected EntityManager em;\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    protected ComponentModel model;\n"
"    protected KeycloakSession session;\n"
msgstr ""
"    protected ComponentModel model;\n"
"    protected KeycloakSession session;\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    public void setModel(ComponentModel model) {\n"
"        this.model = model;\n"
"    }\n"
msgstr ""
"    public void setModel(ComponentModel model) {\n"
"        this.model = model;\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    public void setSession(KeycloakSession session) {\n"
"        this.session = session;\n"
"    }\n"
msgstr ""
"    public void setSession(KeycloakSession session) {\n"
"        this.session = session;\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Remove\n"
"    @Override\n"
"    public void close() {\n"
"    }\n"
"...\n"
"}\n"
msgstr ""
"    @Remove\n"
"    @Override\n"
"    public void close() {\n"
"    }\n"
"...\n"
"}\n"

#. type: Plain text
msgid ""
"You have to define the `@Local` annotation and specify your provider class "
"there.  If you don't do this, EJB will not proxy the provider instance "
"correctly and your provider won't work."
msgstr ""
"ここで、 `@Local` "
"アノテーションを定義し、プロバイダー・クラスを指定する必要があります。これを行わないと、EJBはプロバイダー・インスタンスを正しくプロキシーせず、プロバイダーは機能しません。"

#. type: Plain text
msgid ""
"You must put the `@Remove` annotation on the `close()` method of your "
"provider.  If you don't, the stateful bean will never be cleaned up and you "
"may eventually see error messages."
msgstr ""
"`@Remove` アノテーションをプロバイダーの `close()` "
"メソッドに付与する必要があります。これを行わないと、ステートフルbeanは決してクリーンアップされず、最終的にエラーメッセージが表示されることになります。"

#. type: Plain text
msgid ""
"Implementations of `ProviderFactory` are required to be plain java objects."
"  Your factory class would perform a JNDI lookup of the Stateful EJB in its "
"`create()` method."
msgstr ""
"`ProviderFactory` の実装はプレーンなJavaオブジェクトである必要があります。ファクトリー・クラスは、その `create()` "
"メソッド内でステートフルEJBのJNDIルックアップを実行します。"

#. type: delimited block -
#, no-wrap
msgid ""
"public class EjbExampleUserStorageProviderFactory\n"
"        implements UserStorageProviderFactory<EjbExampleUserStorageProvider> {\n"
msgstr ""
"public class EjbExampleUserStorageProviderFactory\n"
"        implements UserStorageProviderFactory<EjbExampleUserStorageProvider> {\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public EjbExampleUserStorageProvider create(KeycloakSession session, ComponentModel model) {\n"
"        try {\n"
"            InitialContext ctx = new InitialContext();\n"
"            EjbExampleUserStorageProvider provider = (EjbExampleUserStorageProvider)ctx.lookup(\n"
"                     \"java:global/user-storage-jpa-example/\" + EjbExampleUserStorageProvider.class.getSimpleName());\n"
"            provider.setModel(model);\n"
"            provider.setSession(session);\n"
"            return provider;\n"
"        } catch (Exception e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public EjbExampleUserStorageProvider create(KeycloakSession session, ComponentModel model) {\n"
"        try {\n"
"            InitialContext ctx = new InitialContext();\n"
"            EjbExampleUserStorageProvider provider = (EjbExampleUserStorageProvider)ctx.lookup(\n"
"                     \"java:global/user-storage-jpa-example/\" + EjbExampleUserStorageProvider.class.getSimpleName());\n"
"            provider.setModel(model);\n"
"            provider.setSession(session);\n"
"            return provider;\n"
"        } catch (Exception e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }\n"

#. type: Attribute :developerguide_jsproviders_name:
#, no-wrap
msgid "JavaScript Providers"
msgstr "JavaScriptプロバイダー"

#. type: Plain text
msgid ""
"{project_name} has the ability to execute scripts during runtime in order to"
" allow administrators to customize specific functionalities:"
msgstr "{project_name}には、管理者が特定の機能をカスタマイズできるようにするために、起動中にスクリプトを実行する機能があります。"

#. type: Plain text
msgid "JavaScript Policy"
msgstr "JavaScriptポリシー"

#. type: Plain text
msgid "OpenID Connect Protocol Mapper"
msgstr "OpenID Connectプロトコル・マッパー"

#. type: Plain text
msgid ""
"Authentication scripts must provide at least one of the following functions:"
" `authenticate(..)`, which is called from "
"`Authenticator#authenticate(AuthenticationFlowContext)` `action(..)`, which "
"is called from `Authenticator#action(AuthenticationFlowContext)`"
msgstr ""
"認証スクリプトは、少なくとも以下の関数のうちの1つを提供しなければなりません。 "
"`Authenticator#authenticate(AuthenticationFlowContext)` から呼び出された "
"`authenticate(..)` 。 `Authenticator#action(AuthenticationFlowContext)` "
"から呼び出された `action(..)` 。"

#. type: Plain text
msgid ""
"Custom `Authenticator` should at least provide the `authenticate(..)` "
"function.  You can use the `javax.script.Bindings` script within the code."
msgstr ""
"カスタム `Authenticator` は、少なくとも `authenticate(..)` 関数を提供する必要があります。コード内で "
"`javax.script.Bindings` スクリプトを使用できます。"

#. type: Labeled list
#, no-wrap
msgid "`script`"
msgstr "`script`"

#. type: Plain text
msgid "the `ScriptModel` to access script metadata"
msgstr "スクリプトのメタデータにアクセスするための `ScriptModel` "

#. type: Labeled list
#, no-wrap
msgid "`realm`"
msgstr "`realm`"

#. type: Plain text
msgid "the `RealmModel`"
msgstr "`RealmModel`"

#. type: Labeled list
#, no-wrap
msgid "`user`"
msgstr "`user`"

#. type: Plain text
msgid "the current `UserModel`"
msgstr "現在の `UserModel`"

#. type: Labeled list
#, no-wrap
msgid "`session`"
msgstr "`session`"

#. type: Plain text
msgid "the active `KeycloakSession`"
msgstr "アクティブな `KeycloakSession`"

#. type: Labeled list
#, no-wrap
msgid "`authenticationSession`"
msgstr "`authenticationSession`"

#. type: Plain text
msgid "the current `AuthenticationSessionModel`"
msgstr "現在の `AuthenticationSessionModel`"

#. type: Labeled list
#, no-wrap
msgid "`httpRequest`"
msgstr "`httpRequest`"

#. type: Plain text
msgid "the current `org.jboss.resteasy.spi.HttpRequest`"
msgstr "現在の `org.jboss.resteasy.spi.HttpRequest`"

#. type: Labeled list
#, no-wrap
msgid "`LOG`"
msgstr "`LOG`"

#. type: Plain text
msgid "a `org.jboss.logging.Logger` scoped to `ScriptBasedAuthenticator`"
msgstr "`ScriptBasedAuthenticator` にスコープされた `org.jboss.logging.Logger`"

#. type: Plain text
msgid ""
"You can extract additional context information from the `context` argument "
"passed to the `authenticate(context)` `action(context)` function."
msgstr ""
"`authenticate(context)` や `action(context)` 関数に渡された `context` "
"引数から追加のコンテキスト情報を抽出できます。"

#. type: delimited block -
#, no-wrap
msgid ""
"AuthenticationFlowError = "
"Java.type(\"org.keycloak.authentication.AuthenticationFlowError\");\n"
msgstr ""
"AuthenticationFlowError = "
"Java.type(\"org.keycloak.authentication.AuthenticationFlowError\");\n"

#. type: delimited block -
#, no-wrap
msgid "function authenticate(context) {\n"
msgstr "function authenticate(context) {\n"

#. type: delimited block -
#, no-wrap
msgid "  LOG.info(script.name + \" --> trace auth for: \" + user.username);\n"
msgstr "  LOG.info(script.name + \" --> trace auth for: \" + user.username);\n"

#. type: delimited block -
#, no-wrap
msgid ""
"  if (   user.username === \"tester\"\n"
"      && user.getAttribute(\"someAttribute\")\n"
"      && user.getAttribute(\"someAttribute\").contains(\"someValue\")) {\n"
msgstr ""
"  if (   user.username === \"tester\"\n"
"      && user.getAttribute(\"someAttribute\")\n"
"      && user.getAttribute(\"someAttribute\").contains(\"someValue\")) {\n"

#. type: delimited block -
#, no-wrap
msgid ""
"      context.failure(AuthenticationFlowError.INVALID_USER);\n"
"      return;\n"
"  }\n"
msgstr ""
"      context.failure(AuthenticationFlowError.INVALID_USER);\n"
"      return;\n"
"  }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"  context.success();\n"
"}\n"
msgstr ""
"  context.success();\n"
"}\n"

#. type: Title ====
#, no-wrap
msgid "Create a JAR with the scripts to deploy"
msgstr "デプロイするスクリプトを含むJARの作成"

#. type: Plain text
msgid "JAR files are regular ZIP files with a `.jar` extension."
msgstr "JARファイルは、拡張子が `.jar` の通常のZIPファイルです。"

#. type: Plain text
msgid ""
"In order to make your scripts available to {project_name} you need to deploy"
" them to the server. For that, you should create a `JAR` file with the "
"following structure:"
msgstr ""
"スクリプトを{project_name}で使用できるようにするには、それらをサーバーにデプロイする必要があります。そのためには、次の構造を持つ "
"`JAR` ファイルを作成する必要があります。"

#. type: delimited block -
#, no-wrap
msgid "META-INF/keycloak-scripts.json\n"
msgstr "META-INF/keycloak-scripts.json\n"

#. type: delimited block -
#, no-wrap
msgid ""
"my-script-authenticator.js\n"
"my-script-policy.js\n"
"my-script-mapper.js\n"
msgstr ""
"my-script-authenticator.js\n"
"my-script-policy.js\n"
"my-script-mapper.js\n"

#. type: Plain text
msgid ""
"The `META-INF/keycloak-scripts.json` is a file descriptor that provides "
"metadata information about the scripts you want to deploy. It is a JSON file"
" with the following structure:"
msgstr ""
"`META-INF/keycloak-scripts.json` "
"は、デプロイするスクリプトに関するメタデータ情報を提供するファイル・ディスクリプターです。次の構造を持つJSONファイルです。"

#. type: Code block
#, no-wrap
msgid ""
"{\n"
"    \"authenticators\": [\n"
"        {\n"
"            \"name\": \"My Authenticator\",\n"
"            \"fileName\": \"my-script-authenticator.js\",\n"
"            \"description\": \"My Authenticator from a JS file\"\n"
"        }\n"
"    ],\n"
"    \"policies\": [\n"
"        {\n"
"            \"name\": \"My Policy\",\n"
"            \"fileName\": \"my-script-policy.js\",\n"
"            \"description\": \"My Policy from a JS file\"\n"
"        }\n"
"    ],\n"
"    \"mappers\": [\n"
"        {\n"
"            \"name\": \"My Mapper\",\n"
"            \"fileName\": \"my-script-mapper.js\",\n"
"            \"description\": \"My Mapper from a JS file\"\n"
"        }\n"
"    ]\n"
"}\n"
msgstr ""
"{\n"
"    \"authenticators\": [\n"
"        {\n"
"            \"name\": \"My Authenticator\",\n"
"            \"fileName\": \"my-script-authenticator.js\",\n"
"            \"description\": \"My Authenticator from a JS file\"\n"
"        }\n"
"    ],\n"
"    \"policies\": [\n"
"        {\n"
"            \"name\": \"My Policy\",\n"
"            \"fileName\": \"my-script-policy.js\",\n"
"            \"description\": \"My Policy from a JS file\"\n"
"        }\n"
"    ],\n"
"    \"mappers\": [\n"
"        {\n"
"            \"name\": \"My Mapper\",\n"
"            \"fileName\": \"my-script-mapper.js\",\n"
"            \"description\": \"My Mapper from a JS file\"\n"
"        }\n"
"    ]\n"
"}\n"

#. type: Plain text
msgid ""
"This file should reference the different types of script providers that you "
"want to deploy:"
msgstr "このファイルは、デプロイするさまざまなタイプのスクリプト・プロバイダーを参照する必要があります。"

#. type: Plain text
msgid "`authenticators`"
msgstr "`authenticators`"

#. type: Plain text
msgid ""
"For OpenID Connect Script Authenticators. You can have one or multiple "
"authenticators in the same JAR file"
msgstr ""
"OpenID Connectスクリプト・オーセンティケーター用です。同じJARファイルに1つ以上のオーセンティケーターを含めることができます。"

#. type: Plain text
msgid "`policies`"
msgstr "`policies`"

#. type: Plain text
msgid ""
"For JavaScript Policies when using {project_name} Authorization Services. "
"You can have one or multiple policies in the same JAR file"
msgstr ""
"{project_name}認可サービスを使用する場合のJavaScriptポリシー用です。同じJARファイルに1つ以上のポリシーを含めることができます。"

#. type: Plain text
msgid "`mappers`"
msgstr "`mappers`"

#. type: Plain text
msgid ""
"For OpenID Connect Script Protocol Mappers. You can have one or multiple "
"mappers in the same JAR file"
msgstr "OpenID Connectスクリプト・プロトコル・マッパー用です。同じJARファイルに1つ以上のマッパーを含めることができます。"

#. type: Plain text
msgid ""
"For each script file in your `JAR` file you must have a corresponding entry "
"in `META-INF/keycloak-scripts.json` that maps your scripts files to a "
"specific provider type. For that you should provide the following properties"
" for each entry:"
msgstr ""
"`JAR` ファイル内の各スクリプト・ファイルに対して、スクリプト・ファイルを特定のプロバイダー・タイプにマッピングする `META-"
"INF/keycloak-scripts.json` "
"に対応するエントリーが必要です。そのためには、各エントリーに次のプロパティーを提供する必要があります。"

#. type: Plain text
msgid "`name`"
msgstr "`name`"

#. type: Plain text
msgid ""
"A friendly name that will be used to show the scripts through the "
"{project_name} Administration Console. If not provided, the name of the "
"script file will be used instead"
msgstr ""
"{project_name}管理コンソールでスクリプトを表示するために使用されるわかりやすい名前です。指定しない場合は、代わりにスクリプト・ファイルの名前が使用されます。"

#. type: Plain text
msgid "`description`"
msgstr "`description`"

#. type: Plain text
msgid "An optional text that better describes the intend of the script file"
msgstr "スクリプト・ファイルの意図をより詳しく説明するオプションのテキストです。"

#. type: Plain text
msgid "`fileName`"
msgstr "`fileName`"

#. type: Plain text
msgid ""
"The name of the script file. This property is *mandatory* and should map to "
"a file within the JAR."
msgstr "スクリプト・ファイルの名前です。このプロパティーは *必須* であり、JAR内のファイルにマップする必要があります。"

#. type: Title ====
#, no-wrap
msgid "Deploy the Script JAR"
msgstr "スクリプトJARのデプロイ"

#. type: Plain text
msgid ""
"Once you have a JAR file with a descriptor and the scripts you want to "
"deploy, you just need to copy the JAR to the {project_name} "
"`standalone/deployments/` directory."
msgstr ""
"ディスクリプターとデプロイしたいスクリプトを含むJARファイルを作成したら、JARを{project_name}の "
"`standalone/deployments/` ディレクトリーにコピーするだけです。"

#. type: Title ====
#, no-wrap
msgid "Using {project_name} Administration Console to upload scripts"
msgstr "{project_name}管理コンソールを使用したスクリプトのアップロード"

#. type: Plain text
msgid ""
"Ability to upload scripts through the admin console is deprecated and will "
"be removed in a future version of {project_name}"
msgstr ""
"管理コンソールを介してスクリプトをアップロードする機能は廃止されており、{project_name}の将来のバージョンでは削除される予定です。"

#. type: Plain text
msgid ""
"Administrators cannot upload scripts to the server. This behavior prevents "
"potential harm to the system in case malicious scripts are accidentally "
"executed. Administrators should always deploy scripts directly to the server"
" using a JAR file to prevent attacks when you run scripts at runtime."
msgstr ""
"管理者はスクリプトをサーバーにアップロードできません。この動作により、悪意のあるスクリプトが誤って実行された場合にシステムに被害が及ぶ可能性を防ぎます。管理者は、スクリプトを実行する際の攻撃を防ぐために、常にJARファイルを使用してサーバーにスクリプトを直接デプロイする必要があります。"

#. type: Plain text
msgid ""
"Ability to upload scripts can be explicitly enabled. This should be used "
"with great care and plans should be created to deploy all scripts directly "
"to the server as soon as possible."
msgstr ""
"スクリプトをアップロードする機能を明示的に有効にすることができます。これは細心の注意を払って使用し、すべてのスクリプトをできるだけ早くサーバーに直接デプロイする計画を作成する必要があります。"

#. type: Plain text
msgid ""
"For more details about how to enable the `upload_scripts` feature. Please, "
"take a look at the "
"link:{installguide_profile_link}[{installguide_profile_name}]."
msgstr ""
"`upload_scripts` "
"機能を有効にする方法の詳細については、link:{installguide_profile_link}[{installguide_profile_name}]を参照してください。"

#. type: Title ===
#, no-wrap
msgid "Available SPIs"
msgstr "利用可能なSPI"

#. type: Plain text
msgid ""
"If you want to see list of all available SPIs at runtime, you can check "
"`Server Info` page in admin console as described in "
"<<_providers_admin_console,Admin Console>> section."
msgstr ""
"利用可能なすべてのSPIのリストを実行時に確認する必要がある場合は、<<_providers_admin_console, "
"管理コンソール>>セクションでの説明通りに、管理コンソール内の `Server Info` ページを確認します。"
