# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Nomura Research Institute, Ltd.
# This file is distributed under the same license as the keycloak-documentation-i18n package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# n.watanabe <nwatanabe.ase@gmail.com>, 2018
# Tsukasa Amano <t.amano@pro-japan.co.jp>, 2018
# Hiroyuki Wada <wadahiro@gmail.com>, 2019
# Kohei Tamura <ktamura.biz.80@gmail.com>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n\n"
"Last-Translator: Kohei Tamura <ktamura.biz.80@gmail.com>, 2019\n"
"Language-Team: Japanese (Japan) (https://www.transifex.com/openstandia/teams/79437/ja_JP/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja_JP\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Title ===
#, no-wrap
msgid "Migrating from an Earlier User Federation SPI"
msgstr "以前のユーザー・フェデレーションSPIからの移行"

#. type: Plain text
#, no-wrap
msgid ""
"This chapter is only applicable if you have implemented a provider using the earlier (and now removed)\n"
"       User Federation SPI.\n"
msgstr "この章は、以前の（および現在は削除された）ユーザー・フェデレーションSPIを使用してプロバイダーを実装した場合にのみ適用されます。\n"

#. type: Plain text
msgid ""
"In Keycloak version 2.4.0 and earlier there was a User Federation SPI. Red "
"Hat Single Sign-On version 7.0, although unsupported, had this earlier SPI "
"available as well. This earlier User Federation SPI has been removed from "
"Keycloak version 2.5.0 and Red Hat Single Sign-On version 7.1.  However, if "
"you have written a provider with this earlier SPI, this chapter discusses "
"some strategies you can use to port it."
msgstr ""
"Keycloakバージョン2.4.0以前では、 ユーザー・フェデレーション SPIがありました。Red Hat Single Sign-"
"Onバージョン7.0は、サポートされていませんが、以前のSPIが利用可能でした。この以前のユーザー・フェデレーションSPIは、Keycloakバージョン2.5.0およびRed"
" Hat Single Sign-"
"Onバージョン7.1から削除されました。しかし、この章では、このSPIを使用してプロバイダーを作成した場合の、SPIを移植するためのいくつかの方法について説明します。"

#. type: Title ====
#, no-wrap
msgid "Import vs. Non-Import"
msgstr "インポート vs. 非インポート"

#. type: Plain text
msgid ""
"The earlier User Federation SPI required you to create a local copy of a "
"user in the {project_name}'s database and import information from your "
"external store to the local copy. However, this is no longer a requirement. "
"You can still port your earlier provider as-is, but you should consider "
"whether a non-import strategy might be a better approach."
msgstr ""
"以前のユーザー・フェデレーションSPIでは、{project_name}のデータベース内でユーザーのローカルコピーを作成し、外部ストアからの情報をローカルコピーにインポートする必要がありました。しかし、これはもう要件ではなくなりました。以前のプロバイダーをそのまま移植することもできますが、インポートしない方法の方がより良いアプローチになるかを検討する必要があります。"

#. type: Plain text
msgid "Advantages of the import strategy:"
msgstr "インポートによる方法の利点は、以下のとおりです。"

#. type: Plain text
msgid ""
"{project_name} basically becomes a persistence user cache for your external "
"store. Once the user is imported you'll no longer hit the external store, "
"thus taking load off of it."
msgstr ""
"{project_name}は、基本的に外部ストアの永続ユーザーキャッシュになります。ユーザーがインポートされると、外部ストアにアクセスしなくなり、その負荷が無くなります。"

#. type: Plain text
msgid ""
"If you are moving to {project_name} as your official user store and "
"deprecating the earlier external store, you can slowly migrate applications "
"to use {project_name}. When all applications have been migrated, unlink the "
"imported user, and retire the earlier legacy external store."
msgstr ""
"{project_name}に移行して公式ユーザーストアとし、以前の外部ストアを廃止する場合、アプリケーションを徐々に移行して{project_name}を使用することができます。すべてのアプリケーションが移行されると、インポートされたユーザーのリンクを解除し、以前のレガシー外部ストアを廃止します。"

#. type: Plain text
msgid ""
"There are some obvious disadvantages though to using an import strategy:"
msgstr "インポートによる方法の使用には明らかな欠点がいくつかあります。"

#. type: Plain text
msgid ""
"Looking up a user for the first time will require multiple updates to "
"{project_name} database. This can be a big performance loss under load and "
"put a lot of strain on the {project_name} database. The user federated "
"storage approach will only store extra data as needed and might never be "
"used depending on the capabilities of your external store."
msgstr ""
"初回のユーザーの検索では、{project_name}のデータベースを複数回更新する必要があります。これは大きなパフォーマンス低下を招き、{project_name}のデータベースに多くの負担をかけることになります。ユーザー・フェデレーティッド・ストレージのアプローチでは、必要に応じて追加のデータのみが保存されるだけであり、外部ストアの機能によってはまったく使用されない可能性もあります。"

#. type: Plain text
msgid ""
"With the import approach, you have to keep local {project_name} storage and "
"external storage in sync. The User Storage SPI has capability interfaces "
"that you can implement to support synchronization, but this can quickly "
"become painful and messy."
msgstr ""
"インポートのアプローチでは、ローカルの{project_name}ストレージと外部ストレージを同期させておく必要があります。ユーザー・ストレージSPIには、同期をサポートできるために実装できるケーパビリティー・インターフェイスがありますが、これはすぐにやっかいで面倒なものになります。"

#. type: Title ====
#, no-wrap
msgid "UserFederationProvider vs. UserStorageProvider"
msgstr "UserFederationProvider vs. UserStorageProvider"

#. type: Plain text
msgid ""
"The first thing to notice is that `UserFederationProvider` was a complete "
"interface. You implemented every method in this interface. However, "
"`UserStorageProvider` has instead broken up this interface into multiple "
"capability interfaces that you implement as needed."
msgstr ""
"最初に気付くべきは、 `UserFederationProvider` "
"が完成されたインターフェイスであったことです。このインターフェイスにはすべてのメソッドが実装されました。ただし、 "
"`UserStorageProvider` "
"では、代わりにこのインターフェイスを、必要に応じて実装可能な複数のケーパビリティー・インターフェイスに分割しています。"

#. type: Plain text
msgid ""
"`UserFederationProvider.getUserByUsername()` and `getUserByEmail()` have "
"exact equivalents in the new SPI. The difference between the two is how you "
"import. If you are going to continue with an import strategy, you no longer "
"call `KeycloakSession.userStorage().addUser()` to create the user locally. "
"Instead you call `KeycloakSession.userLocalStorage().addUser()`.  The "
"`userStorage()` method no longer exists."
msgstr ""
"`UserFederationProvider.getUserByUsername()` と `getUserByEmail()` "
"は、新しいSPIに完全に同等のものを持ちます。この両者の違いはインポート方法にあります。インポート・ストラテジーを引き続き使用している場合、ユーザーをローカルで作成するために"
" `KeycloakSession.userStorage().addUser()` を呼び出す必要はありません。その代わりに、 "
"`KeycloakSession.userLocalStorage().addUser()` を呼び出します。 `userStorage()` "
"メソッドは存在しません。"

#. type: Plain text
msgid ""
"The `UserFederationProvider.validateAndProxy()` method has been moved to an "
"optional capability interface, `ImportedUserValidation`.  You want to "
"implement this interface if you are porting your earlier provider as-is.  "
"Also note that in the earlier SPI, this method was called every time the "
"user was accessed, even if the local user is in the cache.  In the later "
"SPI, this method is only called when the local user is loaded from local "
"storage. If the local user is cached, then the "
"`ImportedUserValidation.validate()` method is not called at all."
msgstr ""
"`UserFederationProvider.validateAndProxy()` メソッドは、オプションのケーパビリティー・インターフェイス、 "
"`ImportedUserValidation` "
"に移動されました。以前のプロバイダーをそのまま移植する場合は、このインターフェイスを実装します。また、以前のSPIでは、ローカルユーザーがキャッシュ内にあっても、ユーザーがアクセスされるたびにこのメソッドが呼び出されました。新しいSPIでは、このメソッドはローカルユーザーがローカル・ストレージからロードされたときにのみ呼び出されます。ローカルユーザーがキャッシュされている場合、"
" `ImportedUserValidation.validate()` メソッドはまったく呼び出されません。"

#. type: Plain text
msgid ""
"The `UserFederationProvider.isValid()` method no longer exists in the later "
"SPI."
msgstr "`UserFederationProvider.isValid()` メソッドは、新しいSPIには存在しません。"

#. type: Plain text
msgid ""
"The `UserFederationProvider` methods `synchronizeRegistrations()`, "
"`registerUser()`, and `removeUser()` have been moved to the "
"`UserRegistrationProvider` capability interface. This new interface is "
"optional to implement so if your provider does not support creating and "
"removing users, you don't have to implement it. If your earlier provider had"
" switch to toggle support for registering new users, this is supported in "
"the new SPI, returning `null` from `UserRegistrationProvider.addUser()` if "
"the provider doesn't support adding users."
msgstr ""
"`UserFederationProvider` のメソッド `synchronizeRegistrations()` 、 "
"`registerUser()` 、 `removeUser()` は `UserRegistrationProvider` "
"のケーパビリティー・インターフェイスに移動されました。この新しいインターフェイスは実装するためにオプションです。プロバイダーがユーザーの作成と削除をサポートしていない場合は、実装する必要はありません。以前のプロバイダーが新しいユーザーの登録をサポートするように切り替えた場合、新しいSPIではこれがサポートされ、プロバイダーがユーザーの追加をサポートしていない場合は、"
" `UserRegistrationProvider.addUser()` から `null` が返されます。"

#. type: Plain text
msgid ""
"The earlier `UserFederationProvider` methods centered around credentials are"
" now encapsulated in the `CredentialInputValidator` and "
"`CredentialInputUpdater` interfaces, which are also optional to implement "
"depending on if you support validating or updating credentials.  Credential "
"management used to exist in `UserModel` methods. These also have been moved "
"to the `CredentialInputValidator` and `CredentialInputUpdater` interfaces.  "
"One thing to note that if you do not implement the `CredentialInputUpdater` "
"interface, then any credentials provided by your provider can be overridden "
"locally in {project_name} storage. So if you want your credentials to be "
"read-only, implement the `CredentialInputUpdater.updateCredential()` method "
"and return a `ReadOnlyException`."
msgstr ""
"クレデンシャルを中心とした以前の `UserFederationProvider` メソッドは `CredentialInputValidator` と"
" `CredentialInputUpdater` "
"インターフェイスにカプセル化されました。この実装は任意で、クレデンシャルの検証や更新をサポートするかどうかによって異なります。クレデンシャル管理は "
"`UserModel` メソッドに存在しましたが、これらも `CredentialInputValidator` と "
"`CredentialInputUpdater` インターフェイスに移行されました。 `CredentialInputUpdater` "
"インターフェイスを実装しないと、プロバイダーが提供するクレデンシャルは{project_name}ストレージ内でローカルにオーバーライドされる可能性があることに注意してください。したがって、クレデンシャルを読み取り専用にする場合は、"
" `CredentialInputUpdater.updateCredential()` メソッドを実装し、 `ReadOnlyException` "
"を返します。"

#. type: Plain text
msgid ""
"The `UserFederationProvider` query methods such as `searchByAttributes()` "
"and `getGroupMembers()` are now encapsulated in an optional interface "
"`UserQueryProvider`. If you do not implement this interface, then users will"
" not be viewable in the admin console.  You'll still be able to login "
"though."
msgstr ""
"`searchByAttributes()` や `getGroupMembers()` のような `UserFederationProvider` "
"クエリーメソッドは、オプションのインターフェイス `UserQueryProvider` "
"にカプセル化されました。このインターフェイスを実装しないと、管理コンソールでユーザーを表示できなくなります。なお、ログインすることはできます。"

#. type: Title ====
#, no-wrap
msgid "UserFederationProviderFactory vs. UserStorageProviderFactory"
msgstr "UserFederationProviderFactory vs. UserStorageProviderFactory"

#. type: Plain text
msgid ""
"The synchronization methods in the earlier SPI are now encapsulated within "
"an optional `ImportSynchronization` interface.  If you have implemented "
"synchronization logic, then have your new `UserStorageProviderFactory` "
"implement the `ImportSynchronization` interface."
msgstr ""
"以前のSPIの同期メソッドは、現在、オプションの `ImportSynchronization` "
"インターフェイスにカプセル化されています。同期ロジックを実装している場合は、新しい `UserStorageProviderFactory` に "
"`ImportSynchronization` インターフェイスを実装してください。"

#. type: Title ====
#, no-wrap
msgid "Upgrading to a New Model"
msgstr "新しいモデルへのアップグレード"

#. type: Plain text
msgid ""
"The User Storage SPI instances are stored in a different set of relational "
"tables. {project_name} automatically runs a migration script. If any earlier"
" User Federation providers are deployed for a realm, they are converted to "
"the later storage model as is, including the `id` of the data. This "
"migration will only happen if a User Storage provider exists with the same "
"provider ID (i.e., \"ldap\", \"kerberos\") as the earlier User Federation "
"provider."
msgstr ""
"ユーザーストレージSPIインスタンスは、異なる一連のリレーショナル・テーブルに格納されます。 "
"{project_name}は自動的に移行スクリプトを実行します。レルムに対して以前のユーザー・フェデレーション・プロバイダーがデプロイされている場合、データの"
" `ID` "
"を含め、それ以降のストレージモデルにそのまま変換されます。この移行は、以前のユーザー・フェデレーション・プロバイダーと同じプロバイダーID（\"ldap\"、\"kerberos\"など）を持つユーザー・ストレージ・プロバイダーが存在する場合にのみ発生します。"

#. type: Plain text
msgid "So, knowing this there are different approaches you can take."
msgstr "これを知ることにより、取ることができるさまざまなアプローチがあります。"

#. type: Plain text
msgid ""
"You can remove the earlier provider in your earlier {project_name} "
"deployment. This will remove the local linked copies of all users you "
"imported.  Then, when you upgrade {project_name}, just deploy and configure "
"your new provider for your realm."
msgstr ""
"以前の{project_name}のデプロイメントで、以前のプロバイダーを削除することができます。これにより、インポートした全ユーザーのローカルリンクされたコピーが削除されます。次に、{project_name}をアップグレードするときに、レルム用に新しいプロバイダーをデプロイして設定するだけです。"

#. type: Plain text
msgid ""
"The second option is to write your new provider making sure it has the same "
"provider ID: `UserStorageProviderFactory.getId()`.  Make sure this provider "
"is in the `deploy/` directory of the new {project_name} installation.  Boot "
"the server, and have the built-in migration script convert from the earlier "
"data model to the later data model. In this case all your earlier linked "
"imported users will work and be the same."
msgstr ""
"2つ目のオプションは、プロバイダーIDが同じであることを `UserStorageProviderFactory.getId()` "
"で確認する新しいプロバイダーを実装することです。このプロバイダーが新しい{project_name}インストールの `deploy/` "
"ディレクトリーにあることを確認してください。サーバーを起動し、組み込みの移行スクリプトで以前のデータモデルを新しいデータモデルに変換します。この場合、以前にリンクされたインポート済みユーザーは、正常に動作し、すべて同じになります。"

#. type: Plain text
msgid ""
"If you have decided to get rid of the import strategy and rewrite your User "
"Storage provider, we suggest that you remove the earlier provider before "
"upgrading {project_name}. This will remove linked local imported copies of "
"any user you imported."
msgstr ""
"インポート・ストラテジーを廃止してユーザー・ストレージ・プロバイダーを実装し直すことに決めた場合は、{project_name}をアップグレードする前に以前のプロバイダーを削除することをお勧めします。これにより、インポートされたすべてのユーザーのリンクされたローカル・インポート済みのコピーが削除されます。"
