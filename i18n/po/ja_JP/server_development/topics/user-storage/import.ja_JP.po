# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Nomura Research Institute, Ltd.
# This file is distributed under the same license as the keycloak-documentation-i18n package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n\n"
"Last-Translator: jic_m_mito <jic-m-mito@nri.co.jp>, 2018\n"
"Language-Team: Japanese (Japan) (https://www.transifex.com/openstandia/teams/79437/ja_JP/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja_JP\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Block title
#, no-wrap
msgid "PropertyFileUserStorageProvider"
msgstr "PropertyFileUserStorageProvider"

#. type: Plain text
msgid ""
"There are some obvious disadvantages though to using an import strategy:"
msgstr "インポート・ストラテジーの使用には、いずれにせよ、明らかな欠点がいくつかあります。"

#. type: Plain text
msgid ""
"With the import approach, you have to keep local keycloak storage and "
"external storage in sync. The User Storage SPI has capability interfaces "
"that you can implement to support synchronization, but this can quickly "
"become painful and messy."
msgstr ""
"インポートのアプローチでは、ローカルkeycloakストレージと外部ストレージを同期させておく必要があります。ユーザー・ストレージSPIには、実装させると同期をサポートできるようになる、インターフェイス機能がありますが、これはすぐにやっかいで面倒なものになります。"

#. type: Title ===
#, no-wrap
msgid "Import Implementation Strategy"
msgstr "インポート実装ストラテジー"

#. type: Plain text
msgid ""
"When implementing a user storage provider, there's another strategy you can "
"take. Instead of using user federated storage, you can create a user locally"
" in the {project_name} built-in user database and copy attributes from your "
"external store into this local copy. There are many advantages to this "
"approach."
msgstr ""
"ユーザー・ストレージ・プロバイダーを実装する場合、取得可能な別のストラテジーがもう1つあります。ユーザー連携されたストレージを使用せずに、{project_name}の組み込みユーザー・データベース内でユーザーをローカルで作成し、外部のストアの属性をこのローカルコピーにコピーすることができます。このアプローチにはたくさんの利点があります。"

#. type: Plain text
msgid ""
"{project_name} basically becomes a persistence user cache for your external "
"store. Once the user is imported you'll no longer hit the external store "
"thus taking load off of it."
msgstr ""
"{project_name}は基本的には外部のストアのための永続的なユーザー・キャッシュになります。ユーザーがインポートされると、外部ストアにヒットすることはなくなり、その不可が取り除かれます。"

#. type: Plain text
msgid ""
"If you are moving to {project_name} as your official user store and "
"deprecating the old external store, you can slowly migrate applications to "
"use {project_name}. When all applications have been migrated, unlink the "
"imported user, and retire the old legacy external store."
msgstr ""
"{project_name}に移行して公式のユーザー・ストアとし、従来の外部ストアは廃止する場合、アプリケーションを徐々に移行して{project_name}を使用することができます。すべてのアプリケーションが移行されると、インポートされたユーザーのリンクを解除し、従来のレガシー外部ストアを廃止します。"

#. type: Plain text
msgid ""
"Looking up a user for the first time will require multiple updates to "
"{project_name} database. This can be a big performance loss under load and "
"put a lot of strain on the {project_name} database. The user federated "
"storage approach will only store extra data as needed and may never be used "
"depending on the capabilities of your external store."
msgstr ""
"初めてユーザーを検索するには、{project_name}データベースを何回も更新する必要があります。これは、負荷となり大きなパフォーマンスロスとなり、{project_name}データベースに多くの負担をかけることになります。ユーザー連携されたストレージ・アプローチでは、必要以上のデータを保持し、外部ストアの機能に応じて使用されるということがありません。"

#. type: Plain text
msgid ""
"To implement the import strategy you simply check to see first if the user "
"has been imported locally. If so return the local user, if not create the "
"user locally and import data from the external store. You can also proxy the"
" local user so that most changes are automatically synchronized."
msgstr ""
"インポート・ストラテジーを実装するには、ユーザーがローカルでインポートされたかどうかを最初に確認するだけです。そうだった場合は、ローカル・ユーザーを返します。そうでなかった場合は、ユーザーをローカルで作成して外部ストアからデータをインポートします。また、ローカル・ユーザーをプロキシして、ほとんどの変更を自動的に同期させます。"

#. type: Plain text
msgid ""
"This will be a bit contrived, but we can extend our "
"`PropertyFileUserStorageProvider` to take this approach. We begin first by "
"modifying the `createAdapter()` method."
msgstr ""
"これは多少工夫を加えることになりますが、 `PropertyFileUserStorageProvider` "
"を拡張してこのアプローチをとることができます。まずは `createAdapter()` メソッドを変更することからはじめます。"

#. type: delimited block -
#, no-wrap
msgid ""
"    protected UserModel createAdapter(RealmModel realm, String username) {\n"
"        UserModel local = session.userLocalStorage().getUserByUsername(username, realm);\n"
"        if (local == null) {\n"
"            local = session.userLocalStorage().addUser(realm, username);\n"
"            local.setFederationLink(model.getId());\n"
"        }\n"
"        return new UserModelDelegate(local) {\n"
"            @Override\n"
"            public void setUsername(String username) {\n"
"                String pw = (String)properties.remove(username);\n"
"                if (pw != null) {\n"
"                    properties.put(username, pw);\n"
"                    save();\n"
"                }\n"
"                super.setUsername(username);\n"
"            }\n"
"        };\n"
"    }\n"
msgstr ""
"    protected UserModel createAdapter(RealmModel realm, String username) {\n"
"        UserModel local = session.userLocalStorage().getUserByUsername(username, realm);\n"
"        if (local == null) {\n"
"            local = session.userLocalStorage().addUser(realm, username);\n"
"            local.setFederationLink(model.getId());\n"
"        }\n"
"        return new UserModelDelegate(local) {\n"
"            @Override\n"
"            public void setUsername(String username) {\n"
"                String pw = (String)properties.remove(username);\n"
"                if (pw != null) {\n"
"                    properties.put(username, pw);\n"
"                    save();\n"
"                }\n"
"                super.setUsername(username);\n"
"            }\n"
"        };\n"
"    }\n"

#. type: Plain text
msgid ""
"In this method we call the `KeycloakSession.userLocalStorage()` method to "
"obtain a reference to local {project_name} user storage. We see if the user "
"is stored locally, if not, we add it locally. Also note that we call "
"`UserModel.setFederationLink()` and pass in the ID of the `ComponentModel` "
"of our provider. This sets a link between the provider and the imported "
"user."
msgstr ""
"このメソッドでは `KeycloakSession.userLocalStorage()` "
"メソッドを呼び出し、ローカルの{project_name}ユーザー・ストレージの参照を取得します。ユーザーがローカルで格納されたかどうかを確認し、そうでなかった場合はローカルでそれを追加します。また、"
" `UserModel.setFederationLink()` を呼び出してプロバイダーの `ComponentModel` "
"のIDに渡すことも忘れないでください。これにより、プロバイダーとインポートされたユーザーの間でリンクが設定されます。"

#. type: Plain text
#, no-wrap
msgid ""
"When a user storage provider is removed, any user imported by it will also be removed.  This is one of the\n"
"      purposes of calling `UserModel.setFederationLink()`.\n"
msgstr ""
"ユーザー・ストレージ・プロバイダーが削除されると、それによりインポートされたユーザーもすべて削除されます。これは "
"`UserModel.setFederationLink()` と呼ばれる目的の1つです。\n"

#. type: Plain text
msgid ""
"Another thing to note is that if a local user is linked, your storage "
"provider will still be delegated to for methods that it implements from the "
"`CredentialInputValidator` and `CredentialInputUpdater` interfaces. "
"Returning `false` from a validation or update will just result in "
"{project_name} seeing if it can validate or update using local storage."
msgstr ""
"また、ローカルユーザーがリンクされている場合、ストレージ・プロバイダーは `CredentialInputValidator` インタフェースと "
"`CredentialInputUpdater` インタフェースから実装されたメソッドのために委任されるという点にも注意してください。 `false` "
"を検証または更新から返すと、{project_name}では、ローカルストレージを使用して検証または更新できるかどうかが確認されます。"

#. type: Plain text
msgid ""
"Also notice that we are proxying the local user using the "
"`org.keycloak.models.utils.UserModelDelegate' class.  This class is an "
"implementation of `UserModel`. Every method just delegates to the "
"`UserModel` it was instantiated with.  We override the `setUsername()` "
"method of this delegate class to synchronize automatically with the property"
" file.  For your providers, you can use this to _intercept_ other methods on"
" the local `UserModel` to perform synchronization with your external store."
"  For example, get methods could make sure that the local store is in sync. "
"Set methods keep the external store in sync with the local one."
msgstr ""
"また、 `org.keycloak.models.utils.UserModelDelegate' "
"クラスを使用するローカルユーザーをプロキシしている点にも注意してください。このクラスは `UserModel` "
"の実装です。メソッドはすべて、インスタンス化された `UserModel` に委譲します。この委譲クラスの `setUsername()` "
"メソッドを上書きし、自動的にプロパティーファイルと同期させます。プロバイダーのために、これを使用してローカルの `UserModel` の他のメソッドを"
" _intercept_ "
"して、外部ストアと同期させることができます。たとえば、getメソッドにより、ローカルストアが同期していることを確認することができます。Setメソッドにより、外部ストアをローカルストアと同期し続けることができます。"

#. type: Plain text
#, no-wrap
msgid ""
"If your provider is implementing the `UserRegistrationProvider` interface, your `removeUser()` method does not\n"
"      need to remove the user from local storage.  The runtime will automatically perform this operation.  Also\n"
"      note that `removeUser()` will be invoked before it is removed from local storage.\n"
msgstr ""
"プロバイダーにより `UserRegistrationProvider` インターフェイスが実装されている場合、 `removeUser()` "
"メソッドではローカル・ストレージからユーザーを削除する必要はありません。ランタイムによりこの動作は自動的に実行されます。また、 "
"`removeUser()` はローカルストレージから削除される前に呼び出される点に注意してください。\n"

#. type: Title ====
#, no-wrap
msgid "ImportedUserValidation Interface"
msgstr "ImportedUserValidationインターフェイス"

#. type: Plain text
msgid ""
"If you remember earlier in this chapter, we discussed how querying for a "
"user worked.  Local storage is queried first, if the user is found there, "
"then the query ends.  This is a problem for our above implementation as we "
"want to proxy the local `UserModel` so that we can keep usernames in sync.  "
"The User Storage SPI has a callback for whenever a linked local user is "
"loaded from the local database."
msgstr ""
"この章の前半で、ユーザーのためのクエリーの機能について説明しました。ローカルストレージが最初にクエリーされ、そこでユーザーが見つけられた場合、クエリーは終了します。これは上記の実装では問題になります。なぜなら、ユーザー名を同期させてローカルの"
" `UserModel` "
"をプロキシする必要があるからです。ユーザー・ストレージSPIでは、リンクされたローカル・ユーザーがローカル・データベースから読み込まれる度にコールバックがあります。"

#. type: delimited block -
#, no-wrap
msgid ""
"package org.keycloak.storage.user;\n"
"public interface ImportedUserValidation {\n"
"    /**\n"
"     * If this method returns null, then the user in local storage will be removed\n"
"     *\n"
"     * @param realm\n"
"     * @param user\n"
"     * @return null if user no longer valid\n"
"     */\n"
"    UserModel validate(RealmModel realm, UserModel user);\n"
"}\n"
msgstr ""
"package org.keycloak.storage.user;\n"
"public interface ImportedUserValidation {\n"
"    /**\n"
"     * If this method returns null, then the user in local storage will be removed\n"
"     *\n"
"     * @param realm\n"
"     * @param user\n"
"     * @return null if user no longer valid\n"
"     */\n"
"    UserModel validate(RealmModel realm, UserModel user);\n"
"}\n"

#. type: Plain text
msgid ""
"Whenever a linked local user is loaded, if the user storage provider class "
"implements this interface, then the `validate()` method is called. Here you "
"can proxy the local user passed in as a parameter and return it. That new "
"`UserModel` will be used. You can also optionally do a check to see if the "
"user still exists in the external store.  If `validate()` returns `null`, "
"then the local user will be removed from the database."
msgstr ""
"リンクされたローカル・ユーザーが読み込まれる度に、ユーザー・ストレージ・プロバイダー・クラスがこのインターフェイスを実装すると、 "
"`validate()` メソッドが呼び出されます。ここでは、パラメーターとして渡されたローカル・ユーザーをプロキシして返すことができます。その新しい "
"`UserModel` を使用します。また、ユーザーが外部ストアにまだあるかどうかを任意で確認することもできます。 `validate()` が "
"`null` を返すと、ローカル・ユーザーはデータベースから削除されます。"

#. type: Title ====
#, no-wrap
msgid "ImportSynchronization Interface"
msgstr "ImportSynchronizationインターフェイス"

#. type: Plain text
msgid ""
"With the import strategy you can see that it is possible for the local user "
"copy to get out of sync with external storage. For example, maybe a user has"
" been removed from the external store. The User Storage SPI has an "
"additional interface you can implement to deal with this, "
"`org.keycloak.storage.user.ImportSynchronization`:"
msgstr ""
"インポート戦略を使用すると、ローカルユーザーのコピーが外部ストレージと同期しない可能性があるということがわかります。たとえば、ユーザーが外部ストアから削除されている可能性があります。ユーザー・ストレージSPIには、"
" これに対処するために実装可能な追加のインターフェイス、 "
"`org.keycloak.storage.user.ImportSynchronization` があります。"

#. type: delimited block -
#, no-wrap
msgid "package org.keycloak.storage.user;\n"
msgstr "package org.keycloak.storage.user;\n"

#. type: delimited block -
#, no-wrap
msgid ""
"public interface ImportSynchronization {\n"
"    SynchronizationResult sync(KeycloakSessionFactory sessionFactory, String realmId, UserStorageProviderModel model);\n"
"    SynchronizationResult syncSince(Date lastSync, KeycloakSessionFactory sessionFactory, String realmId, UserStorageProviderModel model);\n"
"}\n"
msgstr ""
"public interface ImportSynchronization {\n"
"    SynchronizationResult sync(KeycloakSessionFactory sessionFactory, String realmId, UserStorageProviderModel model);\n"
"    SynchronizationResult syncSince(Date lastSync, KeycloakSessionFactory sessionFactory, String realmId, UserStorageProviderModel model);\n"
"}\n"

#. type: Plain text
msgid ""
"This interface is implemented by the provider factory. Once this interface "
"is implemented by the provider factory, the administration console "
"management page for the provider shows additional options. You can manually "
"force a synchronization by clicking a button. This invokes the "
"`ImportSynchronization.sync()` method. Also, additional configuration "
"options are displayed that allow you to automatically schedule a "
"synchronization. Automatic synchronizations invoke the `syncSince()` method."
msgstr ""
"このインターフェイスは、プロバイダー・ファクトリーによって実装されます。このインターフェイスがプロバイダー・ファクトリーによって実装されると、プロバイダーのための管理コンソール・マネジメントページに追加のオプションが表示されます。ボタンをクリックして、手動で同期させることができます。こうして、"
" `ImportSynchronization.sync()` "
"メソッドが呼び出されます。また、追加の設定オプションが表示され、自動的に同期実行が予定されます。自動同期によって、 `syncSince()` "
"メソッドが呼び出されます。"
