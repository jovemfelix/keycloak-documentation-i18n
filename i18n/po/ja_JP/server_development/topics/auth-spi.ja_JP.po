# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Nomura Research Institute, Ltd.
# This file is distributed under the same license as the keycloak-documentation-i18n package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n\n"
"Last-Translator: Kohei Tamura <ktamura.biz.80@gmail.com>, 2017\n"
"Language-Team: Japanese (Japan) (https://www.transifex.com/openstandia/teams/79437/ja_JP/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja_JP\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: delimited block -
#, no-wrap
msgid "    }\n"
msgstr "}\n"

#. type: Title ====
#, no-wrap
msgid "Packaging Classes and Deployment"
msgstr "クラスとデプロイのパッケージ"

#. type: Title ==
#, no-wrap
msgid "Authentication SPI"
msgstr "認証SPI"

#. type: Plain text
msgid ""
"Keycloak comes out of the box with a bunch of different authentication "
"mechanisms: kerberos, password, and otp.  These mechanisms may not meet all "
"of your requirements and you may want to plug in your own custom ones.  "
"Keycloak provides an authentication SPI that you can use to write new "
"plugins.  The admin console supports applying, ordering, and configuring "
"these new mechanisms."
msgstr ""
"Keycloakには、ケルベロス、パスワード、ワンタイムパスワードなどのさまざまな認証機構が多数すぐ使用できるように用意されています。これらの機構は、要件をすべて満たしているわけではなく、独自のカスタムバージョンにプラグインする必要があるかもしれません。Keycloakによって、新しいプラグインを書き起こすのに使用できる認証SPIが提供されます。管理コンソールによって、これらの新しい機構の適用、発注、設定はサポートされます。"

#. type: Plain text
msgid ""
"Keycloak also supports a simple registration form.  Different aspects of "
"this form can be enabled and disabled i.e.  Recaptcha support can be turned "
"off and on.  The same authentication SPI can be used to add another page to "
"the registration flow or reimplement it entirely.  There's also an "
"additional fine-grain SPI you can use to add specific validations and user "
"extensions to the built in registration form."
msgstr ""
"また、Keycloakでは簡単な登録フォームもサポートされます。このフォームのさまざまな側面を有効にしたり無効にしたりすることができます。例えば、ecaptchaのサポートを有効にしたり無効にしたりすることができます。同じ認証SPIを使用して、他のページを登録フローに追加したり、それを完全に再実装することができます。また、追加の細かいSPIもあり、それを使用してビルトインの登録フォームに特定の修正とユーザー拡張機能を追加することもできます。"

#. type: Plain text
msgid ""
"A required action in Keycloak is an action that a user has to perform after "
"he authenticates.  After the action is performed successfully, the user "
"doesn't have to perform the action again.  Keycloak comes with some built in"
" required actions like \"reset password\".  This action forces the user to "
"change their password after they have logged in.  You can write and plug in "
"your own required actions."
msgstr ""
"Keycloakにおける必須アクションとは、認証後にユーザーが実行する必要があるアクションのことです。アクションが実行された後、ユーザーは再度そのアクションを実行する必要はありません。Keycloakには、ビルトインの"
" \"reset password\" "
"のようなビルトインの必須アクションがいくつかあります。このアクションでは、ユーザーはログイン後にパスワードを変更する必要があります。必須アクションを書き起こしてプラグインすることができます。"

#. type: Title ===
#, no-wrap
msgid "Terms"
msgstr "用語"

#. type: Plain text
msgid ""
"To first learn about the Authentication SPI, let's go over some of the terms"
" used to describe it."
msgstr "まず、認証SPIを学ぶために、それを説明するための用語をいくつか確認していきましょう。"

#. type: Labeled list
#, no-wrap
msgid "Authentication Flow"
msgstr "認証フロー"

#. type: Plain text
msgid ""
"A flow is a container for all authentications that must happen during login "
"or registration.  If you go to the admin console authentication page, you "
"can view all the defined flows in the system and what authenticators they "
"are made up of.  Flows can contain other flows.  You can also bind a new "
"different flow for browser login, direct grant access, and registration."
msgstr ""
"フローは、ログインまたは登録中に発生する必要がある、すべての認証のためのコンテナです。管理コンソールの認証ページに移動すると、システム内で定義されたフローすべて、およびそれらがどんなオーセンティケーター・コードを作成したかが表示されます。フローには、他のフローを含めることができます。また、ブラウザー・ログイン、ダイレクト・グラント・アクセス、および登録用に、新しい異なるフローをバインドすることもできます。"

#. type: Labeled list
#, no-wrap
msgid "Authenticator"
msgstr "オーセンティケーター"

#. type: Plain text
msgid ""
"An authenticator is a pluggable component that hold the logic for performing"
" the authentication or action within a flow.  It is usually a singleton."
msgstr ""
"オーセンティケーターとは、フロー内で認証またはアクションを実行するためのロジックを保持する、プラグインが可能なコンポーネントです。これは通常シングルトンです。"

#. type: Labeled list
#, no-wrap
msgid "Execution"
msgstr "実行"

#. type: Plain text
msgid ""
"An execution is an object that binds the authenticator to the flow and the "
"authenticator to the configuration of the authenticator.  Flows contain "
"execution entries."
msgstr ""
"実行とは、オーセンティケーターを、フローにバインドしたり、オーセンティケーターの設定へバインドしたりするオブジェクトです。フローには、実行エントリが含まれます。"

#. type: Labeled list
#, no-wrap
msgid "Execution Requirement"
msgstr "実行の要件"

#. type: Plain text
msgid ""
"Each execution defines how an authenticator behaves in a flow.  The "
"requirement defines whether the authenticator is enabled, disabled, "
"optional, required, or an alternative.  An alternative requirement means "
"that the authentiactor is optional unless no other alternative authenticator"
" is successful in the flow.  For example, cookie authentication, kerberos, "
"and the set of all login forms are all alternative.  If one of those is "
"successful, none of the others are executed."
msgstr ""
"実行によって、それぞれフロー内でオーセンティケーターが行う方法が定義されます。要件によって、オーセンティケーターが有効か、無効か、任意か、必須か、または代替かが定義されます。代替としての要件は、フロー内で他の代替のオーセンティケーターも実行が成功しなければ、そのオーセンティケーターは任意であるということになります。例えば、Cookie認証、ケルベロス、およびログイン画面のセットは、すべて代替です。これらのうち1つが実行に成功した場合は、他はすべて実行されません。"

#. type: Labeled list
#, no-wrap
msgid "Authenticator Config"
msgstr "オーセンティケーターの設定"

#. type: Plain text
msgid ""
"This object defines the configuration for the Authenticator for a specific "
"execution within an authentication flow.  Each execution can have a "
"different config."
msgstr ""
"このオブジェクトによって、認証フロー内で特定の実行が行われるように、オーセンティケーターの設定が定義されます。各実行は、それぞれ異なる設定を持つことができます。"

#. type: Labeled list
#, no-wrap
msgid "Required Action"
msgstr "必須アクション"

#. type: Plain text
#, no-wrap
msgid ""
"After authentication completes, the user might have one or more one-time actions he must complete before he is allowed to login.\n"
"The user might be required to set up an OTP token generator or reset an expired password or even accept a Terms and Conditions document.         \n"
msgstr ""
"認証が完了した後、ログインが許可される前に、ユーザーが完了しなければならない1つまたは複数のワンタイム・アクションがあるかもしれません。ユーザーは、OTPトークン・ジェネレーターを設定するか、有効期限切れのパスワードをリセットするか、または諸条件に同意することが要求される可能性があります。\n"

#. type: Title ===
#, no-wrap
msgid "Algorithm Overview"
msgstr "アルゴニズムの概要"

#. type: Plain text
msgid ""
"Let's talk about how this all works for browser login.  Let's assume the "
"following flows, executions and sub flows."
msgstr "これがブラウザーへのログインでどのように機能するか説明します。以下のフロー、実行、サブフローを想定してみましょう。"

#. type: delimited block -
#, no-wrap
msgid ""
"Cookie - ALTERNATIVE\n"
"Kerberos - ALTERNATIVE\n"
"Forms Subflow - ALTERNATIVE\n"
"           Username/Password Form - REQUIRED\n"
"           OTP Password Form - OPTIONAL\n"
msgstr ""
"Cookie - ALTERNATIVE\n"
"Kerberos - ALTERNATIVE\n"
"Forms Subflow - ALTERNATIVE\n"
"           Username/Password Form - REQUIRED\n"
"           OTP Password Form - OPTIONAL\n"

#. type: Plain text
msgid ""
"In the top level of the form we have 3 executions of which all are "
"alternatively required.  This means that if any of these are successful, "
"then the others do not have to execute.  The Username/Password form is not "
"executed if there is an SSO Cookie set or a successful Kerberos login.  "
"Let's walk through the steps from when a client first redirects to keycloak "
"to authenticate the user."
msgstr ""
"この画面の上部には、必須の実行が3つあり、すべてお互い代替になることができます。このことは、これら3つのうちいずれかが実行できた場合、他は実行する必要がないということを意味します。SSOCookieセットがあるか、ケルベロスのログインが成功した場合は、ユーザー名またはパスワードの画面は実行されません。最初にクライアントがkeycloakにリダイレクトし、ユーザーを認証するまでの手順を説明します。"

#. type: Plain text
msgid ""
"The OpenID Connect or SAML protocol provider unpacks relevent data, verifies"
" the client and any signatures.  It creates a AuthenticationSessionModel.  "
"It looks up what the browser flow should be, then starts executing the flow."
msgstr ""
"OpenID "
"ConnectまたはSAMLプロトコル・プロバイダーによって、関連データがアンパックされ、クライアントと署名が検証されます。これで、AuthenticationSessionModelが作成されます。ブラウザーのフローが調べられてから、フローが実行されます。"
" "

#. type: Plain text
msgid ""
"The flow looks at the cookie execution and sees that it is an alternative.  "
"It loads the cookie provider.  It checks to see if the cookie provider "
"requires that a user already be associated with the authentication session."
"  Cookie provider does not require a user.  If it did, the flow would abort "
"and the user would see an error screen.  Cookie provider then executes.  Its"
" purpose is to see if there is an SSO cookie set.  If there is one set, it "
"is validated and the UserSessionModel is verified and associated with the "
"AuthenticationSessionModel.  The Cookie provider returns a success() status "
"if the SSO cookie exists and is validated.  Since the cookie provider "
"returned success and each execution at this level of the flow is "
"ALTERNATIVE, no other execution is executed and this results in a successful"
" login.  If there is no SSO cookie, the cookie provider returns with a "
"status of attempted().  This means there was no error condition, but no "
"success either.  The provider tried, but the request just wasn't set up to "
"handle this authenticator."
msgstr ""
"このフローによって、クッキーの実行が調べられ、それが代替であるということが確認されます。Cookieプロバイダーがロードされます。ユーザーが認証セッションに既に関連付けられているということを、Cookieプロバイダーが要求するかどうかを確認するために、このフローがチェックします。Cookieプロバイダーには、ユーザーは必要ありません。"
" "
"必要とされる場合は、そのフローが中断され、ユーザーにはエラー画面が表示されます。その後、Cookieプロバイダーが実行されます。SSOCookieセットがあるかどうかを確認することが目的です。1セットあった場合、それは検証され、UserSessionModelが証明され、AuthenticationSessionModelに関連付けられます。SSOCookieが存在し検証が済むと、Cookieプロバイダーはsuccess()ステータスを返却します。成功ステータスを返却したCookieプロバイダーと、フローのこの段階における各実行はALTERNATIVEであり、他の実行は実行されずにログインは成功します。SSOCookieが存在しなかった場合は、Cookieプロバイダーはattempted()というステータスを返却します。このことは、エラー状態はありませんでしたが、成功もしませんでしたということを意味します。つまり、プロバイダーが実行はしてみましたが、このオーセンティケーターを処理できるように、リクエストがセットアップされるまでは至りませんでしたということです。"

#. type: Plain text
msgid ""
"Next the flow looks at the Kerberos execution.  This is also an alternative."
"  The kerberos provider also does not require a user to be already set up "
"and associated with the AuthenticationSessionModel so this provider is "
"executed.  Kerberos uses the SPNEGO browser protocol.  This requires a "
"series of challenge/responses between the server and client exchanging "
"negotiation headers.  The kerberos provider does not see any negotiate "
"header, so it assumes that this is the first interaction between the server "
"and client.  It therefore creates an HTTP challenge response to the client "
"and sets a forceChallenge() status.  A forceChallenge() means that this HTTP"
" response cannot be ignored by the flow and must be returned to the client."
"  If instead the provider returned a challenge() status, the flow would hold"
" the challenge response until all other alternatives are attempted.  So, in "
"this initial phase, the flow would stop and the challenge response would be "
"sent back to the browser.  If the browser then responds with a successful "
"negotiate header, the provider associates the user with the "
"AuthenticationSession and the flow ends because the rest of the executions "
"on this level of the flow are all alternatives.  Otherwise, again, the "
"kerberos provider sets an attempted() status and the flow continues."
msgstr ""
"次に、ケルベロス実行のフローを説明します。これはまた代替です。また、ケルベロス・プロバイダーでは、ユーザーがすでに設定されてAuthenticationSessionModelに関連付けられていることが必要とされません。そのため、このプロバイダーが実行されることになります。ケルベロスはSPNEGOブラウザー・プロトコルを使用します。これには、サーバーとクライアントがネゴシエーションのヘッダーを交換する、一連のチャレンジまたはレスポンスが必要です。ケルベロス・プロバイダーはネゴシエーションのヘッダーを確認しないので、これがサーバーとクライアントの間の最初のやりとりであるとみなします。したがって、クライアントへのHTTPチャレンジ・レスポンスを作成し、forceChallenge()ステータスを設定します。forceChallenge()は、このHTTPレスポンスはフローにとって無視することができないもので、クライアントに返さなければならないということを意味します。代わりに、プロバイダーがchallenge()ステータスを返却した場合、他のすべての代替の実行が試されるまで、このフローがチャレンジ・レスポンスを保持します。したがって、この初期フェーズでは、フローが停止し、チャレンジ・レスポンスがブラウザーに送り返されます。次に、成功したネゴシエーションのヘッダーでブラウザーが応答すると、プロバイダーはユーザーをAuthenticationSessionに関連付け、フローが終了します。なぜなら、フローのこの段階での残りの実行はすべて代替だからです。そうでない場合は、ケルベロスのプロバイダーによってattempted()ステータスが設定され、フローは続行されます。"

#. type: Plain text
msgid ""
"The next execution is a subflow called Forms.  The executions for this "
"subflow are loaded and the same processing logic occurs"
msgstr "次に実行するのは、フォームと呼ばれるサブフローです。このサブフローの実行がロードされて同じ処理ロジックが発生します。"

#. type: Plain text
msgid ""
"The first execution in the Forms subflow is the UsernamePassword provider.  "
"This provider also does not require for a user to already be associated with"
" the flow.  This provider creates challenge HTTP response and sets its "
"status to challenge(). This execution is required, so the flow honors this "
"challenge and sends the HTTP response back to the browser.  This response is"
" a rendering of the Username/Password HTML page.  The user enters in their "
"username and password and clicks submit.  This HTTP request is directed to "
"the UsernamePassword provider.  If the user entered an invalid username or "
"password, a new challenge response is created and a status of "
"failureChallenge() is set for this execution.  A failureChallenge() means "
"that there is a challenge, but that the flow should log this as an error in "
"the error log.  This error log can be used to lock accounts or IP Addresses "
"that have had too many login failures.  If the username and password is "
"valid, the provider associated the UserModel with the "
"AuthenticationSessionModel and returns a status of success()"
msgstr ""
"フォーム・サブフローで最初に実行するのは、UsernamePasswordプロバイダーになります。また、このプロバイダーでは、ユーザが既にフローに関連付けられている必要はありません。このプロバイダーでは、チャレンジHTTPレスポンスが作成され、そのステータスはchallenge()に設定されます。この実行は必須なので、フローはこのチャレンジを優先し、ブラウザーにHTTPレスポンスを返します。このレスポンスは、Username/Password"
" "
"HTMLページのレンダリングです。ユーザーはユーザー名とパスワードを入力し、送信をクリックします。このHTTPリクエストは、UsernamePasswordプロバイダーに向けられています。ユーザーが無効なユーザー名またはパスワードを入力した場合、新しいチャレンジ・レスポンスが作成され、failureChallenge()のステータスがこの実行のために設定されます。failureChallenge()は、チャレンジがあることを意味しますが、これはフローによりエラーログ内のエラーとしてログが残される必要があります。このエラー・ログは、ログインにあまりに多く失敗したアカウントまたはIPアドレスをロックするために、使用することができます。ユーザー名とパスワードが有効な場合、プロバイダーはAuthenticationSessionModelにUserModelを関連付け、success()ステータスを返します。"

#. type: Plain text
msgid ""
"The next execution is the OTP Form.  This provider requires that a user has "
"been associated with the flow.  This requirement is satisfied because the "
"UsernamePassword provider already associated the user with the flow.  Since "
"a user is required for this provider, the provider is also asked if the user"
" is configured to use this provider.  If user is not configured, and this "
"execution is required, then the flow will then set up a required action that"
" the user must perform after authentication is complete.  For OTP, this "
"means the OTP setup page.  If the execution was optional, then this "
"execution is skipped."
msgstr ""
"次に実行するのは、OTPフォームになります。このプロバイダーでは、ユーザーはフローに関連付けられている必要があります。この要件は、UsernamePasswordプロバイダーによって既にユーザーがフローに関連付けられているため、満たされています。このプロバイダーにはユーザーが必要なため、ユーザーがこのプロバイダーを使用できるよう設定されているかどうか、プロバイダーは確認されます。ユーザーが設定されていない状態でこの実行が必要な場合、認証が完了した後にユーザーが実行しなければならない必須アクションがフローによって設定されます。OTPの場合、これはOTP設定ページを意味します。実行がオプションの場合は、この実行はスキップされます。"

#. type: Plain text
msgid ""
"After the flow is complete, the authentication processor creates a "
"UserSessionModel and associates it with the AuthenticationSessionModel.  It "
"then checks to see if the user is required to complete any required actions "
"before logging in."
msgstr ""
"フローが完了した後、認証プロセッサーによって、UserSessionModelが作成されてAuthenticationSessionModelに関連付けられます。次に、ログイン前にユーザーが必須アクションを完了する必要があるかどうかを確認されます。"

#. type: Plain text
msgid ""
"First, each required action's evaluateTriggers() method is called.  This "
"allows the required action provider to figure out if there is some state "
"that might trigger the action to be fired.  For example, if your realm has a"
" password expiration policy, it might be triggered by this method."
msgstr ""
"まず、必須アクションそれぞれのevaluateTriggers()のメソッドが呼び出されます。これにより、アクションが実行されるトリガーになる可能性がある状態であるかどうかを必須アクション・プロバイダーは判断することができます。例えば、レルムにパスワード有効期限ポリシーがある場合、このポリシーはこのメソッドによりトリガーされる可能性があります。"

#. type: Plain text
msgid ""
"Each required action associated with the user that has its "
"requiredActionChallenge() method called.  Here the provider sets up an HTTP "
"response which renders the page for the required action.  This is done by "
"setting a challenge status."
msgstr ""
"各必須アクションが、呼び出されたrequiredActionChallenge()メソッドを持っているユーザーに関連付けられました。これで、必須アクションのページをレンダリングするHTTPレスポンスを、プロバイダーが設定します。これは、チャレンジ・ステータスを設定することで実行されます。"

#. type: Plain text
msgid ""
"If the required action is ultimately successful, then the required action is"
" removed from the user's require actions list."
msgstr "必須アクションが最終的に成功すると、必須アクションはユーザーの必須アクションリストから削除されます。"

#. type: Plain text
#, no-wrap
msgid ""
"After all required actions have been resolved, the user is finally logged "
"in.         \n"
msgstr "必須アクションがすべて解決した後、最後にユーザーがログインします。\n"

#. type: Title ===
#, no-wrap
msgid "Authenticator SPI Walk Through"
msgstr "オーセンティケーターSPIのウォークスルー"

#. type: Plain text
msgid ""
"In this section, we'll take a look at the Authenticator interface.  For "
"this, we are going to implement an authenticator that requires that a user "
"enter in the answer to a secret question like \"What is your mother's maiden"
" name?\".  This example is fully implemented and contained in the "
"examples/providers/authenticator directory of the demo distribution of "
"Keycloak."
msgstr ""
"このセクションでは、オーセンティケーター・インターフェイスについて説明します。これを説明するために、オーセンティケーターを実装していきます。このオーセンティケーターにより、ユーザーは"
" \"あなたの母親の旧姓は何ですか？\" "
"などの秘密の質問への回答を入力する必要があります。この例は、完全に実装され、Keycloakのデモ配布物のexamples/providers/authenticatorディレクトリに含まれています。"

#. type: Plain text
msgid ""
"The classes you must implement are the "
"org.keycloak.authentication.AuthenticatorFactory and Authenticator "
"interfaces.  The Authenticator interface defines the logic.  The "
"AuthenticatorFactory is responsible for creating instances of an "
"Authenticator.  They both extend a more generic Provider and ProviderFactory"
" set of interfaces that other Keycloak components like User Federation do."
msgstr ""
"実装する必要があるクラスは、org.keycloak.authentication.AuthenticatorFactoryとオーセンティケーター・インターフェイスです。オーセンティケーター・インターフェイスはロジックを定義します。AuthenticatorFactoryは、オーセンティケーターのインスタンスの作成を担当します。それらは両方とも、ユーザー・フェデレーションなどの他Keycloakのコンポーネントが実行する、汎用的なプロバイダーとインターフェイスのProviderFactoryセットを拡張します。"

#. type: Plain text
#, no-wrap
msgid ""
"You will package your classes within a single jar.\n"
"This jar must contain a file named  `org.keycloak.authentication.AuthenticatorFactory`                and must be contained in the `META-INF/services/` directory of your jar.\n"
"This file must list the fully qualified classname of each AuthenticatorFactory implementation you have in the jar.\n"
"For example: \n"
msgstr ""
"1つのjar内でクラスをパッケージ化します。このjarには、 "
"`org.keycloak.authentication.AuthenticatorFactory` "
"という名前のファイルが含まれている必要があります。また、このjarは、jarの `META-INF/services/` "
"ディレクトリに格納されている必要があります。このファイルには、jar内にある各AuthenticatorFactory実装の要件を完全に満たしたクラス名がリストされている必要があります。サンプルは、以下の通りです。\n"

#. type: delimited block -
#, no-wrap
msgid ""
"org.keycloak.examples.authenticator.SecretQuestionAuthenticatorFactory\n"
"org.keycloak.examples.authenticator.AnotherProviderFactory\n"
msgstr ""
"org.keycloak.examples.authenticator.SecretQuestionAuthenticatorFactory\n"
"org.keycloak.examples.authenticator.AnotherProviderFactory\n"

#. type: Plain text
msgid ""
"This services/ file is used by Keycloak to scan the providers it has to load"
" into the system."
msgstr "このサービスまたはファイルは、システムにロードする必要があるプロバイダーをKeycloakがスキャンするために使用されます。"

#. type: Plain text
msgid "To deploy this jar, just copy it to the providers directory."
msgstr "このjarをデプロイするには、これをプロバイダー・ディレクトリにコピーするだけです。"

#. type: Title ====
#, no-wrap
msgid "Implementing an Authenticator"
msgstr "オーセンティケーターの実装"

#. type: Plain text
msgid ""
"When implementing the Authenticator interface, the first method that needs "
"to be implemented is the requiresUser() method.  For our example, this "
"method must return true as we need to validate the secret question "
"associated with the user.  A provider like kerberos would return false from "
"this method as it can resolve a user from the negotiate header.  This "
"example, however, is validating a specific credential of a specific user."
msgstr ""
"オーセンティケーター・インターフェイスを実装する場合、最初に実装する必要があるメソッドはrequiresUser()メソッドです。サンプルでは、このメソッドは、ユーザーに関連付けられた秘密の質問を検証する必要があるため、trueを返す必要があります。ケルベロスなどのプロバイダーは、ネゴシエート・ヘッダーからユーザーを解決することができるので、このメソッドからfalseを返します。ただし、このサンプルでは、特定のユーザーの特定のクレデンシャルが検証されています。"

#. type: Plain text
msgid ""
"The next method to implement is the configuredFor() method.  This method is "
"responsible for determining if the user is configured for this particular "
"authenticator.  For this example, we need to check if the answer to the "
"secret question has been set up by the user or not.  In our case we are "
"storing this information, hashed, within a UserCredentialValueModel within "
"the UserModel (just like passwords are stored).  Here's how we do this very "
"simple check:"
msgstr ""
"次に実装するメソッドは、configuredFor()メソッドです。このメソッドは、ユーザーがこの特定のオーセンティケーターのために設定されているのかどうかの判断を担当します。このサンプルの場合、秘密の質問への回答がユーザーによって設定されているのかどうかが確認される必要があります。ここでは、ハッシュ化されたこの情報を、（パスワードが格納されているのと同じように）UserModel内のUserCredentialValueModel内で格納しています。これを簡単に確認する方法は、以下の通りです。"

#. type: delimited block -
#, no-wrap
msgid ""
"@Override\n"
"  public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {\n"
"     return session.users().configuredForCredentialType(\"secret_question\", realm, user);\n"
"    }\n"
msgstr ""
"@Override\n"
"  public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {\n"
"     return session.users().configuredForCredentialType(\"secret_question\", realm, user);\n"
"    }\n"

#. type: Plain text
msgid ""
"The configuredForCredentialType() call queries the user to see if it "
"supports that credential type."
msgstr ""
"configuredForCredentialType()が呼び出されると、ユーザーは、そのクレデンシャル・タイプがサポートしているかどうかを尋ねられます。"

#. type: Plain text
msgid ""
"The next method to implement on the Authenticator is setRequiredActions().  "
"If configuredFor() returns false and our example authenticator is required "
"within the flow, this method will be called.  It is responsible for "
"registering any required actions that must be performed by the user.  In our"
" example, we need to register a required action that will force the user to "
"set up the answer to the secret question.  We will implement this required "
"action provider later in this chapter.  Here is the implementation of the "
"setRequiredActions() method."
msgstr ""
"次にオーセンティケーターで実装するメソッドは、setRequiredActions()です。configuredFor()がfalseを返し、オーセンティケーターのサンプルがフロー内で必要とされる場合、このメソッドが呼び出されます。このメソッドは、ユーザーが実行する必要がある必須アクションの登録を担当します。サンプルでは、ユーザーに秘密の質問への回答を設定させる、必須アクションを登録する必要があります。この章で、後ほど、この必須アクション・プロバイダーを実装します。setRequiredActions()メソッドの実装は、以下の通りです。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void setRequiredActions(KeycloakSession session, RealmModel realm, UserModel user) {\n"
"        user.addRequiredAction(\"SECRET_QUESTION_CONFIG\");\n"
"    }\n"
msgstr ""
"@Override\n"
" public void setRequiredActions(KeycloakSession session, RealmModel realm, UserModel user) {\n"
" user.addRequiredAction(\"SECRET_QUESTION_CONFIG\");\n"
" }\n"

#. type: Plain text
msgid ""
"Now we are getting into the meat of the Authenticator implementation.  The "
"next method to implement is authenticate().  This is the initial method the "
"flow invokes when the execution is first visited.  What we want is that if a"
" user has answered the secret question already on their browser's machine, "
"then the user doesn't have to answer the question again, making that machine"
" \"trusted\".  The authenticate() method isn't responsible for processing "
"the secret question form.  Its sole purpose is to render the page or to "
"continue the flow."
msgstr ""
"さて今度は、オーセンティケーター実装の問題に取り掛かります。次に実装するメソッドはauthenticate()です。これは、最初の実行時にフローが呼び出す、初期のメソッドです。ユーザーが既にブラウザーのマシン上で秘密の質問に回答した場合、ユーザーはその質問に再度回答する必要はなく、そのマシンを"
" \"trusted\" "
"にすることが必要です。authenticate()メソッドには、秘密の質問フォームを処理する責任はありません。その唯一の目的は、ページをレンダリングするか、フローを継続することです。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void authenticate(AuthenticationFlowContext context) {\n"
"        if (hasCookie(context)) {\n"
"           context.success();\n"
"           return;\n"
"        }\n"
"        Response challenge = loginForm(context).createForm(\"secret_question.ftl\");\n"
"        context.challenge(challenge);\n"
"    }\n"
msgstr ""
"@Override\n"
" public void authenticate(AuthenticationFlowContext context) {\n"
" if (hasCookie(context)) {\n"
" context.success();\n"
" return;\n"
" }\n"
" Response challenge = loginForm(context).createForm(\"secret_question.ftl\");\n"
" context.challenge(challenge);\n"
" }\n"

#. type: Plain text
msgid ""
"The hasCookie() method checks to see if there is already a cookie set on the"
" browser which indicates that the secret question has already been answered."
"  If that returns true, we just mark this execution's status as SUCCESS "
"using the AuthenticationFlowContext.success() method and returning from the "
"authentication() method."
msgstr ""
"hasCookie()メソッドによって、秘密の質問に既に回答したことを示すブラウザーに、Cookieが既に設定されているかどうかが確認されます。確認した結果、trueが返された場合は、AuthenticationFlowContext.success()メソッドを使用してauthentication()メソッドから返し、この実行ステータスをSUCCESSとするだけです。"

#. type: Plain text
msgid ""
"If the hasCookie() method returns false, we must return a response that "
"renders the secret question HTML form.  AuthenticationFlowContext has a "
"form() method that initializes a Freemarker page builder with appropriate "
"base information needed to build the form.  This page builder is called "
"`org.keycloak.login.LoginFormsProvider`.  the "
"LoginFormsProvider.createForm() method loads a Freemarker template file from"
" your login theme.  Additionally you can call the "
"LoginFormsProvider.setAttribute() method if you want to pass additional "
"information to the Freemarker template.  We'll go over this later."
msgstr ""
"hasCookie()メソッドによってfalseが返される場合、秘密の質問HTMLフォームをレンダリングするレスポンスを返す必要があります。AuthenticationFlowContextには、フォームを構築するのに必要な適切な基本情報を使用してFreemarkerページ・ビルダーを初期化する、form()メソッドがあります。このページ・ビルダーは"
" `org.keycloak.login.LoginFormsProvider` "
"と呼ばれています。LoginFormsProvider.createForm()メソッドは、ログイン・テーマからFreemarkerテンプレート・ファイルを読み込みます。さらに、Freemarker"
" "
"templateに追加情報を渡す必要がある場合は、LoginFormsProvider.setAttribute()メソッドを呼び出すことができます。この点については、後で説明します。"

#. type: Plain text
msgid ""
"Calling LoginFormsProvider.createForm() returns a JAX-RS Response object.  "
"We then call AuthenticationFlowContext.challenge() passing in this response."
"  This sets the status of the execution as CHALLENGE and if the execution is"
" Required, this JAX-RS Response object will be sent to the browser."
msgstr ""
"LoginFormsProvider.createForm()の呼び出しによって、JAX-"
"RSレスポンスのオブジェクトが返されます。次に、このレスポンス内に渡すAuthenticationFlowContext.challenge()を呼び出します。これにより、実行のステータスがCHALLENGEに設定され"
"、実行が必須の場合はこのJAX-RSレスポンスのオブジェクトがブラウザーに送信されます。"

#. type: Plain text
msgid ""
"So, the HTML page asking for the answer to a secret question is displayed to"
" the user and the user enteres in the answer and clicks submit.  The action "
"URL of the HTML form will send an HTTP request to the flow.  The flow will "
"end up invoking the action() method of our Authenticator implementation."
msgstr ""
"こうして、秘密の質問への回答を求めるHTMLページがユーザーに表示され、ユーザーが回答を入力して送信をクリックします。このHTMLフォームのURLアクションにより、HTTPの要求がフローに送信されます。このフローによって、オーセンティケーター実装のaction()メソッドが呼び出されることになります。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void action(AuthenticationFlowContext context) {\n"
"        boolean validated = validateAnswer(context);\n"
"        if (!validated) {\n"
"           Response challenge = context.form()\n"
"                                 .setError(\"badSecret\")\n"
"                                 .createForm(\"secret-question.ftl\");\n"
"           context.failureChallenge(AuthenticationFlowError.INVALID_CREDENTIALS, challenge);\n"
"           return;\n"
"        }\n"
"        setCookie(context);\n"
"        context.success();\n"
"    }\n"
msgstr ""
"@Override\n"
" public void action(AuthenticationFlowContext context) {\n"
" boolean validated = validateAnswer(context);\n"
" if (!validated) {\n"
" Response challenge = context.form()\n"
" .setError(\"badSecret\")\n"
" .createForm(\"secret-question.ftl\");\n"
" context.failureChallenge(AuthenticationFlowError.INVALID_CREDENTIALS, challenge);\n"
" return;\n"
" }\n"
" setCookie(context);\n"
" context.success();\n"
" }\n"

#. type: Plain text
msgid ""
"If the answer is not valid, we rebuild the HTML Form with an additional "
"error message.  We then call AuthenticationFlowContext.failureChallenge() "
"passing in the reason for the value and the JAX-RS response.  "
"failureChallenge() works the same as challenge(), but it also records the "
"failure so it can be analyzed by any attack detection service."
msgstr ""
"回答が有効でない場合、HTMLフォームを追加のエラーメッセージで再構築します。次に、値とJAX-"
"RSレスポンスの理由を渡すAuthenticationFlowContext.failureChallenge()を呼び出します。failureChallenge()は、challenge()と同じ働きをしますが、失敗を記録し、その失敗を攻撃の検出サービスで解析することもできます。"

#. type: Plain text
msgid ""
"If validation is successful, then we set a cookie to remember that the "
"secret question has been answered and we call "
"AuthenticationFlowContext.success()."
msgstr ""
"検証が成功したら、次にCookieを設定して秘密の質問に回答したことを覚えておき、AuthenticationFlowContext.success()を呼び出します。"

#. type: Plain text
msgid ""
"The last thing I want to go over is the setCookie() method.  This is an "
"example of providing configuration for the Authenticator.  In this case we "
"want the max age of the cookie to be configurable."
msgstr ""
"最後にこれから説明するのが、setCookie()メソッドです。これはオーセンティケーターの設定を提供するサンプルになります。この場合"
"、Cookieのmax-ageを設定できるようにする必要があります。"

#. type: delimited block -
#, no-wrap
msgid ""
"    protected void setCookie(AuthenticationFlowContext context) {\n"
"        AuthenticatorConfigModel config = context.getAuthenticatorConfig();\n"
"        int maxCookieAge = 60 * 60 * 24 * 30; // 30 days\n"
"        if (config != null) {\n"
"            maxCookieAge = Integer.valueOf(config.getConfig().get(\"cookie.max.age\"));\n"
msgstr ""
"protected void setCookie(AuthenticationFlowContext context) {\n"
" AuthenticatorConfigModel config = context.getAuthenticatorConfig();\n"
" int maxCookieAge = 60 * 60 * 24 * 30; // 30 days\n"
" if (config != null) {\n"
" maxCookieAge = Integer.valueOf(config.getConfig().get(\"cookie.max.age\"));\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        }\n"
"        ... set the cookie ...\n"
"    }\n"
msgstr ""
"}\n"
" ... set the cookie ...\n"
" }\n"

#. type: Plain text
msgid ""
"We obtain an AuthenticatorConfigModel from the "
"AuthenticationFlowContext.getAuthenticatorConfig() method.  If configuration"
" exists we pull the max age config out of it.  We will see how we can define"
" what should be configured when we talk about the AuthenticatorFactory "
"implementation.  The config values can be defined within the admin console "
"if you set up config definitions in your AuthenticatorFactory "
"implementation."
msgstr ""
"AuthenticationFlowContext.getAuthenticatorConfig()メソッドからAuthenticatorConfigModelを取得します。設定がある場合"
"、max-"
"age設定を引き出します。何を設定するべきかを定義する方法については、AuthenticatorFactoryの実装について説明する時に、見ていきます。"
" 設定値については、AuthenticatorFactory実装内で設定定義を設定した場合、管理コンソール内で定義することができます。"

#. type: Title ====
#, no-wrap
msgid "Implementing an AuthenticatorFactory"
msgstr "AuthenticatorFactoryの実装"

#. type: Plain text
msgid ""
"The next step in this process is to implement an AuthenticatorFactory.  This"
" factory is responsible for instantiating an Authenticator.  It also "
"provides deployment and configuration metadata about the Authenticator."
msgstr ""
"このプロセスでの次の手順は、AuthenticatorFactoryを実装することです。このファクトリーはオーセンティケーターのインスタンス化を担当します。"
" また、オーセンティケーターに関するデプロイメントと設定のメタデータも提供します。"

#. type: Plain text
msgid ""
"The getId() method is just the unique name of the component.  The create() "
"method is called by the runtime to allocate and process the Authenticator."
msgstr ""
"getId()メソッドは、コンポーネントの独自の名前です。create()メソッドは、オーセンティケーターを割り当てて処理するために、ランタイムによって呼び出されます。"

#. type: delimited block -
#, no-wrap
msgid ""
"public class SecretQuestionAuthenticatorFactory implements "
"AuthenticatorFactory, ConfigurableAuthenticatorFactory {\n"
msgstr ""
"public class SecretQuestionAuthenticatorFactory implements "
"AuthenticatorFactory, ConfigurableAuthenticatorFactory {\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    public static final String PROVIDER_ID = \"secret-question-authenticator\";\n"
"    private static final SecretQuestionAuthenticator SINGLETON = new SecretQuestionAuthenticator();\n"
msgstr ""
"public static final String PROVIDER_ID = \"secret-question-authenticator\";\n"
" private static final SecretQuestionAuthenticator SINGLETON = new SecretQuestionAuthenticator();\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public String getId() {\n"
"        return PROVIDER_ID;\n"
"    }\n"
msgstr ""
"@Override\n"
" public String getId() {\n"
" return PROVIDER_ID;\n"
" }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public Authenticator create(KeycloakSession session) {\n"
"        return SINGLETON;\n"
"    }\n"
msgstr ""
"@Override\n"
" public Authenticator create(KeycloakSession session) {\n"
" return SINGLETON;\n"
" }\n"

#. type: Plain text
msgid ""
"The next thing the factory is responsible for is specify the allowed "
"requirement switches.  While there are four different requirement types: "
"ALTERNATIVE, REQUIRED, OPTIONAL, DISABLED, AuthenticatorFactory "
"implementations can limit which requirement options are shown in the admin "
"console when defining a flow.  In our example, we're going to limit our "
"requirement options to REQUIRED and DISABLED."
msgstr ""
"次にファクトリーが担当するのは、許可された要件スイッチを指定することです。ALTERNATIVE、REQUIRED、OPTIONAL、DISABLEの4つの異なる要件タイプがありますが、AuthenticatorFactoryの実装により、フローを定義する時に管理コンソールに表示される要件オプションを制限することができます。このサンプルでは、要件オプションをREQUIREDとDISABLEDに制限します。"

#. type: delimited block -
#, no-wrap
msgid ""
"    private static AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {\n"
"            AuthenticationExecutionModel.Requirement.REQUIRED,\n"
"            AuthenticationExecutionModel.Requirement.DISABLED\n"
"    };\n"
"    @Override\n"
"    public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {\n"
"        return REQUIREMENT_CHOICES;\n"
"    }\n"
msgstr ""
"    private static AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {\n"
"            AuthenticationExecutionModel.Requirement.REQUIRED,\n"
"            AuthenticationExecutionModel.Requirement.DISABLED\n"
"    };\n"
"    @Override\n"
"    public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {\n"
"        return REQUIREMENT_CHOICES;\n"
"    }\n"

#. type: Plain text
msgid ""
"The AuthenticatorFactory.isUserSetupAllowed() is a flag that tells the flow "
"manager whether or not Authenticator.setRequiredActions() method will be "
"called.  If an Authenticator is not configured for a user, the flow manager "
"checks isUserSetupAllowed().  If it is false, then the flow aborts with an "
"error.  If it returns true, then the flow manager will invoke "
"Authenticator.setRequiredActions()."
msgstr ""
"AuthenticatorFactory.isUserSetupAllowed()は、Authenticator.setRequiredActions()メソッドが呼び出されるかどうかをフローマネージャーに通知するフラグです。オーセンティケーターがユーザー用に設定されていない場合、フローマネージャーがisUserSetupAllowed()を確認します。falseの場合は、フローによりエラーでアボートされます。trueが返された場合は、フローマネージャーはAuthenticator.setRequiredActions()を呼び出します。"
" "

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public boolean isUserSetupAllowed() {\n"
"        return true;\n"
"    }\n"
msgstr ""
"@Override\n"
" public boolean isUserSetupAllowed() {\n"
" return true;\n"
" }\n"

#. type: Plain text
msgid ""
"The next few methods define how the Authenticator can be configured.  The "
"isConfigurable() method is a flag which specifies to the admin console on "
"whether the Authenticator can be configured within a flow.  The "
"getConfigProperties() method returns a list of ProviderConfigProperty "
"objects.  These objects define a specific configuration attribute."
msgstr ""
"次のいくつかのメソッドにより、オーセンティケーターの設定方法が定義されます。isConfigurable()メソッドは、オーセンティケーターをフロー内で設定することができるかどうかを管理コンソールに指定するフラグです。getConfigProperties()メソッドは、ProviderConfigPropertyオブジェクトのリストを返します。これらのオブジェクトにより、特定の設定属性が定義されます。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public List<ProviderConfigProperty> getConfigProperties() {\n"
"        return configProperties;\n"
"    }\n"
msgstr ""
"@Override\n"
" public List<ProviderConfigProperty> getConfigProperties() {\n"
" return configProperties;\n"
" }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    private static final List<ProviderConfigProperty> configProperties = new"
" ArrayList<ProviderConfigProperty>();\n"
msgstr ""
"private static final List<ProviderConfigProperty> configProperties = new "
"ArrayList<ProviderConfigProperty>();\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    static {\n"
"        ProviderConfigProperty property;\n"
"        property = new ProviderConfigProperty();\n"
"        property.setName(\"cookie.max.age\");\n"
"        property.setLabel(\"Cookie Max Age\");\n"
"        property.setType(ProviderConfigProperty.STRING_TYPE);\n"
"        property.setHelpText(\"Max age in seconds of the SECRET_QUESTION_COOKIE.\");\n"
"        configProperties.add(property);\n"
"    }\n"
msgstr ""
"static {\n"
" 　ProviderConfigProperty property;\n"
" 　property = new ProviderConfigProperty();\n"
" 　property.setName(\"cookie.max.age\");\n"
"　 property.setLabel(\"Cookie Max Age\");\n"
" 　property.setType(ProviderConfigProperty.STRING_TYPE);\n"
" 　property.setHelpText(\"Max age in seconds of the SECRET_QUESTION_COOKIE.\");\n"
" 　configProperties.add(property);\n"
" }\n"

#. type: Plain text
msgid ""
"Each ProviderConfigProperty defines the name of the config property.  This "
"is the key used in the config map stored in AuthenticatorConfigModel.  The "
"label defines how the config option will be displayed in the admin console."
"  The type defines if it is a String, Boolean, or other type.  The admin "
"console will display different UI inputs depending on the type.  The help "
"text is what will be shown in the tooltip for the config attribute in the "
"admin console.  Read the javadoc of ProviderConfigProperty for more detail."
msgstr ""
"各ProviderConfigPropertyにより、設定プロパティの名前が定義されます。これが、AuthenticatorConfigModel内に格納される設定マップで使用される鍵となります。ラベルにより、管理コンソール内でどのように設定オプションが表示されるかが定義されます。タイプにより、それがString、Booleanまたはその他のタイプなのかが定義されます。管理コンソールには、タイプによって異なるUI入力が表示されます。ヘルプのテキストは、管理コンソール内の設定属性のためのツールチップに表示されるものです。詳しくは、ProviderConfigPropertyのjavadocを参照ください。"

#. type: Plain text
msgid ""
"The rest of the methods are for the admin console.  getHelpText() is the "
"tooltip text that will be shown when you are picking the Authenticator you "
"want to bind to an execution.  getDisplayType() is what text that will be "
"shown in the admin console when listing the Authenticator.  "
"getReferenceCategory() is just a category the Authenticator belongs to."
msgstr ""
"残りのメソッドは管理コンソール用です。getHelpText()は、実行時にバインドする必要があるオーセンティケーターを選択する時に表示される、ツールチップのテキストです。getDisplayType()は、オーセンティケーターをリストアップする時に管理コンソールに表示されるテキストです。getReferenceCategory()は、オーセンティケーターが属する、単なるカテゴリーです。"
" "

#. type: Title ====
#, no-wrap
msgid "Adding Authenticator Form"
msgstr "オーセンティケーター・フォームの追加"

#. type: Plain text
msgid ""
"Keycloak comes with a Freemarker <<_themes,theme and template engine>>.  The"
" createForm() method you called within authenticate() of your Authenticator "
"class, builds an HTML page from a file within your login theme: secret-"
"question.ftl.  This file should be placed in the login theme with all the "
"other .ftl files you see for login."
msgstr ""
"Keycloakには、Freemarker <<_themes,theme and template engine>> "
"が付属しています。オーセンティケーター・クラスのauthenticate()内に呼び出される、createForm()メソッドにより、secret-"
"question.ftlというログイン・テーマ内のファイルからHTMLページが構築されます。このファイルは、ログイン時に表示されるその他すべての.ftlファイルと共に、ログイン・テーマ内に保存される必要があります。"

#. type: Plain text
msgid ""
"Let's take a bigger look at secret-question.ftl Here's a small code snippet:"
msgstr "secret-question.ftlの詳細を見ていきましょう。以下は、短いコード・スニペットになります。"

#. type: delimited block -
#, no-wrap
msgid ""
"        <form id=\"kc-totp-login-form\" class=\"${properties.kcFormClass!}\" action=\"${url.loginAction}\" method=\"post\">\n"
"            <div class=\"${properties.kcFormGroupClass!}\">\n"
"                <div class=\"${properties.kcLabelWrapperClass!}\">\n"
"                    <label for=\"totp\" class=\"${properties.kcLabelClass!}\">${msg(\"loginSecretQuestion\")}</label>\n"
"                </div>\n"
msgstr ""
"        <form id=\"kc-totp-login-form\" class=\"${properties.kcFormClass!}\" action=\"${url.loginAction}\" method=\"post\">\n"
"            <div class=\"${properties.kcFormGroupClass!}\">\n"
"                <div class=\"${properties.kcLabelWrapperClass!}\">\n"
"                    <label for=\"totp\" class=\"${properties.kcLabelClass!}\">${msg(\"loginSecretQuestion\")}</label>\n"
"                </div>\n"

#. type: delimited block -
#, no-wrap
msgid ""
"                <div class=\"${properties.kcInputWrapperClass!}\">\n"
"                    <input id=\"totp\" name=\"secret_answer\" type=\"text\" class=\"${properties.kcInputClass!}\" />\n"
"                </div>\n"
"            </div>\n"
msgstr ""
"                <div class=\"${properties.kcInputWrapperClass!}\">\n"
"                    <input id=\"totp\" name=\"secret_answer\" type=\"text\" class=\"${properties.kcInputClass!}\" />\n"
"                </div>\n"
"            </div>\n"

#. type: Plain text
msgid ""
"Any piece of text enclosed in `${}` corresponds to an attribute or template "
"funtion.  If you see the form's action, you see it points to "
"`${url.loginAction}`.  This value is automatically generated when you invoke"
" the AuthenticationFlowContext.form() method.  You can also obtain this "
"value by calling the AuthenticationFlowContext.getActionURL() method in Java"
" code."
msgstr ""
"`${}` に含まれるテキストの一部は、属性かテンプレートの機能に対応します。フォームの動作を確認すると、それは "
"`${url.loginAction}` "
"を指していることが分かります。この値は、AuthenticationFlowContext.form()メソッドを呼び出す時に自動的に生成されます。また、"
" "
"Javaコード内のAuthenticationFlowContext.getActionURL()メソッドを呼び出すことにより、この値を取得することもできます。"

#. type: Plain text
#, no-wrap
msgid ""
"You'll also see `${properties.someValue}`.\n"
"These correspond to properties defined in your theme.properties file of our theme.\n"
" `${msg(\"someValue\")}` corresponds to the internationalized message bundles (.properties files) included with the login theme messages/ directory.\n"
"If you're just using english, you can just add the value of the `loginSecretQuestion`                value.\n"
"This should be the question you want to ask the user. \n"
msgstr ""
"また、 `${properties.someValue}` も表示されます。\n"
"これらは、テーマのtheme.propertiesファイル内で定義されたプロパティに対応します。\n"
" `${msg(\"someValue\")}` は、ログイン・テーマのメッセージまたはディレクトリと共に含まれている、国際化されたメッセージのバンドル（.properties files）に対応します。\n"
"英語のみを使用している場合は、 `loginSecretQuestion` の値を追加するだけです。\n"
"これが、ユーザーに尋ねる必要がある質問になります。\n"

#. type: Plain text
msgid ""
"When you call AuthenticationFlowContext.form() this gives you a "
"LoginFormsProvider instance.  If you called, "
"`LoginFormsProvider.setAttribute(\"foo\", \"bar\")`, the value of \"foo\" "
"would be available for reference in your form as `${foo}`.  The value of an "
"attribute can be any Java bean as well."
msgstr ""
"AuthenticationFlowContext.form()を呼び出すと、LoginFormsProviderインスタンスが生成されます。 "
"`LoginFormsProvider.setAttribute（ \"foo\" 、 \"bar\" ）` を呼び出した場合、 \"foo\" "
"の値はフォーム内で `${foo}` として参照できるようになります。属性の値は、Java beanでも構いません。"

#. type: Title ====
#, no-wrap
msgid "Adding Authenticator to a Flow"
msgstr "オーセンティケーターをフローに追加"

#. type: Plain text
msgid ""
"Adding an Authenticator to a flow must be done in the admin console.  If you"
" go to the Authentication menu item and go to the Flow tab, you will be able"
" to view the currently defined flows.  You cannot modify an built in flows, "
"so, to add the Authenticator we've created you have to copy an existing flow"
" or create your own.  I'm hoping the UI is intuitive enough so that you can "
"figure out for yourself how to create a flow and add the Authenticator."
msgstr ""
"フローへのオーセンティケーター追加は、管理コンソール内で行う必要があります。オーセンティケーション・メニュー・アイテムへ移動してフロー・タブを選択すると、現在定義済みのフローが表示されます。組み込みのフローを変更することはできませんので、作成したオーセンティケーターを追加するには、既存のフローをコピーするか、独自のフローを作成する必要があります。このUIは非常に分かりやすく作られているので、フローを作成してオーセンティケーターを追加する方法が直感的に分かるようになっていれば良いと思っています。"

#. type: Plain text
msgid ""
"After you've created your flow, you have to bind it to the login action you "
"want to bind it to.  If you go to the Authentication menu and go to the "
"Bindings tab you will see options to bind a flow to the browser, "
"registration, or direct grant flow."
msgstr ""
"フローを作成した後、バインドしたいログイン動作に、これをバインドする必要があります。オーセンティケーション・メニューに移動してバインディング・タブを選択すると、フローをブラウザー、登録、または直接許可フローにバインドするオプションが表示されます。"

#. type: Title ===
#, no-wrap
msgid "Required Action Walkthrough"
msgstr "必須アクションのウォークスルー"

#. type: Plain text
msgid ""
"In this section we will discuss how to define a required action.  In the "
"Authenticator section you may have wondered, \"How will we get the user's "
"answer to the secret question entered into the system?\".  As we showed in "
"the example, if the answer is not set up, a required action will be "
"triggered.  This section discusses how to implement the required action for "
"the Secret Question Authenticator."
msgstr ""
"このセクションでは、必須アクションを定義する方法について説明します。オーセンティケーター・セクションでは、 "
"\"どのようにしてシステムに入力された秘密の質問に対するユーザーの回答をもらえば良いのだろう\" "
"と疑問に思うかもしれません。サンプルで示された通り、回答が設定されていない場合は、必須アクションがトリガーになります。このセクションでは、秘密の質問オーセンティケーターのために必須アクションを実装する方法について説明します。"

#. type: Plain text
#, no-wrap
msgid ""
"You will package your classes within a single jar.\n"
"This jar does not have to be separate from other provider classes but it must contain a file named  `org.keycloak.authentication.RequiredActionFactory`                and must be contained in the `META-INF/services/` directory of your jar.\n"
"This file must list the fully qualified classname of each RequiredActionFactory implementation you have in the jar.\n"
"For example: \n"
msgstr ""
"1つのjar内でクラスをパッケージ化します。\n"
"このjarを他のプロバイダーのクラスとは別にする必要はありませんが、  `org.keycloak.authentication.RequiredActionFactory` という名前のファイルを含む必要があります。また、これはjarの `META-INF/services/` ディレクトリ内に含まれる必要があります。\n"
"このファイルには、jar内にある各RequiredActionFactory実装の完全修飾クラス名がリストされている必要があります。\n"
"例えば、以下の通りです。\n"

#. type: delimited block -
#, no-wrap
msgid ""
"org.keycloak.examples.authenticator.SecretQuestionRequiredActionFactory\n"
msgstr ""
"org.keycloak.examples.authenticator.SecretQuestionRequiredActionFactory\n"

#. type: Title ====
#, no-wrap
msgid "Implement the RequiredActionProvider"
msgstr "RequiredActionProviderの実装"

#. type: Plain text
msgid ""
"Required actions must first implement the RequiredActionProvider interface."
"  The RequiredActionProvider.requiredActionChallenge() is the initial call "
"by the flow manager into the required action.  This method is responsible "
"for rendering the HTML form that will drive the required action."
msgstr ""
"必須アクションでは、まずRequiredActionProviderインターフェイスが実装される必要があります。RequiredActionProvider.requiredActionChallenge()は、フローマネージャーから必須アクションに対する初回の呼び出しになります。このメソッドは、必須アクションを動作させるHTMLフォームのレンダリングを担当します。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void requiredActionChallenge(RequiredActionContext context) {\n"
"        Response challenge = context.form().createForm(\"secret_question_config.ftl\");\n"
"        context.challenge(challenge);\n"
msgstr ""
"@Override\n"
" public void requiredActionChallenge(RequiredActionContext context) {\n"
" Response challenge = context.form().createForm(\"secret_question_config.ftl\");\n"
" context.challenge(challenge);\n"

#. type: Plain text
msgid ""
"You see that RequiredActionContext has similar methods to "
"AuthenticationFlowContext.  The form() method allows you to render the page "
"from a Freemarker template.  The action URL is preset by the call to this "
"form() method.  You just need to reference it within your HTML form.  I'll "
"show you this later."
msgstr ""
"RequiredActionContextには、AuthenticationFlowContextと同じようなメソッドがあります。form()メソッドにより、Freemarkerテンプレートからページをレンダリングすることができます。動作確認URLは、このform()メソッドの呼び出しにより事前設定されています。これをHTMLフォーム内で参照するだけで済みます。これについては、後ほど説明します。"

#. type: Plain text
msgid ""
"The challenge() method notifies the flow manager that a required action must"
" be executed."
msgstr "challenge()メソッドにより、必須アクションを実行する必要があるということがフローマネージャーに通知されます。"

#. type: Plain text
msgid ""
"The next method is responsible for processing input from the HTML form of "
"the required action.  The action URL of the form will be routed to the "
"RequiredActionProvider.processAction() method"
msgstr ""
"次のメソッドは、必須アクションのHTMLフォームからの入力処理を担当します。フォームの動作確認URLは、RequiredActionProvider.processAction()メソッドへルーティングされます。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void processAction(RequiredActionContext context) {\n"
"        String answer = (context.getHttpRequest().getDecodedFormParameters().getFirst(\"answer\"));\n"
"        UserCredentialValueModel model = new UserCredentialValueModel();\n"
"        model.setValue(answer);\n"
"        model.setType(SecretQuestionAuthenticator.CREDENTIAL_TYPE);\n"
"        context.getUser().updateCredentialDirectly(model);\n"
"        context.success();\n"
"    }\n"
msgstr ""
"@Override\n"
" public void processAction(RequiredActionContext context) {\n"
" String answer = (context.getHttpRequest().getDecodedFormParameters().getFirst(\"answer\"));\n"
" UserCredentialValueModel model = new UserCredentialValueModel();\n"
" model.setValue(answer);\n"
" model.setType(SecretQuestionAuthenticator.CREDENTIAL_TYPE);\n"
" context.getUser().updateCredentialDirectly(model);\n"
" context.success();\n"
" }\n"

#. type: Plain text
msgid ""
"The answer is pulled out of the form post.  A UserCredentialValueModel is "
"created and the type and value of the credential are set.  Then "
"UserModel.updateCredentialDirectly() is invoked.  Finally, "
"RequiredActionContext.success() notifies the container that the required "
"action was successful."
msgstr ""
"回答がフォーム投稿から引き出されます。UserCredentialValueModelが作成され、クレデンシャルのタイプと値が設定されます。次に、UserModel.updateCredentialDirectly()"
" "
"が呼び出されます。最後に、RequiredActionContext.success()により、必須アクションが成功したことがコンテナーに通知されます。"

#. type: Title ====
#, no-wrap
msgid "Implement the RequiredActionFactory"
msgstr "RequiredActionFactoryの実装"

#. type: Plain text
msgid ""
"This class is really simple.  It is just responsible for creating the "
"required actin provider instance."
msgstr "このクラスは非常に単純です。これは必須アクション・プロバイダー・インスタンスの作成を担当するだけです。"

#. type: delimited block -
#, no-wrap
msgid ""
"public class SecretQuestionRequiredActionFactory implements "
"RequiredActionFactory {\n"
msgstr ""
"public class SecretQuestionRequiredActionFactory implements "
"RequiredActionFactory {\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    private static final SecretQuestionRequiredAction SINGLETON = new "
"SecretQuestionRequiredAction();\n"
msgstr ""
"private static final SecretQuestionRequiredAction SINGLETON = new "
"SecretQuestionRequiredAction();\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public RequiredActionProvider create(KeycloakSession session) {\n"
"        return SINGLETON;\n"
"    }\n"
msgstr ""
"    @Override\n"
" public RequiredActionProvider create(KeycloakSession session) {\n"
" return SINGLETON;\n"
" }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public String getId() {\n"
"        return SecretQuestionRequiredAction.PROVIDER_ID;\n"
"    }\n"
msgstr ""
"@Override\n"
" public String getId() {\n"
" return SecretQuestionRequiredAction.PROVIDER_ID;\n"
" }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public String getDisplayText() {\n"
"        return \"Secret Question\";\n"
"    }\n"
msgstr ""
"@Override\n"
" public String getDisplayText() {\n"
" return \"Secret Question\";\n"
" }\n"

#. type: Plain text
msgid ""
"The getDisplayText() method is just for the admin console when it wants to "
"display a friendly name for the required action."
msgstr ""
"getDisplayText()メソッドは、管理コンソールで、必須アクションのために分かりやすい名前を表示する必要がある時にだけ使用するものです。"

#. type: Title ====
#, no-wrap
msgid "Enable Required Action"
msgstr "必須アクションの有効化"

#. type: Plain text
msgid ""
"The final thing you have to do is go into the admin console.  Click on the "
"Authentication left menu.  Click on the Required Actions tab.  Click on the "
"Register button and choose your new Required Action.  Your new required "
"action should now be displayed and enabled in the required actions list."
msgstr ""
"最後に、管理コンソールに移動する必要があります。認証の左メニューをクリックします。必須アクションのタブをクリックします。登録ボタンをクリックし、新しい必須アクションンを選択します。これで、必須アクションのリストに新しい必須アクションが表示され、有効になります。"

#. type: Title ===
#, no-wrap
msgid "Modifying/Extending the Registration Form"
msgstr "登録フォームの変更または拡張"

#. type: Plain text
msgid ""
"It is entirely possible for you to implement your own flow with a set of "
"Authenticators to totally change how registration is done in Keycloak.  But "
"what you'll usually want to do is just add a little bit of validation to the"
" out of the box registration page.  An additional SPI was created to be able"
" to do this.  It basically allows you to add validation of form elements on "
"the page as well as to initialize UserModel attributes and data after the "
"user has been registered.  We'll look at both the implementation of the user"
" profile registration processing as well as the registration Google "
"Recaptcha plugin."
msgstr ""
"認証のセットを使用して独自のフローを実装すれば、Keycloakでの登録方法を完全に変更することができます。しかし、通常は、登録ページにバリデーションを少し加えたいだけでしょう。このことを可能にするために、追加のSPIが作成されました。このSPIにより、基本的には、ユーザーの登録後、UserModel属性とデータを初期化するだけでなく、ページのフォーム要素にバリデーションを加えることができるようになります。Google"
" Recaptchaプラグイン登録とユーザー・プロファイル登録処理の実装の両方を説明します。"

#. type: Title ====
#, no-wrap
msgid "Implementation FormAction Interface"
msgstr "実装FormActionインターフェイス"

#. type: Plain text
msgid ""
"The core interface you have to implement is the FormAction interface.  A "
"FormAction is responsible for rendering and processing a portion of the "
"page.  Rendering is done in the buildPage() method, validation is done in "
"the validate() method, post validation operations are done in success().  "
"Let's first take a look at buildPage() method of the Recaptcha plugin."
msgstr ""
"実装する必要がある最も重要なインターフェイスは、FormActionインターフェイスです。FormActionは、ページの一部のレンダリングと処理を担当します。レンダリングはbuildPage()メソッド内で、バリデーションはvalidate()メソッド内で、投稿バリデーション動作はsuccess()内で実行されます。まずは、RecaptchaプラグインのbuildPage()メソッドを見てみましょう。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void buildPage(FormContext context, LoginFormsProvider form) {\n"
"        AuthenticatorConfigModel captchaConfig = context.getAuthenticatorConfig();\n"
"        if (captchaConfig == null || captchaConfig.getConfig() == null\n"
"                || captchaConfig.getConfig().get(SITE_KEY) == null\n"
"                || captchaConfig.getConfig().get(SITE_SECRET) == null\n"
"                ) {\n"
"            form.addError(new FormMessage(null, Messages.RECAPTCHA_NOT_CONFIGURED));\n"
"            return;\n"
"        }\n"
"        String siteKey = captchaConfig.getConfig().get(SITE_KEY);\n"
"        form.setAttribute(\"recaptchaRequired\", true);\n"
"        form.setAttribute(\"recaptchaSiteKey\", siteKey);\n"
"        form.addScript(\"https://www.google.com/recaptcha/api.js\");\n"
"    }\n"
msgstr ""
"@Override\n"
" public void buildPage(FormContext context, LoginFormsProvider form) {\n"
" AuthenticatorConfigModel captchaConfig = context.getAuthenticatorConfig();\n"
" if (captchaConfig == null || captchaConfig.getConfig() == null\n"
" || captchaConfig.getConfig().get(SITE_KEY) == null\n"
" || captchaConfig.getConfig().get(SITE_SECRET) == null\n"
" ) {\n"
" form.addError(new FormMessage(null, Messages.RECAPTCHA_NOT_CONFIGURED));\n"
" return;\n"
" }\n"
" String siteKey = captchaConfig.getConfig().get(SITE_KEY);\n"
" form.setAttribute(\"recaptchaRequired\", true);\n"
" form.setAttribute(\"recaptchaSiteKey\", siteKey);\n"
" form.addScript(\"https://www.google.com/recaptcha/api.js\");\n"
" }\n"

#. type: Plain text
msgid ""
"The Recaptcha buildPage() method is a callback by the form flow to help "
"render the page.  It receives a form parameter which is a "
"LoginFormsProvider.  You can add additional attributes to the form provider "
"so that they can be displayed in the HTML page generated by the registration"
" Freemarker template."
msgstr ""
"Recaptcha "
"buildPage()メソッドは、ページをレンダリングするための、フォーム・フローからのコールバックです。これは、LoginFormsProviderであるフォーム・パラメーターを受け取ります。フォーム・プロバイダーに追加属性を加えて、登録Freemarkerテンプレートによって生成されたHTMLページに表示させることができます。"

#. type: Plain text
msgid ""
"The code above is from the registration recaptcha plugin.  Recaptcha "
"requires some specific settings that must be obtained from configuration.  "
"FormActions are configured in the exact same was as Authenticators are.  In "
"this example, we pull the Google Recaptcha site key from configuration and "
"add it as an attribute to the form provider.  Our regstration template file "
"can read this attribute now."
msgstr ""
"上記のコードは、登録recaptchaプラグインからのものです。Recaptchaにはいくつかの特定の設定が必要で、それらを設定から取得する必要があります。FormActionsは、Authenticatorsとまったく同じように設定されています。このサンプルでは、設定からGoogle"
" "
"Recaptchaサイト鍵を引き出し、フォーム・プロバイダーに属性として追加します。これで、登録テンプレート・ファイルはこの属性を読み込むことができます。"

#. type: Plain text
msgid ""
"Recaptcha also has the requirement of loading a javascript script.  You can "
"do this by calling LoginFormsProvider.addScript() passing in the URL."
msgstr ""
"また、Recaptchaには、javascriptのスクリプトを読み込む要件があります。URL内で渡すLoginFormsProvider.addScript()を呼び出して、これを実行することができます。"

#. type: Plain text
msgid ""
"For user profile processing, there is no additional information that it "
"needs to add to the form, so its buildPage() method is empty."
msgstr ""
"ユーザー・プロファイルを処理するために、フォームに加える必要がある追加情報はありません。そのため、そのbuildPage()メソッドは空です。"

#. type: Plain text
msgid ""
"The next meaty part of this interface is the validate() method.  This is "
"called immediately upon receiving a form post.  Let's look at the "
"Recaptcha's plugin first."
msgstr ""
"このインターフェイスの次の部分はvalidate()メソッドです。これは、フォーム投稿を受信するとすぐに呼び出されます。まず、Recaptchaのプラグインを見てみましょう。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void validate(ValidationContext context) {\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        List<FormMessage> errors = new ArrayList<>();\n"
"        boolean success = false;\n"
msgstr ""
"@Override\n"
" public void validate(ValidationContext context) {\n"
" MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
" List<FormMessage> errors = new ArrayList<>();\n"
" boolean success = false;\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        String captcha = formData.getFirst(G_RECAPTCHA_RESPONSE);\n"
"        if (!Validation.isBlank(captcha)) {\n"
"            AuthenticatorConfigModel captchaConfig = context.getAuthenticatorConfig();\n"
"            String secret = captchaConfig.getConfig().get(SITE_SECRET);\n"
msgstr ""
"String captcha = formData.getFirst(G_RECAPTCHA_RESPONSE);\n"
" if (!Validation.isBlank(captcha)) {\n"
" AuthenticatorConfigModel captchaConfig = context.getAuthenticatorConfig();\n"
" String secret = captchaConfig.getConfig().get(SITE_SECRET);\n"

#. type: delimited block -
#, no-wrap
msgid ""
"            success = validateRecaptcha(context, success, captcha, secret);\n"
"        }\n"
"        if (success) {\n"
"            context.success();\n"
"        } else {\n"
"            errors.add(new FormMessage(null, Messages.RECAPTCHA_FAILED));\n"
"            formData.remove(G_RECAPTCHA_RESPONSE);\n"
"            context.validationError(formData, errors);\n"
"            return;\n"
msgstr ""
"success = validateRecaptcha(context, success, captcha, secret);\n"
" }\n"
" if (success) {\n"
" context.success();\n"
" } else {\n"
" errors.add(new FormMessage(null, Messages.RECAPTCHA_FAILED));\n"
" formData.remove(G_RECAPTCHA_RESPONSE);\n"
" context.validationError(formData, errors);\n"
" return;　\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        }\n"
"    }\n"
msgstr ""
"}\n"
" }　\n"
"\n"

#. type: Plain text
msgid ""
"Here we obtain the form data that the Recaptcha widget adds to the form.  We"
" obtain the Recaptcha secret key from configuration.  We then validate the "
"recaptcha.  If successful, ValidationContext.success() is called.  If not, "
"we invoke ValidationContext.validationError() passing in the formData (so "
"the user doesn't have to re-enter data), we also specify an error message we"
" want displayed.  The error message must point to a message bundle property "
"in the internationalized message bundles.  For other registration extensions"
" validate() might be validating the format of a form element, i.e.  an "
"alternative email attribute."
msgstr ""
"ここでは、Recaptchaウィジェットがフォームに追加するフォームデータを取得します。設定からRecaptcha秘密鍵を取得します。次に、recaptchaを検証します。成功すると、ValidationContext.success()が呼び出されます。成功しなかった場合は、formData内で渡すValidationContext.validationError()を呼び出します（こうしてユーザーはデータを再入力する必要がなくなります）。また、表示するエラーメッセージも指定します。エラーメッセージにより、国際化されたメッセージ・バンドル内のメッセージ・バンドル・プロパティが指し示される必要があります。他の登録拡張では、validate()はフォーム要素のフォーマット、例えば別の電子メール属性を検証している可能性があります。"

#. type: Plain text
msgid ""
"Let's also look at the user profile plugin that is used to validate email "
"address and other user information when registering."
msgstr "また、登録時にメールアドレスと他のユーザー情報を検証するために使用されるユーザー・プロファイル・プラグインを見てみましょう。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void validate(ValidationContext context) {\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        List<FormMessage> errors = new ArrayList<>();\n"
msgstr ""
"@Override\n"
" public void validate(ValidationContext context) {\n"
" MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
" List<FormMessage> errors = new ArrayList<>();\n"

#. type: delimited block -
#, no-wrap
msgid "        String eventError = Errors.INVALID_REGISTRATION;\n"
msgstr "String eventError = Errors.INVALID_REGISTRATION;\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        if (Validation.isBlank(formData.getFirst((RegistrationPage.FIELD_FIRST_NAME)))) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_FIRST_NAME, Messages.MISSING_FIRST_NAME));\n"
"        }\n"
msgstr ""
"if (Validation.isBlank(formData.getFirst((RegistrationPage.FIELD_FIRST_NAME)))) {\n"
" errors.add(new FormMessage(RegistrationPage.FIELD_FIRST_NAME, Messages.MISSING_FIRST_NAME));\n"
" }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        if (Validation.isBlank(formData.getFirst((RegistrationPage.FIELD_LAST_NAME)))) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_LAST_NAME, Messages.MISSING_LAST_NAME));\n"
"        }\n"
msgstr ""
"if (Validation.isBlank(formData.getFirst((RegistrationPage.FIELD_LAST_NAME)))) {\n"
" errors.add(new FormMessage(RegistrationPage.FIELD_LAST_NAME, Messages.MISSING_LAST_NAME));\n"
" }\n"
"\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        String email = formData.getFirst(Validation.FIELD_EMAIL);\n"
"        if (Validation.isBlank(email)) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.MISSING_EMAIL));\n"
"        } else if (!Validation.isEmailValid(email)) {\n"
"            formData.remove(Validation.FIELD_EMAIL);\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.INVALID_EMAIL));\n"
"        }\n"
msgstr ""
"String email = formData.getFirst(Validation.FIELD_EMAIL);\n"
" if (Validation.isBlank(email)) {\n"
" errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.MISSING_EMAIL));\n"
" } else if (!Validation.isEmailValid(email)) {\n"
" formData.remove(Validation.FIELD_EMAIL);\n"
" errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.INVALID_EMAIL));\n"
" }\n"
"\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        if (context.getSession().users().getUserByEmail(email, context.getRealm()) != null) {\n"
"            formData.remove(Validation.FIELD_EMAIL);\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.EMAIL_EXISTS));\n"
"        }\n"
msgstr ""
"if (context.getSession().users().getUserByEmail(email, context.getRealm()) != null) {\n"
" formData.remove(Validation.FIELD_EMAIL);\n"
" errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.EMAIL_EXISTS));\n"
" }\n"
"\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        if (errors.size() > 0) {\n"
"            context.validationError(formData, errors);\n"
"            return;\n"
msgstr ""
"if (errors.size() > 0) {\n"
" context.validationError(formData, errors);\n"
" return;\n"
"\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        } else {\n"
"            context.success();\n"
"        }\n"
"    }\n"
msgstr ""
"} else {\n"
" context.success();\n"
" }\n"
" }\n"
"\n"

#. type: Plain text
msgid ""
"As you can see, this validate() method of user profile processing makes sure"
" that the email, first, and last name are filled in in the form.  It also "
"makes sure that email is in the right format.  If any of these validations "
"fail, an error message is queued up for rendering.  Any fields in error are "
"removed from the form data.  Error messages are represented by the "
"FormMessage class.  The first parameter of the constructor of this class "
"takes the HTML element id.  The input in error will be highlighted when the "
"form is re-rendered.  The second parameter is a message reference id.  This "
"id must correspond to a property in one of the localized message bundle "
"files.  in the theme."
msgstr ""
"上記に示されている通り、ユーザー・プロファイル処理のvalidate()メソッドにより、まず電子メール、次に苗字がフォーム内に入力されていることが確認されます。また、電子メールが正しいフォーマットであることも確認されます。これらの検証のいずれか1つでも失敗した場合、エラーメッセージがレンダリング用にキューに入れられます。エラー内のフィールドは、フォームデータから削除されます。エラーメッセージは、FormMessageクラスによって表されます。このクラスのコンストラクターでの最初のパラメーターにより、HTML要素idが取得されます。フォームが再レンダリングされる時に、エラー入力がハイライトされます。2番目のパラメーターはメッセージ参照idです。このidは、テーマ内でローカライズされたメッセージ・バンドル・ファイルのいずれかのプロパティに対応している必要があります。"

#. type: Plain text
msgid ""
"After all validations have been processed then, the form flow then invokes "
"the FormAction.success() method.  For recaptcha this is a no-op, so we won't"
" go over it.  For user profile processing, this method fills in values in "
"the registered user."
msgstr ""
"バリデーションがすべて処理された後、フォームフローは次にFormAction.success()メソッドを呼び出します。これはrecaptcha用で、オプションはありませんので、これについて説明はしません。ユーザー・プロファイルを処理するために、このメソッドによって、値が登録ユーザーに入力されます。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void success(FormContext context) {\n"
"        UserModel user = context.getUser();\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        user.setFirstName(formData.getFirst(RegistrationPage.FIELD_FIRST_NAME));\n"
"        user.setLastName(formData.getFirst(RegistrationPage.FIELD_LAST_NAME));\n"
"        user.setEmail(formData.getFirst(RegistrationPage.FIELD_EMAIL));\n"
"    }\n"
msgstr ""
"@Override\n"
" public void success(FormContext context) {\n"
" UserModel user = context.getUser();\n"
" MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
" user.setFirstName(formData.getFirst(RegistrationPage.FIELD_FIRST_NAME));\n"
" user.setLastName(formData.getFirst(RegistrationPage.FIELD_LAST_NAME));\n"
" user.setEmail(formData.getFirst(RegistrationPage.FIELD_EMAIL));\n"
" }\n"

#. type: Plain text
msgid ""
"Pretty simple implementation.  The UserModel of the newly registered user is"
" obtained from the FormContext.  The appropriate methods are called to "
"initialize UserModel data."
msgstr ""
"非常に簡単な実装です。新しく登録されたユーザーのUserModelは、FormContextから取得されます。適切なメソッドが呼び出され、UserModelデータが初期化されます。"

#. type: Plain text
msgid ""
"Finally, you are also required to define a FormActionFactory class.  This "
"class is implemented similarly to AuthenticatorFactory, so we won't go over "
"it."
msgstr ""
"最後に、またFormActionFactoryクラスの定義が必要です。このクラスは、AuthenticatorFactoryと同じように実装されますので、これについて説明はしません。"

#. type: Title ====
#, no-wrap
msgid "Packaging the Action"
msgstr "動作のパッケージ化"

#. type: Plain text
#, no-wrap
msgid ""
"You will package your classes within a single jar.\n"
"This jar must contain a file named  `org.keycloak.authentication.FormActionFactory`                and must be contained in the `META-INF/services/` directory of your jar.\n"
"This file must list the fully qualified classname of each FormActionFactory implementation you have in the jar.\n"
"For example: \n"
msgstr ""
"1つのjar内でクラスをパッケージ化します。\n"
"このjarは `org.keycloak.authentication.FormActionFactory` という名前のファイルを含んでいる必要があり、jarの `META-INF/services/` ディレクトリ内に含まれている必要があります。\n"
"このファイルには、jar内にある各FormActionFactory実装の完全修飾クラス名がリストされている必要があります。 例えば、以下の通りです。\n"

#. type: delimited block -
#, no-wrap
msgid ""
"org.keycloak.authentication.forms.RegistrationProfile\n"
"org.keycloak.authentication.forms.RegistrationRecaptcha\n"
msgstr ""
"org.keycloak.authentication.forms.RegistrationProfile\n"
"org.keycloak.authentication.forms.RegistrationRecaptcha\n"

#. type: Title ====
#, no-wrap
msgid "Adding FormAction to the Registration Flow"
msgstr "登録フローへのFormAction追加"

#. type: Plain text
msgid ""
"Adding an FormAction to a registration page flow must be done in the admin "
"console.  If you go to the Authentication menu item and go to the Flow tab, "
"you will be able to view the currently defined flows.  You cannot modify an "
"built in flows, so, to add the Authenticator we've created you have to copy "
"an existing flow or create your own.  I'm hoping the UI is intuitive enough "
"so that you can figure out for yourself how to create a flow and add the "
"FormAction."
msgstr ""
"FormActionの登録ページ・フローへの追加は管理コンソール内で行われる必要があります。 "
"Authenticationメニュー項目へ移動してFlowタブを選択すると、現在定義されているフローが表示されます。組み込みのフローは変更することはできませんので、作成したオーセンティケーターを追加するには、既存のフローをコピーするか独自のフローを作成する必要があります。このUIは非常に分かりやすく作られているので、フローを作成してFormActionを追加する方法が直感的に分かるようになっていれば良いと思っています。"

#. type: Plain text
msgid ""
"Basically you'll have to copy the registration flow.  Then click Actions "
"menu to the right of the Registration Form, and pick \"Add Execution\" to "
"add a new execution.  You'll pick the FormAction from the selection list.  "
"Make sure your FormAction comes after \"Registration User Creation\" by "
"using the down errors to move it if your FormAction isn't already listed "
"after \"Registration User Creation\".  You want your FormAction to come "
"after user creation because the success() method of Regsitration User "
"Creation is responsible for creating the new UserModel."
msgstr ""
"基本的には、登録フローをコピーする必要があります。次に、登録フォームの右側にあるActionsメニューをクリックし、 \"Add Execution\""
" を選択して新しい実行を追加します。選択リストからFormActionを選択します。FormActionが \"登録ユーザー作成\" "
"の後にリストされていない場合は、ダウンエラーを使用してそれを移動させることにより、FormActionが \"登録ユーザー作成\" "
"の後に表示されることを確認してください。登録ユーザー作成のsuccess()メソッドが新しいUserModelの作成を担当しているため、FormActionはユーザー作成の後に表示される必要があるのです。"
" "

#. type: Plain text
msgid ""
"After you've created your flow, you have to bind it to registration.  If you"
" go to the Authentication menu and go to the Bindings tab you will see "
"options to bind a flow to the browser, registration, or direct grant flow."
msgstr ""
"フローを作成した後、そのフローを登録にバインドする必要があります。Authenticationメニューに移動してBindingsタブを選択すると、フローをブラウザー、登録、またはダイレクト許可フローにバインドするオプションが表示されます。"

#. type: Title ===
#, no-wrap
msgid "Modifying Forgot Password/Credential Flow"
msgstr "パスワードを忘れた場合の変更、またはクレデンシャル・フローの変更"

#. type: Plain text
msgid ""
"Keycloak also has a specific authentication flow for forgot password, or "
"rather credential reset initiated by a user.  If you go to the admin console"
" flows page, there is a \"reset credentials\" flow.  By default, Keycloak "
"asks for the email or username of the user and sends an email to them.  If "
"the user clicks on the link, then they are able to reset both their password"
" and OTP (if an OTP has been set up).  You can disable automatic OTP reset "
"by disabling the \"Reset OTP\" authenticator in the flow."
msgstr ""
"また、Keycloakには、パスワードを忘れた時のための特定の認証フロー、ユーザーによって新しく作成されたクレデンシャル・リセットまであります。管理コンソールのフローページに移動すると、"
" \"クレデンシャルのリセット\" "
"フローがあります。Keycloakでは、デフォルトで、ユーザーの電子メールまたはユーザー名が要求され、ユーザーに電子メールが送信されます。ユーザーがリンクをクリックすると、パスワードとOTP（OTPが設定されている場合）の両方をリセットすることができます。フロー"
" \"OTPのリセット\" オーセンティケーターを無効にすると、自動OTPリセットを無効にすることができます。"

#. type: Plain text
msgid ""
"You can add additional functionality to this flow as well.  For example, "
"many deployments would like for the user to answer one or more secret "
"questions in additional to sending an email with a link.  You could expand "
"on the secret question example that comes with the distro and incorporate it"
" into the reset credential flow."
msgstr ""
"同じように、このフローに追加の機能を加えることができます。例えば、デプロイメントでは、リンクを含む電子メールの送信に加え、ユーザーによる1つまたは複数の秘密の質問に対する回答を必要とすることが多いです。配布物に付属する秘密の質問のサンプルを拡張し、クレデンシャル・リセット・フローに組み込むことができます。"

#. type: Plain text
msgid ""
"One thing to note if you are extending the reset credentials flow.  The "
"first \"authenticator\" is just a page to obtain the username or email.  If "
"the username or email exists, then the AuthenticationFlowContext.getUser() "
"will return the located user.  Otherwise this will be null.  This form *WILL"
" NOT* re-ask the user to enter in an email or username if the previous email"
" or username did not exist.  You need to prevent attackers from being able "
"to guess valid users.  So, if AuthenticationFlowContext.getUser() returns "
"null, you should proceed with the flow to make it look like a valid user was"
" selected.  I suggest that if you want to add secret questions to this flow,"
" you should ask these questions after the email is sent.  In other words, "
"add your custom authenticator after the \"Send Reset Email\" authenticator."
msgstr ""
"クレデンシャル・リセット・フローを拡張する場合、1つ注意点があります。最初の \"オーセンティケーター\" "
"は、単にユーザー名と電子メールを取得するためだけのページです。ユーザー名と電子メールが既にある場合、AuthenticationFlowContext.getUser()はその既存のユーザーを返します。これ以外の場合は、無効になります。このフォームにより、以前の電子メールまたはユーザー名が存在しない場合、ユーザーは電子メールまたはユーザー名を入力するように"
" *再度要求はされません* "
"。攻撃者が有効なユーザーを推測できないようにする必要があるので、AuthenticationFlowContext.getUser()が無効を返した場合、フローを続行し、有効なユーザーが選択されたかのように見せかける必要があります。このフローへの秘密の質問を追加する必要がある場合は、電子メールの送信後にこれらの質問をすることをおすすめします。つまり、"
" \"リセット電子メールの送信\" オーセンティケーターの後に、カスタム・オーセンティケーターを追加してください。"

#. type: Title ===
#, no-wrap
msgid "Modifying First Broker Login Flow"
msgstr "First Brokerログイン・フローの変更"

#. type: Plain text
msgid ""
"First Broker Login flow is used during first login with some identity "
"provider.  Term `First Login` means that there is not yet existing "
"{project_name} account linked with the particular authenticated identity "
"provider account.  For more details about this flow see the `Identity "
"Brokering` chapter in link:{adminguide_link}[{adminguide_name}] ."
msgstr ""
"First Brokerのログイン・フローは、アイデンティティー・プロバイダーに最初にログインした時に使用されるものです。 `First Login` "
"という用語は、特定の認証されたアイデンティティー・プロバイダー・アカウントにリンクされている{project_name}アカウントがまだ存在していないことを意味します。このフローについて詳しくはlink:{adminguide_link}[{adminguide_name}]内の"
" `Identity Brokering` 章を参照ください。"

#. type: Title ===
#, no-wrap
msgid "Authentication of clients"
msgstr "クライアント認証"

#. type: Plain text
msgid ""
"{project_name} actually supports pluggable authentication for "
"http://openid.net/specs/openid-connect-core-1_0.html[OpenID Connect] client "
"applications.  Authentication of client (application) is used under the hood"
" by the {project_name} adapter during sending any backchannel requests to "
"the {project_name} server (like the request for exchange code to access "
"token after successful authentication or request to refresh token).  But the"
" client authentication can be also used directly by you during `Direct "
"Access grants` (represented by OAuth2 `Resource Owner Password Credentials "
"Flow`)  or during `Service account` authentication (represented by OAuth2 "
"`Client Credentials Flow`)."
msgstr ""
"{project_name}は実際には、http://openid.net/specs/openid-connect-core-"
"1_0.html[OpenID "
"Connect]クライアント・アプリケーションのためのプラグイン可能な認証をサポートしています。クライアント（アプリケーション）の認証は、（認証またはリフレッシュ・トークンの要求が成功した後に、アクセス・トークンに交換コードをリクエストするのと同じように）バックチャネル・リクエストを{project_name}サーバーに送信する間、{project_name}アダプターにより表示はされないながら実質的に使用されます。しかし、"
" `Direct Access grants` （OAuth2により表される `Resource Owner Password Credentials "
"Flow` ）または `Service account` 認証（OAuth2により表される `Client Credentials Flow` "
"）の間は、クライアント認証を直接使用することも可能です。"

#. type: Plain text
msgid ""
"For more details about {project_name} adapter and OAuth2 flows see "
"link:{adapterguide_link}[{adapterguide_name}]."
msgstr ""
"{project_name}アダプターとOAuth2フローについて、詳しくはlink:{adapterguide_link}[{adapterguide_name}]を参照ください。"

#. type: Title ====
#, no-wrap
msgid "Default implementations"
msgstr "デフォルト実装"

#. type: Plain text
msgid ""
"Actually Keycloak has 2 builtin implementations of client authentication:"
msgstr "Keycloakには、実際のところ以下の通り、クライアント認証の実装が2つ組み込まれています。"

#. type: Labeled list
#, no-wrap
msgid "Traditional authentication with client_id and client_secret"
msgstr "client_idとclient_secretによる従来の認証"

#. type: Plain text
#, no-wrap
msgid ""
"This is default mechanism mentioned in the http://openid.net/specs/openid-connect-core-1_0.html[OpenID Connect]                                or https://tools.ietf.org/html/rfc6749[OAuth2] specification and Keycloak supports it since it's early days.\n"
"The public client needs to include `client_id` parameter with it's ID in the POST request (so it's defacto not authenticated) and the confidential client needs to include `Authorization: Basic` header with the clientId and clientSecret used as username and password. \n"
msgstr ""
"これは、http://openid.net/specs/openid-connect-core-1_0.html[OpenID Connect]またはhttps://tools.ietf.org/html/rfc6749[OAuth2]の仕様で説明したデフォルトのメカニズムで、これはKeycloakによって早い段階からサポートされています。\n"
"パブリック・クライアントには、POSTリクエスト内にIDを持つ `client_id` パラメーターが含まれている必要があり（そのため実際は認証されていません）、コンフィデンシャル・クライアントには、ユーザ名とパスワードとして使用されるclientIdとclientSecretを持つ `Authorization: Basic` ヘッダーが含まれている必要があります。\n"

#. type: Labeled list
#, no-wrap
msgid "Authentication with signed JWT"
msgstr "署名付きのJWTによる認証"

#. type: Plain text
#, no-wrap
msgid ""
"This is based on the https://tools.ietf.org/html/rfc7523[JWT Bearer Token Profiles for OAuth 2.0] specification.\n"
"The client/adapter generates the https://tools.ietf.org/html/rfc7519[JWT] and signs it with his private key.\n"
"The Keycloak then verifies the signed JWT with the client's public key and authenticates client based on it.             \n"
msgstr ""
"これはhttps://tools.ietf.org/html/rfc7523[JWT Bearer Token Profiles for OAuth 2.0]仕様に基づいています。\n"
"クライアントまたはアダプターがhttps://tools.ietf.org/html/rfc7519[JWT]を生成し、秘密鍵で署名します。\n"
"次に、Keycloakにより、クライアントの公開鍵で署名付きのJWTを検証し、それに基づいてクライアントを認証します。 \n"

#. type: Plain text
msgid ""
"See the demo example and especially the `examples/preconfigured-demo"
"/product-app` for the example application showing the application using "
"client authentication with signed JWT."
msgstr ""
"デモのサンプル、および署名付きのJWTによるクライアント認証を使用するアプリケーションを表示するアプリケーションのサンプル用には、特に "
"`examples/preconfigured-demo/product-app` を参照ください。"

#. type: Title ====
#, no-wrap
msgid "Implement your own client authenticator"
msgstr "独自のクライアント・オーセンティケーターの実装"

#. type: Plain text
msgid ""
"For plug your own client authenticator, you need to implement few interfaces"
" on both client (adapter) and server side."
msgstr ""
"独自のクライアント・オーセンティケーターをプラグインするには、クライアント（アダプター）とサーバー側の両方にインターフェースを少し実装する必要があります。"

#. type: Labeled list
#, no-wrap
msgid "Client side"
msgstr "クライアント側"

#. type: Plain text
msgid ""
"Here you need to implement "
"`org.keycloak.adapters.authentication.ClientCredentialsProvider` and put the"
" implementation either to:"
msgstr ""
"ここでは `org.keycloak.adapters.authentication.ClientCredentialsProvider` "
"を実装し、以下にその実装を置く必要があります。"

#. type: Plain text
msgid ""
"your WAR file into WEB-INF/classes . But in this case, the implementation "
"can be used just for this single WAR application"
msgstr ""
"WEB-INF/classes内のWARファイル。ただし、この場合、実装はこの1つのWARアプリケーションのためだけに使用することができます。"

#. type: Plain text
msgid "Some JAR file, which will be added into WEB-INF/lib of your WAR"
msgstr "WARのWEB-INF/libに追加されるJARファイル"

#. type: Plain text
#, no-wrap
msgid ""
"Some JAR file, which will be used as jboss module and configured in jboss-"
"deployment-structure.xml of your WAR.                                In all "
"cases, you also need to create the file `META-"
"INF/services/org.keycloak.adapters.authentication.ClientCredentialsProvider`"
"                                either in the WAR or in your JAR. \n"
msgstr ""
"jbossモジュールとして使用され、WARのjboss-deployment-structure.xml内で設定される、JARファイル。 "
"いずれの場合でも、WARまたはJARのいずれかに `META-"
"INF/services/org.keycloak.adapters.authentication.ClientCredentialsProvider`"
" ファイルを作成する必要もあります。\n"

#. type: Labeled list
#, no-wrap
msgid "Server side"
msgstr "サーバー側"

#. type: Plain text
#, no-wrap
msgid ""
"Here you need to implement `org.keycloak.authentication.ClientAuthenticatorFactory` and `org.keycloak.authentication.ClientAuthenticator` . You also need to add the file `META-INF/services/org.keycloak.authentication.ClientAuthenticatorFactory` with the name of the implementation classes.\n"
"See <<_auth_spi_walkthrough,authenticators>> for more details.             \n"
msgstr ""
"ここでは、 `org.keycloak.authentication.ClientAuthenticatorFactory` と  `org.keycloak.authentication.ClientAuthenticator` を実装する必要があります。また `META-INF/services/org.keycloak.authentication.ClientAuthenticatorFactory` ファイルを実装クラス名を使用して追加する必要があります。\n"
"詳しくは <<_auth_spi_walkthrough,authenticators>> を参照ください。             \n"
