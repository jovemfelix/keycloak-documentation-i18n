# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Nomura Research Institute, Ltd.
# This file is distributed under the same license as the keycloak-documentation-i18n package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Tsukasa Amano <t.amano@pro-japan.co.jp>, 2017
# Kohei Tamura <ktamura.biz.80@gmail.com>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n\n"
"Last-Translator: Kohei Tamura <ktamura.biz.80@gmail.com>, 2019\n"
"Language-Team: Japanese (Japan) (https://www.transifex.com/openstandia/teams/79437/ja_JP/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja_JP\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Labeled list
#, no-wrap
msgid "client_id"
msgstr "client_id"

#. type: Title ===
#, no-wrap
msgid "Client Initiated Account Linking"
msgstr "Client Initiated Account Linking"

#. type: Plain text
msgid ""
"Some applications want to integrate with social providers like Facebook, but"
" do not want to provide an option to login via these social providers.  "
"{project_name} offers a browser-based API that applications can use to link "
"an existing user account to a specific external IDP.  This is called client-"
"initiated account linking. Account linking can only be initiated by OIDC "
"applications."
msgstr ""
"アプリケーションの中には、Facebookなどのソーシャル・プロバイダーと統合したいが、これらのソーシャル・プロバイダーを介してログインするオプションを提供したくないものもあります。{project_name}は、既存のユーザー・アカウントを特定の外部IDPにリンクするためにアプリケーションが使用できる、ブラウザー・ベースのAPIを提供しています。これは"
"、Client-Initiated Account "
"Linkingと呼ばれます。アカウント・リンキングは、OIDCアプリケーションによってのみ開始できます。"

#. type: Plain text
msgid ""
"The way it works is that the application forwards the user's browser to a "
"URL on the {project_name} server requesting that it wants to link the user's"
" account to a specific external provider (i.e. Facebook).  The server "
"initiates a login with the external provider.  The browser logs in at the "
"external provider and is redirected back to the server.  The server "
"establishes the link and redirects back to the application with a "
"confirmation."
msgstr ""
"これを動作させるには、アプリケーションがユーザーのブラウザーを{project_name}サーバー上のURLに転送して、ユーザーのアカウントを特定の外部プロバイダー（Facebookなど）にリンクすることを要求します。サーバーは、外部プロバイダーとのログインを開始します。ブラウザーは外部プロバイダーにログインし、サーバーにリダイレクトされます。サーバーはリンクを確立し、確認のためにアプリケーションにリダイレクトします。"

#. type: Plain text
msgid ""
"There are some preconditions that must be met by the client application "
"before it can initiate this protocol:"
msgstr "このプロトコルを開始する上で、クライアント・アプリケーションが満たさなければならない、いくつかの前提条件があります。"

#. type: Plain text
msgid ""
"The desired identity provider must be configured and enabled for the user's "
"realm in the admin console."
msgstr "管理コンソールで、必要なアイデンティティー・プロバイダーを設定し、ユーザーのレルムに対して有効にする必要がある。"

#. type: Plain text
msgid ""
"The user account must already be logged in as an existing user via the OIDC "
"protocol"
msgstr "ユーザー・アカウントは、OIDCプロトコルを介して既存のユーザーとしてログインしている必要がある。"

#. type: Plain text
msgid ""
"The user must have an `account.manage-account` or `account.manage-account-"
"links` role mapping."
msgstr ""
"ユーザーには `account.manage-account` または `account.manage-account-links` "
"のロールマッピングがなければならない。"

#. type: Plain text
msgid ""
"The application must be granted the scope for those roles within its access "
"token"
msgstr "アプリケーションは、アクセストークン内にあるそれらのロールのスコープを許可されている必要がある。"

#. type: Plain text
msgid ""
"The application must have access to its access token as it needs information"
" within it to generate the redirect URL."
msgstr "アプリケーションは、リダイレクトURLを生成するために情報が必要なので、アクセストークンにアクセスする必要がある"

#. type: Plain text
msgid ""
"To initiate the login, the application must fabricate a URL and redirect the"
" user's browser to this URL.  The URL looks like this:"
msgstr ""
"ログインを開始するには、アプリケーションがURLを作成し、ユーザーのブラウザーをこのURLにリダイレクトする必要があります。URLは次のようになります。"

#. type: delimited block -
#, no-wrap
msgid ""
"/{auth-server-"
"root}/auth/realms/{realm}/broker/{provider}/link?client_id={id}&redirect_uri={uri}&nonce={nonce}&hash={hash}\n"
msgstr ""
"/{auth-server-"
"root}/auth/realms/{realm}/broker/{provider}/link?client_id={id}&redirect_uri={uri}&nonce={nonce}&hash={hash}\n"

#. type: Plain text
msgid "Here's a description of each path and query param:"
msgstr "各パスとクエリー・パラメータの説明は次のとおりです。"

#. type: Labeled list
#, no-wrap
msgid "provider"
msgstr "provider"

#. type: Plain text
msgid ""
"This is the provider alias of the external IDP that you defined in the "
"`Identity Provider` section of the admin console."
msgstr "管理コンソールの `アイデンティティー・プロバイダー` のセクションで定義した外部IDPのプロバイダー・エイリアスです。"

#. type: Plain text
msgid ""
"This is the OIDC client id of your application.  When you registered the "
"application as a client in the admin console, you had to specify this client"
" id."
msgstr ""
"アプリケーションのOIDCクライアントIDです。管理コンソールでアプリケーションをクライアントとして登録したときに、このクライアントIDを指定する必要があります。"

#. type: Labeled list
#, no-wrap
msgid "redirect_uri"
msgstr "redirect_uri"

#. type: Plain text
msgid ""
"This is the application callback URL you want to redirect to after the "
"account link is established.  It must be a valid client redirect URI "
"pattern.  In other words, it must match one of the valid URL patterns you "
"defined when you registered the client in the admin console."
msgstr ""
"アカウントのリンクが確立された後にリダイレクトするアプリケーションのコールバックURLです。有効なクライアント・リダイレクトURIパターンでなければなりません。つまり、管理コンソールでクライアントを登録したときに定義した有効なURLパターンの1つと一致する必要があります。"

#. type: Labeled list
#, no-wrap
msgid "nonce"
msgstr "nonce"

#. type: Plain text
msgid "This is a random string that your application must generate"
msgstr "アプリケーションが生成しなければならないランダムな文字列です。"

#. type: Labeled list
#, no-wrap
msgid "hash"
msgstr "hash"

#. type: Plain text
msgid ""
"This is a Base64 URL encoded hash.  This hash is generated by Base64 URL "
"encoding a SHA_256 hash of `nonce` + `token.getSessionState()` + "
"`token.getIssuedFor()` + `provider`.  The token variable are obtained from "
"the OIDC access token.  Basically you are hashing the random nonce, the user"
" session id, the client id, and the identity provider alias you want to "
"access."
msgstr ""
"Base64 URLでエンコードされたハッシュです。このハッシュは、 `nonce` + `token.getSessionState()` + "
"`token.getIssuedFor()` + `provider` のSHA_256ハッシュでエンコードされたBase64 "
"URLによって生成されます。トークン変数はOIDCのアクセストークンから取得されます。基本的には、ランダムなnonce、ユーザーセッションID、クライアントID、およびアクセスするアイデンティティー・プロバイダーのエイリアスをハッシュしています。"

#. type: Plain text
msgid ""
"Here's an example of Java Servlet code that generates the URL to establish "
"the account link."
msgstr "次に、アカウントリンクを確立するためのURLを生成するJavaサーブレット・コードの例を示します。"

#. type: delimited block -
#, no-wrap
msgid ""
"   KeycloakSecurityContext session = (KeycloakSecurityContext) httpServletRequest.getAttribute(KeycloakSecurityContext.class.getName());\n"
"   AccessToken token = session.getToken();\n"
"   String clientId = token.getIssuedFor();\n"
"   String nonce = UUID.randomUUID().toString();\n"
"   MessageDigest md = null;\n"
"   try {\n"
"      md = MessageDigest.getInstance(\"SHA-256\");\n"
"   } catch (NoSuchAlgorithmException e) {\n"
"      throw new RuntimeException(e);\n"
"   }\n"
"   String input = nonce + token.getSessionState() + clientId + provider;\n"
"   byte[] check = md.digest(input.getBytes(StandardCharsets.UTF_8));\n"
"   String hash = Base64Url.encode(check);\n"
"   request.getSession().setAttribute(\"hash\", hash);\n"
"   String redirectUri = ...;\n"
"   String accountLinkUrl = KeycloakUriBuilder.fromUri(authServerRootUrl)\n"
"                    .path(\"/auth/realms/{realm}/broker/{provider}/link\")\n"
"                    .queryParam(\"nonce\", nonce)\n"
"                    .queryParam(\"hash\", hash)\n"
"                    .queryParam(\"client_id\", clientId)\n"
"                    .queryParam(\"redirect_uri\", redirectUri).build(realm, provider).toString();\n"
msgstr ""
"   KeycloakSecurityContext session = (KeycloakSecurityContext) httpServletRequest.getAttribute(KeycloakSecurityContext.class.getName());\n"
"   AccessToken token = session.getToken();\n"
"   String clientId = token.getIssuedFor();\n"
"   String nonce = UUID.randomUUID().toString();\n"
"   MessageDigest md = null;\n"
"   try {\n"
"      md = MessageDigest.getInstance(\"SHA-256\");\n"
"   } catch (NoSuchAlgorithmException e) {\n"
"      throw new RuntimeException(e);\n"
"   }\n"
"   String input = nonce + token.getSessionState() + clientId + provider;\n"
"   byte[] check = md.digest(input.getBytes(StandardCharsets.UTF_8));\n"
"   String hash = Base64Url.encode(check);\n"
"   request.getSession().setAttribute(\"hash\", hash);\n"
"   String redirectUri = ...;\n"
"   String accountLinkUrl = KeycloakUriBuilder.fromUri(authServerRootUrl)\n"
"                    .path(\"/auth/realms/{realm}/broker/{provider}/link\")\n"
"                    .queryParam(\"nonce\", nonce)\n"
"                    .queryParam(\"hash\", hash)\n"
"                    .queryParam(\"client_id\", clientId)\n"
"                    .queryParam(\"redirect_uri\", redirectUri).build(realm, provider).toString();\n"

#. type: Plain text
msgid ""
"Why is this hash included? We do this so that the auth server is guaranteed "
"to know that the client application initiated the request and no other rogue"
" app just randomly asked for a user account to be linked to a specific "
"provider.  The auth server will first check to see if the user is logged in "
"by checking the SSO cookie set at login.  It will then try to regenerate the"
" hash based on the current login and match it up to the hash sent by the "
"application."
msgstr ""
"このハッシュはなぜ含まれるのでしょうか？これにより、認証サーバーはクライアント・アプリケーションが要求を開始したことと、ユーザー・アカウントが特定のプロバイダーにリンクされることをランダムに要求する悪意のあるアプリケーションが無いことを保証します。認証サーバーはまず、ログイン時に設定されたSSO"
" "
"Cookieをチェックして、ユーザーがログインしているかどうかを確認します。次に、現在のログインに基づいてハッシュを再生成し、アプリケーションによって送信されたハッシュと一致するか確認します。"

#. type: Plain text
msgid ""
"After the account has been linked, the auth server will redirect back to the"
" `redirect_uri`.  If there is a problem servicing the link request, the auth"
" server may or may not redirect back to the `redirect_uri`.  The browser may"
" just end up at an error page instead of being redirected back to the "
"application.  If there is an error condition and the auth server deems it "
"safe enough to redirect back to the client app, an additional `error` query "
"parameter will be appended to the `redirect_uri`."
msgstr ""
"アカウントがリンクされると、認証サーバーは `redirect_uri` にリダイレクトします。リンクリクエストの処理に問題がある場合、認証サーバーが "
"`redirect_uri` "
"にリダイレクトされる保障はありません。ブラウザーはアプリケーションにリダイレクトされるのではなく、エラーページにリダイレクトされることがあります。何らかのエラー状態があり、認証サーバーがクライアント・アプリケーションにリダイレクトするのに十分安全であると判断した場合、"
" `error` クエリー・パラメーターが `redirect_uri` に追加されます。"

#. type: Plain text
#, no-wrap
msgid ""
"   While this API guarantees that the application initiated the request, it does not completely prevent CSRF attacks for this operation.  The application\n"
"   is still responsible for guarding against CSRF attacks target at itself.\n"
msgstr ""
"このAPIはアプリケーションが要求を開始したことを保証しますが、この操作に対するCSRF攻撃を完全に防止するわけではありません。このアプリケーションは、依然としてCSRFの攻撃のターゲットに対する防御の責任があります。\n"

#. type: Title ====
#, no-wrap
msgid "Refreshing External Tokens"
msgstr "外部トークンのリフレッシュ"

#. type: Plain text
msgid ""
"If you are using the external token generated by logging into the provider "
"(i.e. a Facebook or GitHub token), you can refresh this token by re-"
"initiating the account linking API."
msgstr ""
"プロバイダーにログインして生成した外部トークン（FacebookやGitHubトークンなど）を使用している場合は、Account Linking "
"APIを再起動することで、このトークンを更新できます。"
