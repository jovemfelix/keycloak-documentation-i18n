# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Nomura Research Institute, Ltd.
# This file is distributed under the same license as the keycloak-documentation-i18n package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n  \n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: delimited block -
#, no-wrap
msgid "    }\n"
msgstr ""

#. type: Title ====
#, no-wrap
msgid "Packaging Classes and Deployment"
msgstr ""

#. type: Title ==
#, no-wrap
msgid "Authentication SPI"
msgstr ""

#. type: Plain text
msgid ""
"{project_name} comes out of the box with a bunch of different authentication "
"mechanisms: kerberos, password, and otp.  These mechanisms may not meet all "
"of your requirements and you may want to plug in your own custom ones.  "
"{project_name} provides an authentication SPI that you can use to write new "
"plugins.  The admin console supports applying, ordering, and configuring "
"these new mechanisms."
msgstr ""

#. type: Plain text
msgid ""
"{project_name} also supports a simple registration form.  Different aspects "
"of this form can be enabled and disabled i.e.  Recaptcha support can be "
"turned off and on.  The same authentication SPI can be used to add another "
"page to the registration flow or reimplement it entirely.  There's also an "
"additional fine-grained SPI you can use to add specific validations and user "
"extensions to the built in registration form."
msgstr ""

#. type: Plain text
msgid ""
"A required action in {project_name} is an action that a user has to perform "
"after he authenticates.  After the action is performed successfully, the "
"user doesn't have to perform the action again.  {project_name} comes with "
"some built in required actions like \"reset password\".  This action forces "
"the user to change their password after they have logged in.  You can write "
"and plug in your own required actions."
msgstr ""

#. type: Title ===
#, no-wrap
msgid "Terms"
msgstr ""

#. type: Plain text
msgid ""
"To first learn about the Authentication SPI, let's go over some of the terms "
"used to describe it."
msgstr ""

#. type: Labeled list
#, no-wrap
msgid "Authentication Flow"
msgstr ""

#. type: Plain text
msgid ""
"A flow is a container for all authentications that must happen during login "
"or registration.  If you go to the admin console authentication page, you "
"can view all the defined flows in the system and what authenticators they "
"are made up of.  Flows can contain other flows.  You can also bind a new "
"different flow for browser login, direct grant access, and registration."
msgstr ""

#. type: Labeled list
#, no-wrap
msgid "Authenticator"
msgstr ""

#. type: Plain text
msgid ""
"An authenticator is a pluggable component that hold the logic for performing "
"the authentication or action within a flow.  It is usually a singleton."
msgstr ""

#. type: Labeled list
#, no-wrap
msgid "Execution"
msgstr ""

#. type: Plain text
msgid ""
"An execution is an object that binds the authenticator to the flow and the "
"authenticator to the configuration of the authenticator.  Flows contain "
"execution entries."
msgstr ""

#. type: Labeled list
#, no-wrap
msgid "Execution Requirement"
msgstr ""

#. type: Plain text
msgid ""
"Each execution defines how an authenticator behaves in a flow.  The "
"requirement defines whether the authenticator is enabled, disabled, "
"conditional, required, or an alternative.  An alternative requirement means "
"that the authenticator is enough to validate the flow it's in, but isn't "
"necessary.  For example, in the built-in browser flow, cookie "
"authentication, the Identity Provider Redirector, and the set of all "
"authenticators in the forms subflow are all alternative. As they are "
"executed in a sequential top-to-bottom order, if one of them is successful, "
"the flow is successful, and any following execution in the flow (or sub-"
"flow) is not evaluated."
msgstr ""

#. type: Labeled list
#, no-wrap
msgid "Authenticator Config"
msgstr ""

#. type: Plain text
msgid ""
"This object defines the configuration for the Authenticator for a specific "
"execution within an authentication flow.  Each execution can have a "
"different config."
msgstr ""

#. type: Labeled list
#, no-wrap
msgid "Required Action"
msgstr ""

#. type: Plain text
msgid ""
"After authentication completes, the user might have one or more one-time "
"actions he must complete before he is allowed to login.  The user might be "
"required to set up an OTP token generator or reset an expired password or "
"even accept a Terms and Conditions document."
msgstr ""

#. type: Title ===
#, no-wrap
msgid "Algorithm Overview"
msgstr ""

#. type: Plain text
msgid ""
"Let's talk about how this all works for browser login.  Let's assume the "
"following flows, executions and sub flows."
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Cookie - ALTERNATIVE\n"
"Kerberos - ALTERNATIVE\n"
"Forms subflow - ALTERNATIVE\n"
"           Username/Password Form - REQUIRED\n"
"           Conditional OTP subflow - CONDITIONAL\n"
"                      Condition - User Configured - REQUIRED\n"
"                      OTP Form - REQUIRED\n"
msgstr ""

#. type: Plain text
msgid ""
"In the top level of the form we have 3 executions of which all are "
"alternatively required.  This means that if any of these are successful, "
"then the others do not have to execute.  The Username/Password form is not "
"executed if there is an SSO Cookie set or a successful Kerberos login.  "
"Let's walk through the steps from when a client first redirects to keycloak "
"to authenticate the user."
msgstr ""

#. type: Plain text
msgid ""
"The OpenID Connect or SAML protocol provider unpacks relevant data, verifies "
"the client and any signatures.  It creates an AuthenticationSessionModel.  "
"It looks up what the browser flow should be, then starts executing the flow."
msgstr ""

#. type: Plain text
msgid ""
"The flow looks at the cookie execution and sees that it is an alternative.  "
"It loads the cookie provider.  It checks to see if the cookie provider "
"requires that a user already be associated with the authentication session.  "
"Cookie provider does not require a user.  If it did, the flow would abort "
"and the user would see an error screen.  Cookie provider then executes.  Its "
"purpose is to see if there is an SSO cookie set.  If there is one set, it is "
"validated and the UserSessionModel is verified and associated with the "
"AuthenticationSessionModel.  The Cookie provider returns a success() status "
"if the SSO cookie exists and is validated.  Since the cookie provider "
"returned success and each execution at this level of the flow is "
"ALTERNATIVE, no other execution is executed and this results in a successful "
"login.  If there is no SSO cookie, the cookie provider returns with a status "
"of attempted().  This means there was no error condition, but no success "
"either.  The provider tried, but the request just wasn't set up to handle "
"this authenticator."
msgstr ""

#. type: Plain text
msgid ""
"Next the flow looks at the Kerberos execution.  This is also an "
"alternative.  The kerberos provider also does not require a user to be "
"already set up and associated with the AuthenticationSessionModel so this "
"provider is executed.  Kerberos uses the SPNEGO browser protocol.  This "
"requires a series of challenge/responses between the server and client "
"exchanging negotiation headers.  The kerberos provider does not see any "
"negotiate header, so it assumes that this is the first interaction between "
"the server and client.  It therefore creates an HTTP challenge response to "
"the client and sets a forceChallenge() status.  A forceChallenge() means "
"that this HTTP response cannot be ignored by the flow and must be returned "
"to the client.  If instead the provider returned a challenge() status, the "
"flow would hold the challenge response until all other alternatives are "
"attempted.  So, in this initial phase, the flow would stop and the challenge "
"response would be sent back to the browser.  If the browser then responds "
"with a successful negotiate header, the provider associates the user with "
"the AuthenticationSession and the flow ends because the rest of the "
"executions on this level of the flow are all alternatives.  Otherwise, "
"again, the kerberos provider sets an attempted() status and the flow "
"continues."
msgstr ""

#. type: Plain text
msgid ""
"The next execution is a subflow called Forms.  The executions for this "
"subflow are loaded and the same processing logic occurs."
msgstr ""

#. type: Plain text
msgid ""
"The first execution in the Forms subflow is the UsernamePassword provider.  "
"This provider also does not require for a user to already be associated with "
"the flow.  This provider creates a challenge HTTP response and sets its "
"status to challenge(). This execution is required, so the flow honors this "
"challenge and sends the HTTP response back to the browser.  This response is "
"a rendering of the Username/Password HTML page.  The user enters in their "
"username and password and clicks submit.  This HTTP request is directed to "
"the UsernamePassword provider.  If the user entered an invalid username or "
"password, a new challenge response is created and a status of "
"failureChallenge() is set for this execution.  A failureChallenge() means "
"that there is a challenge, but that the flow should log this as an error in "
"the error log.  This error log can be used to lock accounts or IP Addresses "
"that have had too many login failures.  If the username and password is "
"valid, the provider associated the UserModel with the "
"AuthenticationSessionModel and returns a status of success()."
msgstr ""

#. type: Plain text
msgid ""
"The next execution is a subflow called Conditional OTP. The executions for "
"this subflow are loaded and the same processing logic occurs. Its "
"Requirement is Conditional. This means that the flow will first evaluate all "
"conditional executors that it contains. Conditional executors are "
"authenticators that implement `ConditionalAuthenticator`, and must implement "
"the method `boolean matchCondition(AuthenticationFlowContext context)`. A "
"conditional subflow will call the `matchCondition` method of all conditional "
"executions it contains, and if all of them evaluate to true, it will act as "
"if it was a required subflow. If not, it will act as if it was a disabled "
"subflow. Conditional authenticators are only used for this purpose, and are "
"not used as authenticators.  This means that even if the conditional "
"authenticator evaluates to \"true\", then this will not mark a flow or "
"subflow as successful. For example, a flow containing only a Conditional "
"subflow with only a conditional authenticator will never allow a user to log "
"in."
msgstr ""

#. type: Plain text
msgid ""
"The first execution of the Conditional OTP subflow is the Condition - User "
"Configured.  This provider requires that a user has been associated with the "
"flow.  This requirement is satisfied because the UsernamePassword provider "
"already associated the user with the flow.  This provider's `matchCondition` "
"method will evaluate the `configuredFor` method for all other Authenticators "
"in its current subflow. If the subflow contains executors with their "
"Requirement set to required, then the `matchCondition` method will only "
"evaluate to true if all the required authenticators' `configuredFor` method "
"evaluate to true. Otherwise, the `matchCondition` method will evaluate to "
"true if any alternative authenticator evaluates to true."
msgstr ""

#. type: Plain text
msgid ""
"The next execution is the OTP Form.  This provider also requires that a user "
"has been associated with the flow.  This requirement is satisfied because "
"the UsernamePassword provider already associated the user with the flow.  "
"Since a user is required for this provider, the provider is also asked if "
"the user is configured to use this provider.  If user is not configured, "
"then the flow will then set up a required action that the user must perform "
"after authentication is complete.  For OTP, this means the OTP setup page. "
"If the user is configured, he will be asked to enter his otp code. In our "
"scenario, because of the conditional sub-flow, the user will never see the "
"OTP login page, unless the Conditional OTP subflow is set to Required."
msgstr ""

#. type: Plain text
msgid ""
"After the flow is complete, the authentication processor creates a "
"UserSessionModel and associates it with the AuthenticationSessionModel.  It "
"then checks to see if the user is required to complete any required actions "
"before logging in."
msgstr ""

#. type: Plain text
msgid ""
"First, each required action's evaluateTriggers() method is called.  This "
"allows the required action provider to figure out if there is some state "
"that might trigger the action to be fired.  For example, if your realm has a "
"password expiration policy, it might be triggered by this method."
msgstr ""

#. type: Plain text
msgid ""
"Each required action associated with the user that has its "
"requiredActionChallenge() method called.  Here the provider sets up an HTTP "
"response which renders the page for the required action.  This is done by "
"setting a challenge status."
msgstr ""

#. type: Plain text
msgid ""
"If the required action is ultimately successful, then the required action is "
"removed from the user's required actions list."
msgstr ""

#. type: Plain text
msgid ""
"After all required actions have been resolved, the user is finally logged in."
msgstr ""

#. type: Title ===
#, no-wrap
msgid "Authenticator SPI Walk Through"
msgstr ""

#. type: Plain text
msgid ""
"In this section, we'll take a look at the Authenticator interface.  For "
"this, we are going to implement an authenticator that requires that a user "
"enter in the answer to a secret question like \"What is your mother's maiden "
"name?\".  This example is fully implemented and contained in the examples/"
"providers/authenticator directory of the demo distribution of {project_name}."
msgstr ""

#. type: Plain text
msgid ""
"To create an authenticator, you must at minimum implement the org.keycloak."
"authentication.AuthenticatorFactory and Authenticator interfaces.  The "
"Authenticator interface defines the logic. The AuthenticatorFactory is "
"responsible for creating instances of an Authenticator.  They both extend a "
"more generic Provider and ProviderFactory set of interfaces that other "
"{project_name} components like User Federation do."
msgstr ""

#. type: Plain text
msgid ""
"Some authenticators, like the CookieAuthenticator don't rely on a Credential "
"that the user has or knows to authenticate the user.  However, some "
"authenticators, such as the PasswordForm authenticator or the "
"OTPFormAuthenticator rely on the user inputting some information and "
"verifying that information against some information in the database. For the "
"PasswordForm for example, the authenticator will verify the hash of the "
"password against a hash stored in the database, while the "
"OTPFormAuthenticator will verify the OTP received against the one generated "
"from the shared secret stored in the database."
msgstr ""

#. type: Plain text
msgid ""
"These types of authenticators are called CredentialValidators, and will "
"require you to implement a few more classes:"
msgstr ""

#. type: Plain text
msgid ""
"A class that extends org.keycloak.credential.CredentialModel, and that can "
"generate the correct format of the credential in the database"
msgstr ""

#. type: Plain text
msgid ""
"A class implementing the org.keycloak.credential.CredentialProvider and "
"interface, and a class implementing its CredentialProviderFactory factory "
"interface."
msgstr ""

#. type: Plain text
msgid ""
"The SecretQuestionAuthenticator we'll see in this walk through is a "
"CredentialValidator, so we'll see how to implement all these classes."
msgstr ""

#. type: Plain text
msgid ""
"You will package your classes within a single jar.  This jar must contain a "
"file named `org.keycloak.authentication.AuthenticatorFactory` and must be "
"contained in the `META-INF/services/` directory of your jar.  This file must "
"list the fully qualified class name of each AuthenticatorFactory "
"implementation you have in the jar.  For example:"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"org.keycloak.examples.authenticator.SecretQuestionAuthenticatorFactory\n"
"org.keycloak.examples.authenticator.AnotherProviderFactory\n"
msgstr ""

#. type: Plain text
msgid ""
"This services/ file is used by {project_name} to scan the providers it has "
"to load into the system."
msgstr ""

#. type: Plain text
msgid "To deploy this jar, just copy it to the providers directory."
msgstr ""

#. type: Title ====
#, no-wrap
msgid "Extending the CredentialModel class"
msgstr ""

#. type: Plain text
msgid ""
"In {project_name}, credentials are stored in the database in the Credentials "
"table. It has the following structure:"
msgstr ""

#. type: Title -
#, no-wrap
msgid "| ID                        |"
msgstr ""

#. type: Title -
#, no-wrap
msgid "| user_ID                   |"
msgstr ""

#. type: Title -
#, no-wrap
msgid "| credential_type           |"
msgstr ""

#. type: Title -
#, no-wrap
msgid "| created_date              |"
msgstr ""

#. type: Title -
#, no-wrap
msgid "| user_label                |"
msgstr ""

#. type: Title -
#, no-wrap
msgid "| secret_data               |"
msgstr ""

#. type: Title -
#, no-wrap
msgid "| credential_data           |"
msgstr ""

#. type: Title -
#, no-wrap
msgid "| priority                  |"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "Where:\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"* `ID` is the primary key of the credential.\n"
"* `user_ID` is the foreign key linking the credential to a user.\n"
"* `credential_type` is a string set during the creation that must reference an existing credential type.\n"
"* `created_date` is the creation timestamp (in long format) of the credential.\n"
"* `user_label` is the editable name of the credential by the user\n"
"* `secret_data` contains a static json with the information that cannot be transmitted outside of {project_name}\n"
"* `credential_data` contains a json with the static information of the credential that can be shared in the admin console or via the REST API.\n"
"* `priority` defines how \"preferred\" a credential is for a user, to determine which credential to present when a user has multiple choices.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"As the secret_data and credential_data fields are designed to contain json, it is up to you to determine how to structure, read and write into\n"
"these fields, allowing you a lot of flexibility.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "For this example, we are going to use a very simple credential data, containing only the question asked to the user:\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "[source]\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"{\n"
"  \"question\":\"aQuestion\"\n"
"}\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "with an equally simple secret data, containing only the secret answer:\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"{\n"
"  \"answer\":\"anAnswer\"\n"
"}\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Here the answer will be kept in plain text in the database for the sake of simplicity, but it would also be possible to have a salted hash for the answer,\n"
"as is the case for passwords in {project_name}. In this case, the secret data would also have to contain a field for the salt, and the credential data information\n"
"about the algorithm such as the type of algorithm used and the number of iterations used. For more details you can consult the implementation of the\n"
"`org.keycloak.models.credential.PasswordCredentialModel` class.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "In our case we create the class `SecretQuestionCredentialModel`:\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "[source,java]\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"public class SecretQuestionCredentialModel extends CredentialModel {\n"
"    public static final String TYPE = \"SECRET_QUESTION\";\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    private final SecretQuestionCredentialData credentialData;\n"
"    private final SecretQuestionSecretData secretData;\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Where `TYPE` is the credential_type we write in the database. For consistency, we make sure that this String is always the one referenced when\n"
"getting the type for this credential. The classes `SecretQuestionCredentialData` and `SecretQuestionSecretData` are used to marshal and unmarshal the json:\n"
msgstr ""

#. type: Plain text
msgid "public class SecretQuestionCredentialData {"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    private final String question;\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    @JsonCreator\n"
"    public SecretQuestionCredentialData(@JsonProperty(\"question\") String question) {\n"
"        this.question = question;\n"
"    }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    public String getQuestion() {\n"
"        return question;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
msgid "public class SecretQuestionSecretData {"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "     private final String answer;\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    @JsonCreator\n"
"     public SecretQuestionSecretData(@JsonProperty(\"answer\") String answer) {\n"
"         this.answer = answer;\n"
"     }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    public String getAnswer() {\n"
"        return answer;\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"To be fully usable, the `SecretQuestionCredentialModel` objects must both contain the raw json data from its parent class,\n"
"and the unmarshalled objects in its own attributes. This leads us to create a method which reads from a simple CredentialModel,\n"
"such as is created when reading from the database, to make a `SecretQuestionCredentialModel`:\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"private SecretQuestionCredentialModel(SecretQuestionCredentialData credentialData, SecretQuestionSecretData secretData) {\n"
"    this.credentialData = credentialData;\n"
"    this.secretData = secretData;\n"
"}\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"public static SecretQuestionCredentialModel createFromCredentialModel(CredentialModel credentialModel){\n"
"    try {\n"
"        SecretQuestionCredentialData credentialData = JsonSerialization.readValue(credentialModel.getCredentialData(), SecretQuestionCredentialData.class);\n"
"        SecretQuestionSecretData secretData = JsonSerialization.readValue(credentialModel.getSecretData(), SecretQuestionSecretData.class);\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"        SecretQuestionCredentialModel secretQuestionCredentialModel = new SecretQuestionCredentialModel(credentialData, secretData);\n"
"        secretQuestionCredentialModel.setUserLabel(credentialModel.getUserLabel());\n"
"        secretQuestionCredentialModel.setCreatedDate(credentialModel.getCreatedDate());\n"
"        secretQuestionCredentialModel.setType(TYPE);\n"
"        secretQuestionCredentialModel.setId(credentialModel.getId());\n"
"        secretQuestionCredentialModel.setSecretData(credentialModel.getSecretData());\n"
"        secretQuestionCredentialModel.setCredentialData(credentialModel.getCredentialData());\n"
"        return secretQuestionCredentialModel;\n"
"    } catch (IOException e){\n"
"        throw new RuntimeException(e);\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "And a method to create a `SecretQuestionCredentialModel` from the question and answer:\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"private SecretQuestionCredentialModel(String question, String answer) {\n"
"    credentialData = new SecretQuestionCredentialData(question);\n"
"    secretData = new SecretQuestionSecretData(answer);\n"
"}\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"public static SecretQuestionCredentialModel createSecretQuestion(String question, String answer) {\n"
"    SecretQuestionCredentialModel credentialModel = new SecretQuestionCredentialModel(question, answer);\n"
"    credentialModel.fillCredentialModelFields();\n"
"    return credentialModel;\n"
"}\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"private void fillCredentialModelFields(){\n"
"    try {\n"
"        setCredentialData(JsonSerialization.writeValueAsString(credentialData));\n"
"        setSecretData(JsonSerialization.writeValueAsString(secretData));\n"
"        setType(TYPE);\n"
"        setCreatedDate(Time.currentTimeMillis());\n"
"    } catch (IOException e) {\n"
"        throw new RuntimeException(e);\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "==== Implementing a CredentialProvider\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"As with all Providers, to allow {project_name} to generate the CredentialProvider, we require a CredentialProviderFactory. For this requirement we create\n"
"the SecretQuestionCredentialProviderFactory, whose `create` method will be called when a SecretQuestionCredentialProvider is asked for:\n"
msgstr ""

#. type: Plain text
msgid ""
"public class SecretQuestionCredentialProviderFactory implements "
"CredentialProviderFactory<SecretQuestionCredentialProvider> {"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    public static final String PROVIDER_ID =  \"secret-question\";\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    @Override\n"
"    public String getId() {\n"
"        return PROVIDER_ID;\n"
"    }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    @Override\n"
"    public CredentialProvider create(KeycloakSession session) {\n"
"        return new SecretQuestionCredentialProvider(session);\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "The CredentialProvider interface takes a generic parameter that extends a CredentialModel. In our case we to use the SecretQuestionCredentialModel we created:\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"public class SecretQuestionCredentialProvider implements CredentialProvider<SecretQuestionCredentialModel>, CredentialInputValidator {\n"
"    private static final Logger logger = Logger.getLogger(SecretQuestionCredentialProvider.class);\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    protected KeycloakSession session;\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    public SecretQuestionCredentialProvider(KeycloakSession session) {\n"
"        this.session = session;\n"
"    }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    private UserCredentialStore getCredentialStore() {\n"
"        return session.userCredentialManager();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"We also want to implement the CredentialInputValidator interface, as this allows {project_name} to know that this provider can also be used to validate a\n"
"credential for an Authenticator. For the CredentialProvider interface, the first method that needs to be implemented is the `getType()` method. This will simply\n"
"return the `SecretQuestionCredentialModel`'s TYPE String:\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"@Override\n"
"public String getType() {\n"
"    return SecretQuestionCredentialModel.TYPE;\n"
"}\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The second method is to create a `SecretQuestionCredentialModel` from a `CredentialModel`. For this method we simply call the existing static method\n"
"from `SecretQuestionCredentialModel`:\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"@Override\n"
"public SecretQuestionCredentialModel getCredentialFromModel(CredentialModel model) {\n"
"    return SecretQuestionCredentialModel.createFromCredentialModel(model);\n"
"}\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Finally, we have the methods to create a credential and delete a credential. These methods call the KeycloakSession's `userCredentialManager`, which\n"
"is responsible for knowing where to read or write the credential, for example local storage or federated storage.\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"@Override\n"
"public CredentialModel createCredential(RealmModel realm, UserModel user, SecretQuestionCredentialModel credentialModel) {\n"
"    if (credentialModel.getCreatedDate() == null) {\n"
"        credentialModel.setCreatedDate(Time.currentTimeMillis());\n"
"    }\n"
"    return getCredentialStore().createCredential(realm, user, credentialModel);\n"
"}\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"@Override\n"
"public void deleteCredential(RealmModel realm, UserModel user, String credentialId) {\n"
"    getCredentialStore().removeStoredCredential(realm, user, credentialId);\n"
"}\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"For the CredentialInputValidator, the main method to implement is the `isValid`, which tests whether a credential is valid for a\n"
"given user in a given realm. This is the method that is called by the Authenticator when it seeks to validate the user's input. Here we\n"
"simply need to check that the input String is the one recorded in the Credential:\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"@Override\n"
"public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {\n"
"    if (!(input instanceof UserCredentialModel)) {\n"
"        logger.debug(\"Expected instance of UserCredentialModel for CredentialInput\");\n"
"        return false;\n"
"    }\n"
"    if (!input.getType().equals(getType())) {\n"
"        return false;\n"
"    }\n"
"    String challengeResponse = input.getChallengeResponse();\n"
"    if (challengeResponse == null) {\n"
"        return false;\n"
"    }\n"
"    CredentialModel credentialModel = getCredentialStore().getStoredCredentialById(realm, user, input.getCredentialId());\n"
"    SecretQuestionCredentialModel sqcm = getCredentialFromModel(credentialModel);\n"
"    return sqcm.getSecretQuestionSecretData().getAnswer().equals(challengeResponse);\n"
"}\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The other two methods to implement are a test if the CredentialProvider supports the given credential type and a test to check\n"
"if the credential type is configured for a given user. For our case, the latter test simply means checking if the user has a credential\n"
"of the SECRET_QUESTION type:\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"@Override\n"
"public boolean supportsCredentialType(String credentialType) {\n"
"    return getType().equals(credentialType);\n"
"}\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"@Override\n"
"public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {\n"
"    if (!supportsCredentialType(credentialType)) return false;\n"
"    return !getCredentialStore().getStoredCredentialsByType(realm, user, credentialType).isEmpty();\n"
"}\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "==== Implementing an Authenticator\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"When implementing an authenticator that uses Credentials to authenticate a user, you should have the authenticator implement\n"
"the CredentialValidator interface. This interfaces takes a class extending a CredentialProvider as a parameter, and will\n"
"allow {project_name} to directly call the methods from the CredentialProvider. The only method that needs to be implemented is\n"
"`getCredentialProvider` method, which in our example allows the SecretQuestionAuthenticator to retrieve the SecretQuestionCredentialProvider:\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"public SecretQuestionCredentialProvider getCredentialProvider(KeycloakSession session) {\n"
"    return (SecretQuestionCredentialProvider)session.getProvider(CredentialProvider.class, SecretQuestionCredentialProviderFactory.PROVIDER_ID);\n"
"}\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"When implementing the Authenticator interface, the first method that needs to be implemented is the requiresUser() method.\n"
"For our example, this method must return true as we need to validate the secret question associated with the user.\n"
"A provider like kerberos would return false from this method as it can resolve a user from the negotiate header.\n"
"This example, however, is validating a specific credential of a specific user.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The next method to implement is the configuredFor() method.\n"
"This method is responsible for determining if the user is configured for this particular authenticator. In our case,\n"
"we can just call the method implemented in the SecretQuestionCredentialProvider\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"@Override\n"
"public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {\n"
"    return getCredentialProvider(session).isConfiguredFor(realm, user, getType(session));\n"
"}\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The next method to implement on the Authenticator is setRequiredActions(). If configuredFor() returns false and our example authenticator\n"
"is required within the flow, this method will be called, but only if the associated AuthenticatorFactory's `isUserSetupAllowed` method returns true.\n"
"The setRequiredActions() method is responsible for registering any required actions that must be performed by the user.\n"
"In our example, we need to register a required action that will force the user to set up the answer to the secret question.\n"
"We will implement this required action provider later in this chapter.\n"
"Here is the implementation of the setRequiredActions() method.\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    @Override\n"
"    public void setRequiredActions(KeycloakSession session, RealmModel realm, UserModel user) {\n"
"        user.addRequiredAction(\"SECRET_QUESTION_CONFIG\");\n"
"    }\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Now we are getting into the meat of the Authenticator implementation.\n"
"The next method to implement is authenticate().  This is the initial method the flow invokes when the execution is first visited.\n"
"What we want is that if a user has answered the secret question already on their browser's machine, then the user doesn't\n"
"have to answer the question again, making that machine \"trusted\".  The authenticate() method isn't responsible for processing the secret question form.\n"
"Its sole purpose is to render the page or to continue the flow.\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"@Override\n"
"public void authenticate(AuthenticationFlowContext context) {\n"
"    if (hasCookie(context)) {\n"
"        context.success();\n"
"        return;\n"
"    }\n"
"    Response challenge = context.form()\n"
"            .createForm(\"secret-question.ftl\");\n"
"    context.challenge(challenge);\n"
"}\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"protected boolean hasCookie(AuthenticationFlowContext context) {\n"
"    Cookie cookie = context.getHttpRequest().getHttpHeaders().getCookies().get(\"SECRET_QUESTION_ANSWERED\");\n"
"    boolean result = cookie != null;\n"
"    if (result) {\n"
"        System.out.println(\"Bypassing secret question because cookie is set\");\n"
"    }\n"
"    return result;\n"
"}\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The hasCookie() method checks to see if there is already a cookie set on the browser which indicates that the secret question has already been answered.\n"
"If that returns true, we just mark this execution's status as SUCCESS using the AuthenticationFlowContext.success() method and returning from the authentication() method.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"If the hasCookie() method returns false, we must return a response that renders the secret question HTML form.\n"
"AuthenticationFlowContext has a form() method that initializes a Freemarker page builder with appropriate base information needed to build the form.\n"
"This page builder is called `org.keycloak.login.LoginFormsProvider`. The LoginFormsProvider.createForm() method loads a Freemarker template file from your login theme.\n"
"Additionally you can call the LoginFormsProvider.setAttribute() method if you want to pass additional information to the Freemarker template.\n"
"We'll go over this later.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Calling LoginFormsProvider.createForm() returns a JAX-RS Response object.\n"
"We then call AuthenticationFlowContext.challenge() passing in this response.\n"
"This sets the status of the execution as CHALLENGE and if the execution is Required, this JAX-RS Response object will be sent to the browser.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"So, the HTML page asking for the answer to a secret question is displayed to the user and the user enters in the answer and clicks submit.\n"
"The action URL of the HTML form will send an HTTP request to the flow.\n"
"The flow will end up invoking the action() method of our Authenticator implementation.\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"@Override\n"
"public void action(AuthenticationFlowContext context) {\n"
"    boolean validated = validateAnswer(context);\n"
"    if (!validated) {\n"
"        Response challenge =  context.form()\n"
"                .setError(\"badSecret\")\n"
"                .createForm(\"secret-question.ftl\");\n"
"        context.failureChallenge(AuthenticationFlowError.INVALID_CREDENTIALS, challenge);\n"
"        return;\n"
"    }\n"
"    setCookie(context);\n"
"    context.success();\n"
"}\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"If the answer is not valid, we rebuild the HTML Form with an additional error message.\n"
"We then call AuthenticationFlowContext.failureChallenge() passing in the reason for the value and the JAX-RS response.\n"
"failureChallenge() works the same as challenge(), but it also records the failure so it can be analyzed by any attack detection service.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "If validation is successful, then we set a cookie to remember that the secret question has been answered and we call AuthenticationFlowContext.success().\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The validation itself gets the data that was received from the form, and calls the isValid method from the SecretQuestionCredentialProvider. You'll notice\n"
"that there's a section of the code concerning getting the credential Id. This is because if {project_name} is configured to allow multiple types of alternative\n"
"authenticators, or if the user could record multiple credentials of the SECRET_QUESTION type (for example if we allowed to choose from several questions,\n"
"and we allowed the user to have answers for more than one of those questions), then {project_name} needs to know which credential is being used to log the user.\n"
"In case there is more than one credential, {project_name} allows the user to choose during the login which credential is being used, and the information is transmitted by\n"
"the form to the Authenticator.\n"
"In case the form doesn't present this information, credential id used is given by the CredentialProvider's `default getDefaultCredential` method, which will\n"
"return the \"most preferred\" credential of the correct type of the user,\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"protected boolean validateAnswer(AuthenticationFlowContext context) {\n"
"    MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"    String secret = formData.getFirst(\"secret_answer\");\n"
"    String credentialId = context.getSelectedCredentialId();\n"
"    if (credentialId == null || credentialId.isEmpty()) {\n"
"        credentialId = getCredentialProvider(context.getSession())\n"
"                .getDefaultCredential(context.getSession(), context.getRealm(), context.getUser()).getId();\n"
"        context.setSelectedCredentialId(credentialId);\n"
"    }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    UserCredentialModel input = new UserCredentialModel(credentialId, getType(context.getSession()), secret);\n"
"    return getCredentialProvider(context.getSession()).isValid(context.getRealm(), context.getUser(), input);\n"
"}\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The last thing to go over is the setCookie() method.\n"
"This is an example of providing configuration for the Authenticator.\n"
"In this case we want the max age of the cookie to be configurable.\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"protected void setCookie(AuthenticationFlowContext context) {\n"
"    AuthenticatorConfigModel config = context.getAuthenticatorConfig();\n"
"    int maxCookieAge = 60 * 60 * 24 * 30; // 30 days\n"
"    if (config != null) {\n"
"        maxCookieAge = Integer.valueOf(config.getConfig().get(\"cookie.max.age\"));\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    }\n"
"    URI uri = context.getUriInfo().getBaseUriBuilder().path(\"realms\").path(context.getRealm().getName()).build();\n"
"    addCookie(context, \"SECRET_QUESTION_ANSWERED\", \"true\",\n"
"            uri.getRawPath(),\n"
"            null, null,\n"
"            maxCookieAge,\n"
"            false, true);\n"
"}\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"We obtain an AuthenticatorConfigModel from the AuthenticationFlowContext.getAuthenticatorConfig() method.\n"
"If configuration exists we pull the max age config out of it.\n"
"We will see how we can define what should be configured when we talk about the AuthenticatorFactory implementation.\n"
"The config values can be defined within the admin console if you set up config definitions in your AuthenticatorFactory implementation.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "==== Implementing an AuthenticatorFactory\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The next step in this process is to implement an AuthenticatorFactory.\n"
"This factory is responsible for instantiating an Authenticator.\n"
"It also provides deployment and configuration metadata about the Authenticator.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The getId() method is just the unique name of the component.\n"
"The create() method is called by the runtime to allocate and process the Authenticator.\n"
msgstr ""

#. type: Plain text
msgid ""
"public class SecretQuestionAuthenticatorFactory implements "
"AuthenticatorFactory, ConfigurableAuthenticatorFactory {"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    public static final String PROVIDER_ID = \"secret-question-authenticator\";\n"
"    private static final SecretQuestionAuthenticator SINGLETON = new SecretQuestionAuthenticator();\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    @Override\n"
"    public Authenticator create(KeycloakSession session) {\n"
"        return SINGLETON;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The next thing the factory is responsible for is to specify the allowed requirement switches.\n"
"While there are four different requirement types:  ALTERNATIVE, REQUIRED, CONDITIONAL, DISABLED, AuthenticatorFactory implementations can limit which\n"
"requirement options are shown in the admin console when defining a flow. CONDITIONAL should only always be used for subflows, and unless there's a good\n"
"reason for doing otherwise, the requirement on a authenticator should be REQUIRED, ALTERNATIVE and DISABLED:\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    private static AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {\n"
"            AuthenticationExecutionModel.Requirement.REQUIRED,\n"
"            AuthenticationExecutionModel.Requirement.ALTERNATIVE,\n"
"            AuthenticationExecutionModel.Requirement.DISABLED\n"
"    };\n"
"    @Override\n"
"    public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {\n"
"        return REQUIREMENT_CHOICES;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The AuthenticatorFactory.isUserSetupAllowed() is a flag that tells the flow manager whether or not Authenticator.setRequiredActions() method will be called.\n"
"If an Authenticator is not configured for a user, the flow manager checks isUserSetupAllowed().  If it is false, then the flow aborts with an error.\n"
"If it returns true, then the flow manager will invoke Authenticator.setRequiredActions().\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    @Override\n"
"    public boolean isUserSetupAllowed() {\n"
"        return true;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The next few methods define how the Authenticator can be configured.\n"
"The isConfigurable() method is a flag which specifies to the admin console on whether the Authenticator can be configured within a flow.\n"
"The getConfigProperties() method returns a list of ProviderConfigProperty objects.\n"
"These objects define a specific configuration attribute.\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    @Override\n"
"    public List<ProviderConfigProperty> getConfigProperties() {\n"
"        return configProperties;\n"
"    }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    private static final List<ProviderConfigProperty> configProperties = new ArrayList<ProviderConfigProperty>();\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    static {\n"
"        ProviderConfigProperty property;\n"
"        property = new ProviderConfigProperty();\n"
"        property.setName(\"cookie.max.age\");\n"
"        property.setLabel(\"Cookie Max Age\");\n"
"        property.setType(ProviderConfigProperty.STRING_TYPE);\n"
"        property.setHelpText(\"Max age in seconds of the SECRET_QUESTION_COOKIE.\");\n"
"        configProperties.add(property);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Each ProviderConfigProperty defines the name of the config property.\n"
"This is the key used in the config map stored in AuthenticatorConfigModel.\n"
"The label defines how the config option will be displayed in the admin console.\n"
"The type defines if it is a String, Boolean, or other type.\n"
"The admin console will display different UI inputs depending on the type.\n"
"The help text is what will be shown in the tooltip for the config attribute in the admin console.\n"
"Read the javadoc of ProviderConfigProperty for more detail.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The rest of the methods are for the admin console.\n"
"getHelpText() is the tooltip text that will be shown when you are picking the Authenticator you want to bind to an execution.\n"
"getDisplayType() is the text that will be shown in the admin console when listing the Authenticator.\n"
"getReferenceCategory() is just a category the Authenticator belongs to.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "==== Adding Authenticator Form\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"{project_name} comes with a Freemarker <<_themes,theme and template engine>>.\n"
"The createForm() method you called within authenticate() of your Authenticator class, builds an HTML page from a file within your login theme: `secret-question.ftl`.\n"
"This file should be added to the `theme-resources/templates` in your JAR, see <<_theme_resource,Theme Resource Provider>> for more details.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "Let's take a bigger look at secret-question.ftl  Here's a small code snippet:\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"        <form id=\"kc-totp-login-form\" class=\"${properties.kcFormClass!}\" action=\"${url.loginAction}\" method=\"post\">\n"
"            <div class=\"${properties.kcFormGroupClass!}\">\n"
"                <div class=\"${properties.kcLabelWrapperClass!}\">\n"
"                    <label for=\"totp\" class=\"${properties.kcLabelClass!}\">${msg(\"loginSecretQuestion\")}</label>\n"
"                </div>\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"                <div class=\"${properties.kcInputWrapperClass!}\">\n"
"                    <input id=\"totp\" name=\"secret_answer\" type=\"text\" class=\"${properties.kcInputClass!}\" />\n"
"                </div>\n"
"            </div>\n"
"        </form>\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Any piece of text enclosed in `${}` corresponds to an attribute or template funtion.\n"
"If you see the form's action, you see it points to `${url.loginAction}`.\n"
"This value is automatically generated when you invoke the AuthenticationFlowContext.form() method.\n"
"You can also obtain this value by calling the AuthenticationFlowContext.getActionURL() method in Java code.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"You'll also see `${properties.someValue}`.\n"
"These correspond to properties defined in your theme.properties file of our theme.\n"
" `${msg(\"someValue\")}` corresponds to the internationalized message bundles (.properties files) included with the login theme messages/ directory.\n"
"If you're just using english, you can just add the value of the `loginSecretQuestion`.\n"
"This should be the question you want to ask the user.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"When you call AuthenticationFlowContext.form() this gives you a LoginFormsProvider  instance.\n"
"If you called, `LoginFormsProvider.setAttribute(\"foo\", \"bar\")`, the value of \"foo\" would be available for reference in your form as `${foo}`.\n"
"The value of an attribute can be any Java bean as well.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "If you look at the top of the file, you'll see that we are importing a template:\n"
msgstr ""

#. type: Plain text
msgid "<#import \"select.ftl\" as layout>"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Importing this template, instead of the standard `template.ftl` allows {project_name} to display a dropdown box that allows the user to select\n"
"a different credential or execution.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"[[_adding_authenticator]]\n"
"==== Adding Authenticator to a Flow\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Adding an Authenticator to a flow must be done in the admin console.\n"
"If you go to the Authentication menu item and go to the Flow tab, you will be able to view the currently defined flows.\n"
"You cannot modify built in flows, so, to add the Authenticator we've created you have to copy an existing flow or create your own.\n"
"I'm hoping the UI is intuitive enough so that you can figure out for yourself how to create a flow and add the Authenticator.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"After you've created your flow, you have to bind it to the login action you want to bind it to.\n"
"If you go to the Authentication menu and go  to the Bindings tab you will see options to bind a flow to the browser, registration, or direct grant flow.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "=== Required Action Walkthrough\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"In this section we will discuss how to define a required action.\n"
"In the Authenticator section you may have wondered, \"How will we get the user's answer to the secret question entered into the system?\".  As we showed in the example, if the answer is not set up, a required action will be triggered.\n"
"This section discusses how to implement the required action for the Secret Question Authenticator.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "==== Packaging Classes and Deployment\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"You will package your classes within a single jar.\n"
"This jar does not have to be separate from other provider classes but it must contain a file named  `org.keycloak.authentication.RequiredActionFactory`                and must be contained in the `META-INF/services/` directory of your jar.\n"
"This file must list the fully qualified classname of each RequiredActionFactory implementation you have in the jar.\n"
"For example:\n"
msgstr ""

#. type: Plain text
msgid "org.keycloak.examples.authenticator.SecretQuestionRequiredActionFactory"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "This services/ file is used by {project_name} to scan the providers it has to load into the system.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "To deploy this jar, just copy it to the `standalone/deployments` directory.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "==== Implement the RequiredActionProvider\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Required actions must first implement the RequiredActionProvider interface.\n"
"The RequiredActionProvider.requiredActionChallenge() is the initial call by the flow manager into the required action.\n"
"This method is responsible for rendering the HTML form that will drive the required action.\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    @Override\n"
"    public void requiredActionChallenge(RequiredActionContext context) {\n"
"        Response challenge = context.form().createForm(\"secret_question_config.ftl\");\n"
"        context.challenge(challenge);\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"You see that RequiredActionContext has similar methods to AuthenticationFlowContext.\n"
"The form() method allows you to render the page from a Freemarker template.\n"
"The action URL is preset by the call to this form() method.\n"
"You just need to reference it within your HTML form.\n"
"I'll show you this later.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "The challenge() method notifies the flow manager that a required action must be executed.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The next method is responsible for processing input from the HTML form of the required action.\n"
"The action URL of the form will be routed to the RequiredActionProvider.processAction() method\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    @Override\n"
"    public void processAction(RequiredActionContext context) {\n"
"        String answer = (context.getHttpRequest().getDecodedFormParameters().getFirst(\"answer\"));\n"
"        UserCredentialValueModel model = new UserCredentialValueModel();\n"
"        model.setValue(answer);\n"
"        model.setType(SecretQuestionAuthenticator.CREDENTIAL_TYPE);\n"
"        context.getUser().updateCredentialDirectly(model);\n"
"        context.success();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The answer is pulled out of the form post.\n"
"A UserCredentialValueModel is created and the type and value of the credential are set.\n"
"Then UserModel.updateCredentialDirectly() is invoked.\n"
"Finally, RequiredActionContext.success() notifies the container that the required action was successful.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "==== Implement the RequiredActionFactory\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"This class is really simple.\n"
"It is just responsible for creating the required action provider instance.\n"
msgstr ""

#. type: Plain text
msgid ""
"public class SecretQuestionRequiredActionFactory implements "
"RequiredActionFactory {"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    private static final SecretQuestionRequiredAction SINGLETON = new SecretQuestionRequiredAction();\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    @Override\n"
"    public RequiredActionProvider create(KeycloakSession session) {\n"
"        return SINGLETON;\n"
"    }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    @Override\n"
"    public String getId() {\n"
"        return SecretQuestionRequiredAction.PROVIDER_ID;\n"
"    }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    @Override\n"
"    public String getDisplayText() {\n"
"        return \"Secret Question\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "The getDisplayText() method is just for the admin console when it wants to display a friendly name for the required action.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "==== Enable Required Action\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The final thing you have to do is go into the admin console.\n"
"Click on the Authentication left menu.\n"
"Click on the Required Actions tab.\n"
"Click on the Register button and choose your new Required Action.\n"
"Your new required action should now be displayed and enabled in the required actions list.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "=== Modifying/Extending the Registration Form\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"It is entirely possible for you to implement your own flow with a set of Authenticators to totally change how registration is done in {project_name}.\n"
"But what you'll usually want to do is just add a little bit of validation to the out of the box registration page.\n"
"An additional SPI was created to be able to do this.\n"
"It basically allows you to add validation of form elements on the page as well as to initialize UserModel attributes and data after the user has been registered.\n"
"We'll look at both the implementation of the user profile registration processing as well as the registration Google Recaptcha plugin.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "==== Implementation FormAction Interface\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The core interface you have to implement is the FormAction interface.\n"
"A FormAction is responsible for rendering and processing a portion of the page.\n"
"Rendering is done in the buildPage() method, validation is done in the validate() method, post validation operations are done in success().  Let's first take a look at buildPage() method of the Recaptcha plugin.\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    @Override\n"
"    public void buildPage(FormContext context, LoginFormsProvider form) {\n"
"        AuthenticatorConfigModel captchaConfig = context.getAuthenticatorConfig();\n"
"        if (captchaConfig == null || captchaConfig.getConfig() == null\n"
"                || captchaConfig.getConfig().get(SITE_KEY) == null\n"
"                || captchaConfig.getConfig().get(SITE_SECRET) == null\n"
"                ) {\n"
"            form.addError(new FormMessage(null, Messages.RECAPTCHA_NOT_CONFIGURED));\n"
"            return;\n"
"        }\n"
"        String siteKey = captchaConfig.getConfig().get(SITE_KEY);\n"
"        form.setAttribute(\"recaptchaRequired\", true);\n"
"        form.setAttribute(\"recaptchaSiteKey\", siteKey);\n"
"        form.addScript(\"https://www.google.com/recaptcha/api.js\");\n"
"    }\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The Recaptcha buildPage() method is a callback by the form flow to help render the page.\n"
"It receives a form parameter which is a LoginFormsProvider.\n"
"You can add additional attributes to the form provider so that they can be displayed in the HTML page generated by the registration Freemarker template.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The code above is from the registration recaptcha plugin.\n"
"Recaptcha requires some specific settings that must be obtained from configuration.\n"
"FormActions are configured in the exact same as Authenticators are.\n"
"In this example, we pull the Google Recaptcha site key from configuration and add it as an attribute to the form provider.\n"
"Our registration template file can read this attribute now.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Recaptcha also has the requirement of loading a JavaScript script.\n"
"You can do this by calling LoginFormsProvider.addScript() passing in the URL.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "For user profile processing, there is no additional information that it needs to add to the form, so its buildPage() method is empty.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"The next meaty part of this interface is the validate() method.\n"
"This is called immediately upon receiving a form post.\n"
"Let's look at the Recaptcha's plugin first.\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    @Override\n"
"    public void validate(ValidationContext context) {\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        List<FormMessage> errors = new ArrayList<>();\n"
"        boolean success = false;\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"        String captcha = formData.getFirst(G_RECAPTCHA_RESPONSE);\n"
"        if (!Validation.isBlank(captcha)) {\n"
"            AuthenticatorConfigModel captchaConfig = context.getAuthenticatorConfig();\n"
"            String secret = captchaConfig.getConfig().get(SITE_SECRET);\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"            success = validateRecaptcha(context, success, captcha, secret);\n"
"        }\n"
"        if (success) {\n"
"            context.success();\n"
"        } else {\n"
"            errors.add(new FormMessage(null, Messages.RECAPTCHA_FAILED));\n"
"            formData.remove(G_RECAPTCHA_RESPONSE);\n"
"            context.validationError(formData, errors);\n"
"            return;\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Here we obtain the form data that the Recaptcha widget adds to the form.\n"
"We obtain the Recaptcha secret key from configuration.\n"
"We then validate the recaptcha.\n"
"If successful, ValidationContext.success() is called.\n"
"If not, we invoke ValidationContext.validationError() passing in the formData (so the user doesn't have to re-enter data), we also specify an error message we want displayed.\n"
"The error message must point to a message bundle property in the internationalized message bundles.\n"
"For other registration extensions validate() might be validating the format of a form element, i.e.\n"
"an alternative email attribute.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "Let's also look at the user profile plugin that is used to validate email address and other user information when registering.\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    @Override\n"
"    public void validate(ValidationContext context) {\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        List<FormMessage> errors = new ArrayList<>();\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "        String eventError = Errors.INVALID_REGISTRATION;\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"        if (Validation.isBlank(formData.getFirst((RegistrationPage.FIELD_FIRST_NAME)))) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_FIRST_NAME, Messages.MISSING_FIRST_NAME));\n"
"        }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"        if (Validation.isBlank(formData.getFirst((RegistrationPage.FIELD_LAST_NAME)))) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_LAST_NAME, Messages.MISSING_LAST_NAME));\n"
"        }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"        String email = formData.getFirst(Validation.FIELD_EMAIL);\n"
"        if (Validation.isBlank(email)) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.MISSING_EMAIL));\n"
"        } else if (!Validation.isEmailValid(email)) {\n"
"            formData.remove(Validation.FIELD_EMAIL);\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.INVALID_EMAIL));\n"
"        }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"        if (context.getSession().users().getUserByEmail(email, context.getRealm()) != null) {\n"
"            formData.remove(Validation.FIELD_EMAIL);\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.EMAIL_EXISTS));\n"
"        }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"        if (errors.size() > 0) {\n"
"            context.validationError(formData, errors);\n"
"            return;\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"        } else {\n"
"            context.success();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"As you can see, this validate() method of user profile processing makes sure that the email, first, and last name are filled in the form.\n"
"It also makes sure that email is in the right format.\n"
"If any of these validations fail, an error message is queued up for rendering.\n"
"Any fields in error are removed from the form data.\n"
"Error messages are represented by the FormMessage class.\n"
"The first parameter of the constructor of this class takes the HTML element id.\n"
"The input in error will be highlighted when the form is re-rendered.\n"
"The second parameter is a message reference id.\n"
"This id must correspond to a property in one of the localized message bundle files.\n"
"in the theme.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"After all validations have been processed then, the form flow then invokes the FormAction.success() method.\n"
"For recaptcha this is a no-op, so we won't go over it.\n"
"For user profile processing, this method fills in values in the registered user.\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    @Override\n"
"    public void success(FormContext context) {\n"
"        UserModel user = context.getUser();\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        user.setFirstName(formData.getFirst(RegistrationPage.FIELD_FIRST_NAME));\n"
"        user.setLastName(formData.getFirst(RegistrationPage.FIELD_LAST_NAME));\n"
"        user.setEmail(formData.getFirst(RegistrationPage.FIELD_EMAIL));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Pretty simple implementation.\n"
"The UserModel of the newly registered user is obtained from the FormContext.\n"
"The appropriate methods are called to initialize UserModel data.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Finally, you are also required to define a FormActionFactory class.\n"
"This class is implemented similarly to AuthenticatorFactory, so we won't go over it.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "==== Packaging the Action\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"You will package your classes within a single jar.\n"
"This jar must contain a file named  `org.keycloak.authentication.FormActionFactory`                and must be contained in the `META-INF/services/` directory of your jar.\n"
"This file must list the fully qualified class name of each FormActionFactory implementation you have in the jar.\n"
"For example:\n"
msgstr ""

#. type: Plain text
msgid ""
"org.keycloak.authentication.forms.RegistrationProfile org.keycloak."
"authentication.forms.RegistrationRecaptcha"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "==== Adding FormAction to the Registration Flow\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Adding a FormAction to a registration page flow must be done in the admin console.\n"
"If you go to the Authentication menu item and go to the Flow tab, you will be able to view the currently defined flows.\n"
"You cannot modify built in flows, so, to add the Authenticator we've created you have to copy an existing flow or create your own.\n"
"I'm hoping the UI is intuitive enough so that you can figure out for yourself how to create a flow and add the FormAction.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Basically you'll have to copy the registration flow.\n"
"Then click Actions menu to the right of the Registration Form, and pick \"Add execution\" to add a new execution.\n"
"You'll pick the FormAction from the selection list.\n"
"Make sure your FormAction comes after \"Registration User Creation\" by using the down buttons to move it if your FormAction isn't already listed after \"Registration User Creation\".  You want your FormAction to come after user creation because the success() method of Registration User Creation is responsible for creating the new UserModel.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"After you've created your flow, you have to bind it to registration.\n"
"If you go to the Authentication menu and go  to the Bindings tab you will see options to bind a flow to the browser, registration, or direct grant flow.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "=== Modifying Forgot Password/Credential Flow\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"{project_name} also has a specific authentication flow for forgot password, or rather credential reset initiated by a user.\n"
"If you go to the admin console flows page, there is a \"reset credentials\" flow.\n"
"By default, {project_name} asks for the email or username of the user and sends an email to them.\n"
"If the user clicks on the link, then they are able to reset both their password and OTP (if an OTP has been set up).  You can disable automatic OTP reset by disabling the \"Reset OTP\" authenticator in the flow.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"You can add additional functionality to this flow as well.\n"
"For example, many deployments would like for the user to answer one or more secret questions in additional to sending an email with a link.\n"
"You could expand on the secret question example that comes with the distro and incorporate it into the reset credential flow.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"One thing to note if you are extending the reset credentials flow.\n"
"The first \"authenticator\" is just a page to obtain the username or email.\n"
"If the username or email exists, then the AuthenticationFlowContext.getUser() will return the located user.\n"
"Otherwise this will be null.\n"
"This form *WILL NOT* re-ask the user to enter in an email or username if the previous email or username did not exist.\n"
"You need to prevent attackers from being able to guess valid users.\n"
"So, if AuthenticationFlowContext.getUser() returns null, you should proceed with the flow to make it look like a valid user was selected.\n"
"I suggest that if you want to add secret questions to this flow, you should ask these questions after the email is sent.\n"
"In other words, add your custom authenticator after the \"Send Reset Email\" authenticator.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "=== Modifying First Broker Login Flow\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"First Broker Login flow is used during first login with some identity provider.\n"
"Term `First Login` means that there is not yet existing {project_name} account linked with the particular authenticated identity provider account.\n"
"For more details about this flow see the `Identity Brokering` chapter in link:{adminguide_link}[{adminguide_name}] .\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"[[_client_authentication]]\n"
"=== Authentication of clients\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"{project_name} actually supports pluggable authentication for https://openid.net/specs/openid-connect-core-1_0.html[OpenID Connect] client applications.\n"
"Authentication of client (application) is used under the hood by the {project_name} adapter during sending any backchannel requests\n"
"to the {project_name} server (like the request for exchange code to access token after successful authentication or request to refresh token).\n"
"But the client authentication can be also used directly by you during `Direct Access grants` (represented by OAuth2 `Resource Owner Password Credentials Flow`)\n"
"or during `Service account` authentication (represented by OAuth2 `Client Credentials Flow`).\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "For more details about {project_name} adapter and OAuth2 flows see link:{adapterguide_link}[{adapterguide_name}].\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "==== Default implementations\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "Actually {project_name} has 2 default implementations of client authentication:\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Traditional authentication with client_id and client_secret::\n"
"  This is default mechanism mentioned in the https://openid.net/specs/openid-connect-core-1_0.html[OpenID Connect]                                or https://tools.ietf.org/html/rfc6749[OAuth2] specification and {project_name} supports it since it's early days.\n"
"  The public client needs to include `client_id` parameter with its ID in the POST request (so it's defacto not authenticated) and the confidential client needs to include `Authorization: Basic` header with the clientId and clientSecret used as username and password.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Authentication with signed JWT::\n"
"  This is based on the https://tools.ietf.org/html/rfc7523[JWT Bearer Token Profiles for OAuth 2.0] specification.\n"
"  The client/adapter generates the https://tools.ietf.org/html/rfc7519[JWT] and signs it with his private key.\n"
"  The {project_name} then verifies the signed JWT with the client's public key and authenticates client based on it.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"See the demo example and especially the `examples/preconfigured-demo/product-app` for the example application showing\n"
"the application using client authentication with signed JWT.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "==== Implement your own client authenticator\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "For plug your own client authenticator, you need to implement few interfaces on both client (adapter) and server side.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Client side::\n"
"Here you need to implement `org.keycloak.adapters.authentication.ClientCredentialsProvider` and put the implementation either to:\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"* your WAR file into WEB-INF/classes . But in this case, the implementation can be used just for this single WAR application\n"
"* Some JAR file, which will be added into WEB-INF/lib of your WAR\n"
"  * Some JAR file, which will be used as jboss module and configured in jboss-deployment-structure.xml of your WAR.                                In all cases, you also need to create the file `META-INF/services/org.keycloak.adapters.authentication.ClientCredentialsProvider`                                either in the WAR or in your JAR.\n"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid ""
"Server side::\n"
"  Here you need to implement `org.keycloak.authentication.ClientAuthenticatorFactory` and `org.keycloak.authentication.ClientAuthenticator` . You also need to add the file `META-INF/services/org.keycloak.authentication.ClientAuthenticatorFactory` with the name of the implementation classes.\n"
"  See <<_auth_spi_walkthrough,authenticators>> for more details.\n"
msgstr ""
