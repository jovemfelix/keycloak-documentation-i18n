# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Nomura Research Institute, Ltd.
# This file is distributed under the same license as the keycloak-documentation-i18n package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n  \n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ==
#, no-wrap
msgid "Setup"
msgstr ""

#. type: Title =
#, no-wrap
msgid "Audience support"
msgstr ""

#. type: Plain text
msgid ""
"Typically, the environment where {project_name} is deployed consists of a "
"set of _confidential_ or _public_ client applications that use "
"{project_name} for authentication."
msgstr ""

#. type: Plain text
msgid ""
"_Services_ (_Resource Servers_ in the https://datatracker.ietf.org/doc/html/"
"draft-ietf-oauth-mtls-08#section-4.2[OAuth 2 specification]) are also "
"available that serve requests from client applications and provide resources "
"to these applications. These services require an _Access token_ (Bearer "
"token) to be sent to them to authenticate a request. This token is obtained "
"by the frontend application upon login to {project_name}."
msgstr ""

#. type: Plain text
msgid ""
"In the environment where trust among services is low, you may encounter this "
"scenario:"
msgstr ""

#. type: Plain text
msgid ""
"A frontend client application requires authentication against {project_name}."
msgstr ""

#. type: Plain text
msgid "{project_name} authenticates a user."
msgstr ""

#. type: Plain text
msgid "{project_name} issues a token to the application."
msgstr ""

#. type: Plain text
msgid "The application uses the token to invoke an untrusted service."
msgstr ""

#. type: Plain text
msgid ""
"The untrusted service returns the response to the application. However, it "
"keeps the applications token."
msgstr ""

#. type: Plain text
msgid ""
"The untrusted service then invokes a trusted service using the applications "
"token. This results in broken security as the untrusted service misuses the "
"token to access other services on behalf of the client application."
msgstr ""

#. type: Plain text
msgid ""
"This scenario is unlikely in environments with a high level of trust between "
"services but not in environments where trust is low. In some environments, "
"this workflow may be correct as the untrusted service may have to retrieve "
"data from a trusted service to return data to the original client "
"application."
msgstr ""

#. type: Plain text
msgid ""
"An unlimited audience is useful when a high level of trust exists between "
"services. Otherwise, the audience should be limited. You can limit the "
"audience and, at the same time, allow untrusted services to retrieve data "
"from trusted services. In this case, ensure that the untrusted service and "
"the trusted service are added as audiences to the token."
msgstr ""

#. type: Plain text
msgid ""
"To prevent any misuse of the access token, limit the audience on the token "
"and configure your services to verify the audience on the token. The flow "
"will change as follows:"
msgstr ""

#. type: Plain text
msgid "A frontend application authenticates against {project_name}."
msgstr ""

#. type: Plain text
msgid ""
"{project_name} issues a token to the application. The application knows that "
"it will need to invoke an untrusted service so it places *scope=<untrusted "
"service>* in the authentication request sent to {project_name} (see "
"<<_client_scopes, Client Scopes section>> for more details about the _scope_ "
"parameter)."
msgstr ""

#. type: Plain text
msgid ""
"The token issued to the application contains a reference to the untrusted "
"service in its audience (*\"audience\": [ \"<untrusted service>\" ]*) which "
"declares that the client uses this access token to invoke the untrusted "
"service."
msgstr ""

#. type: Block title
#, no-wrap
msgid "The untrusted service serves the request to the client application but also keeps the token."
msgstr ""

#. type: Plain text
msgid ""
"The untrusted service invokes a trusted service with the token. Invocation "
"is not successful because the trusted service checks the audience on the "
"token and find that its audience is only for the untrusted service. This "
"behavior is expected and security is not broken."
msgstr ""

#. type: Plain text
msgid ""
"If the client wants to invoke the trusted service later, it must obtain "
"another token by reissuing the SSO login with *scope=<trusted service>*. The "
"returned token will then contain the trusted service as an audience:"
msgstr ""

#. type: delimited block -
#, no-wrap
msgid "\"audience\": [ \"<trusted service>\" ]\n"
msgstr ""

#. type: Plain text
msgid "Use this value to invoke the *<trusted service>*."
msgstr ""

#. type: Plain text
msgid "When setting up audience checking:"
msgstr ""

#. type: Plain text
msgid ""
"Ensure that services are configured to check audience on the access token "
"sent to them by adding the flag *_verify-token-audience_* in the adapter "
"configuration. See link:{adapterguide_link_latest}"
"#_java_adapter_config[Adapter configuration] for details."
msgstr ""

#. type: Plain text
msgid ""
"Ensure that access tokens issued by {project_name} contain all necessary "
"audiences. Audiences can be added using the client roles as described in the "
"<<_audience_resolve, next section>> or hardcoded. See <<_audience_hardcoded, "
"Hardcoded audience>>."
msgstr ""

#. type: Title ==
#, no-wrap
msgid "Automatically add audience"
msgstr ""

#. type: Plain text
msgid ""
"An _Audience Resolve_ protocol mapper is defined in the default client scope "
"_roles_. The mapper checks for clients that have at least one client role "
"available for the current token. The client ID of each client is then added "
"as an audience, which is useful if your service (usually bearer-only) "
"clients rely on client roles."
msgstr ""

#. type: Plain text
msgid ""
"For example, for a bearer-only client and a confidential client, you can use "
"the access token issued for the confidential client to invoke the bearer-"
"only client REST service. The bearer-only client will be automatically added "
"as an audience to the access token issued for the confidential client if the "
"following are true:"
msgstr ""

#. type: Plain text
msgid "The bearer-only client has any client roles defined on itself."
msgstr ""

#. type: Plain text
msgid "Target user has at least one of those client roles assigned."
msgstr ""

#. type: Plain text
msgid "Confidential client has the role scope mappings for the assigned role."
msgstr ""

#. type: delimited block =
msgid ""
"If you want to ensure that the audience is not added automatically, do not "
"configure role scope mappings directly on the confidential client. Instead, "
"you can create a dedicated client scope that contains the role scope "
"mappings for the client roles of your dedicated client scope."
msgstr ""

#. type: delimited block =
msgid ""
"Assuming that the client scope is added as an optional client scope to the "
"confidential client, the client roles and the audience will be added to the "
"token if explicitly requested by the *scope=<trusted service>* parameter."
msgstr ""

#. type: delimited block =
msgid ""
"The frontend client itself is not automatically added to the access token "
"audience, therefore allowing easy differentiation between the access token "
"and the ID token, since the access token will not contain the client for "
"which the token is issued as an audience."
msgstr ""

#. type: delimited block =
msgid ""
"If you need the client itself as an audience, see the <<_audience_hardcoded, "
"hardcoded audience>> option. However, using the same client as both frontend "
"and REST service is not recommended."
msgstr ""

#. type: Title ==
#, no-wrap
msgid "Hardcoded audience"
msgstr ""

#. type: Plain text
msgid ""
"When your service relies on realm roles or does not rely on the roles in the "
"token at all, it can be useful to use a hardcoded audience. A hardcoded "
"audience is a protocol mapper, that will add the client ID of the specified "
"service client as an audience to the token.  You can use any custom value, "
"for example a URL, if you want to use a different audience than the client "
"ID."
msgstr ""

#. type: Plain text
msgid ""
"You can add the protocol mapper directly to the frontend client. If the "
"protocol mapper is added directly, the audience will be always added as well."
msgstr ""

#. type: Plain text
msgid ""
"For more control over the protocol mapper, you can create the protocol "
"mapper on the dedicated client scope, which will be called for example *good-"
"service*."
msgstr ""

#. type: Block title
#, no-wrap
msgid "Audience protocol mapper"
msgstr ""

#. type: Plain text
msgid "image:{project_images}/audience_mapper.png[]"
msgstr ""

#. type: Plain text
msgid ""
"From the <<_client_installation, Installation tab>> of the *good-service* "
"client, you can generate the adapter configuration and you can confirm that "
"_verify-token-audience_ option will be set to *true*. This forces the "
"adapter to verify the audience if you use this configuration."
msgstr ""

#. type: Plain text
msgid ""
"You need to ensure that the confidential client is able to request *good-"
"service* as an audience in its tokens."
msgstr ""

#. type: Plain text
msgid "On the confidential client:"
msgstr ""

#. type: Plain text
msgid "Click the _Client Scopes_ tab."
msgstr ""

#. type: Plain text
msgid "Assign *good-service* as an optional (or default) client scope."
msgstr ""

#. type: Plain text
msgid ""
"See <<_client_scopes_linking, Client Scopes Linking section>> for more "
"details."
msgstr ""

#. type: Plain text
msgid ""
"You can optionally <<_client_scopes_evaluate, Evaluate Client Scopes>> and "
"generate an example access token. *good-service* will be added to the "
"audience of the generated access token if *good-service* is included in the "
"_scope_ parameter, when you assigned it as an optional client scope."
msgstr ""

#. type: Plain text
msgid ""
"In your confidential client application, ensure that the _scope_ parameter "
"is used. The value *good-service* must be included when you want to issue "
"the token for accessing *good-service*."
msgstr ""

#. type: Plain text
msgid "See:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"** link:{adapterguide_link}#_params_forwarding[parameters forwarding section] if your application uses the servlet adapter.\n"
"** link:{adapterguide_link}#_javascript_adapter[javascript adapter section] if your application uses the javascript adapter.\n"
msgstr ""

#. type: Plain text
msgid ""
"Both the _Audience_ and _Audience Resolve_ protocol mappers add the "
"audiences to the access token only, by default. The ID Token typically "
"contains only a single audience, the client ID for which the token was "
"issued, a requirement of the OpenID Connect specification. However, the "
"access token does not necessarily have the client ID, which was the token "
"issued for, unless the audience mappers added it."
msgstr ""
